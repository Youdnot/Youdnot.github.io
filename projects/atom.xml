<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iTimeTraveler</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://itimetraveler.github.io/"/>
  <updated>2019-12-02T09:48:04.711Z</updated>
  <id>https://itimetraveler.github.io/</id>
  
  <author>
    <name>Mr.Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Uber使用QUIC协议优化App网络性能</title>
    <link href="https://itimetraveler.github.io/2019/12/02/Uber%E4%BD%BF%E7%94%A8QUIC%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96App%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
    <id>https://itimetraveler.github.io/2019/12/02/Uber使用QUIC协议优化App网络性能/</id>
    <published>2019-12-02T03:08:00.000Z</published>
    <updated>2019-12-02T09:48:04.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://eng.uber.com/employing-quic-protocol/" target="_blank" rel="noopener">Employing QUIC Protocol to Optimize Uber’s App Performance</a></p></blockquote><p>Uber operates on a global scale across more than 600 cities, with our apps relying entirely on wireless connectivity from over 4,500 mobile carriers. To deliver the real-time performance expected from Uber’s users, our mobile apps require low-latency and highly reliable network communication. Unfortunately, the <a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a> stack fares poorly in dynamic, lossy wireless networks, and we learned that poor performance can often be traced directly to Transmission Control Protocol (TCP) implementations buried in OS kernels.</p><p>Uber在全球600个城市运营，我们的APP完全依赖于4500家移动网络运营商提供的无线网络服务。为了提供Uber用户期望的实时性能，我们的手机应用需要低延迟、高可用的网络通信。不幸的是，HTTP/2协议在动态、有损的无线网络中表现不佳，我们了解到低性能的原因通常被追溯定位到内核中的TCP实现。</p><p>To address these pain points, we adopted the <a href="https://en.wikipedia.org/wiki/QUIC" target="_blank" rel="noopener">QUIC protocol</a>, a stream-multiplexed modern transport protocol implemented over UDP, which enables us to better control the transport protocol performance. QUIC is currently being standardized by the <a href="https://www.ietf.org/" target="_blank" rel="noopener">Internet Engineering Task Force</a> (IETF) as <a href="https://github.com/quicwg" target="_blank" rel="noopener">HTTP/3</a>.</p><p>After thorough testing of QUIC, we concluded that integrating QUIC in our apps would fchroreduce the tail-end latencies compared to TCP. We witnessed a reduction of 10-30 percent in tail-end latencies for HTTPS traffic at scale in our rider and driver apps. In addition to improving the performance of our apps in low connectivity networks, QUIC gives us end-to-end control over the flow of packets in the user space.</p><p>In this article, we share our experiences optimizing TCP performance for Uber’s apps by moving to a network stack that supports the QUIC protocol.</p><h2 id="State-of-the-Art-TCP"><a href="#State-of-the-Art-TCP" class="headerlink" title="State of the Art: TCP"></a>State of the Art: TCP</h2><p>On today’s Internet, <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">TCP</a> is the most widely adopted transport protocol for carrying HTTPS traffic. TCP provides a reliable byte stream, dealing with the complexities of network <a href="https://en.wikipedia.org/wiki/TCP_congestion_control" target="_blank" rel="noopener">congestion</a> and link layer <a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">losses</a>. The widespread use of TCP for HTTPS traffic is mainly attributed to ubiquity (almost every OS includes TCP), availability on a wide range of infrastructure, such as load balancers, HTTPS <a href="https://www.nginx.com/" target="_blank" rel="noopener">proxies</a>, and <a href="https://www.akamai.com/us/en/resources/content-distribution-network.jsp" target="_blank" rel="noopener">CDNs</a>, and it’s out-of-the-box functionality for most platforms and networks.</p><p>Most users access Uber’s services on the move, and the tail-end latencies of our applications running on TCP were far from meeting the requirements of the real-time nature of our HTTPS traffic. Specifically, users perceived high tail-end latencies across the world. In Figure 1, below, we plot the tail-end latencies of our HTTPS network calls across major cities:</p><p><img src="/gallery/common/image3-1068x531.png" alt="Figure 1. Tail-end latencies vary across the major cities where Uber operates."></p><p>Although the latencies in India and Brazil’s networks were worse than those in the US and UK, the tail-end latencies are significantly higher than the average latencies, even in the case of the US and UK.</p><a id="more"></a><h3 id="TCP-Performance-over-wireless"><a href="#TCP-Performance-over-wireless" class="headerlink" title="TCP Performance over wireless"></a>TCP Performance over wireless</h3><p>TCP was originally designed for <em>wired</em> networks, which have largely predictable links. However, <em>wireless</em> networks have unique characteristics and challenges. Firstly, wireless networks are susceptible to losses from interference and signal attenuation. For instance, WiFi networks are susceptible to interference from microwaves, bluetooth, and other types of radio waves. Cellular networks are affected by signal loss (or <a href="https://en.wikipedia.org/wiki/Path_loss" target="_blank" rel="noopener">path loss</a>) due to reflection/absorption by things in the environment, such as buildings, and <a href="https://en.wikipedia.org/wiki/Co-channel_interference" target="_blank" rel="noopener">interference</a> from neighboring <a href="http://www.artizanetworks.com/resources/tutorials/what_lteenb.html" target="_blank" rel="noopener">base stations</a>. These result in much higher (e.g: 4-10x) and variable Round-trip times (<a href="https://en.wikipedia.org/wiki/Round-trip_delay_time" target="_blank" rel="noopener">RTTs</a>) and packet loss than wired counterparts.</p><p>To overcome intermittent fluctuations in bandwidth and loss, cellular networks typically employ large buffers to absorb traffic bursts. Large buffers can cause excessive queueing, causing longer delays. TCP often interprets such queuing as loss due to time out durations, so it tends to retransmit and further fill up the buffer. This problem, known as <a href="https://queue.acm.org/detail.cfm?id=2071893" target="_blank" rel="noopener">bufferbloat</a>, is a major <a href="http://conferences.sigcomm.org/sigcomm/2012/paper/cellnet/p1.pdf" target="_blank" rel="noopener">challenge</a> in today’s Internet.</p><p>Finally, cellular network performance <a href="https://pdfs.semanticscholar.org/00aa/a84be127c04a21b5f5f8dc5d2426921654e2.pdf" target="_blank" rel="noopener">varies</a> significantly across carriers, regions, and time. In Figure 2, below, we plot the median latencies of HTTPS traffic in Uber’s rider app across hexagons of 2 kilometers for two major mobile carriers in Delhi, India. As can be seen in the figure, the network performance varies significantly across the hexagons in the same city. Also, the performance is significantly different for two of the top carriers. Factors such as user access patterns based on location and time, user mobility, and the network deployment of the carrier based on the density of the towers and the proportion of the types of networks (LTE, 3G, etc.) cause network load variations across location and carriers.</p><p><img src="/gallery/common/image4-1068x478.png" alt="Figure 2: Charting tail-end latencies over two-kilometer hexagons in Delhi, India, we see major differences from two different carriers."></p><p>In addition to varying across locations, the cellular network performance varies over time. As shown in Figure 3, below, the median latency across two kilometer hexagons for the same region within Delhi and the same carrier fluctuates across the days of the week. We also saw variations within finer time scales, such as within a day and an hour.</p><p><img src="/gallery/common/image1-1068x259.png" alt="Figure 3: Tail-end latencies can vary considerably from day to day, on the same carrier."></p><p>The above characteristics translate into inefficiencies in TCP’s performance on wireless networks. However, before looking into alternatives to TCP,  we wanted to develop a key understanding of the problem space by assessing the following considerations:</p><ul><li>Is TCP the main contributor to the high tail-end latencies on our mobile applications?</li><li>Do current networks have significantly high RTT variance and losses?</li><li>What is the impact of the high RTTs and losses on the performance of TCP?</li></ul><h3 id="TCP-performance-analysis"><a href="#TCP-performance-analysis" class="headerlink" title="TCP performance analysis"></a>TCP performance analysis</h3><p>To better understand how we analyze TCP performance, let’s first briefly explain how TCP transfers data from a sender to a receiver. Initially, the sender sets up a TCP connection by performing a three-way <a href="https://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml" target="_blank" rel="noopener">handshake</a>: the sender transmits a SYN packet, waits for a SYN-ACK packet from the receiver, then sends an ACK packet. An additional two to three round trips are spent on setting up a <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">TLS</a> connection. Each data packet is ACKed by the receiver to ensure reliable delivery.</p><p>In the case that a packet or ACK is lost, the sender retransmits the packet after the expiration of a <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">retransmission timeout</a> (RTO). The RTO is dynamically computed based on various factors, such as the estimate of the RTT between the sender and the receiver.</p><p><img src="/gallery/common/image10-1068x578.png" alt="Figure 4: TCP/TLS packet exchanges include a mechanism to retransmit lost packets."></p><p>To determine how the TCP flow was performing in our apps, we collected TCP packet traces using <a href="https://www.tcpdump.org/" target="_blank" rel="noopener">tcpdump</a> for a week of production traffic from Uber’s edge servers for connections originating from India. We then analyzed the TCP connections using <a href="http://www.tcptrace.org/" target="_blank" rel="noopener">tcptrace</a>. In addition, we also built an Android application that sends emulated traffic to a test server closely mimicking real traffic. The application collects TCP traces in the background, and uploads the logs to a back-end server. Android phones running this application were handed out to a few employees in India, who collected logs for a period of a few days.</p><p>The results were consistent from both experiments. We witnessed high RTT values, and tail-end values being almost <em>six times</em> the median value, with an average variance of more than one second. Additionally, most connections were lossy, causing TCP to retransmit 3.5 percent of total packets. In congested locations, such as railway stations and airports, we witnessed as high as 7 percent of packets being dropped by the network. These results challenge a common notion that cellular networks’ <a href="http://www.sharetechnote.com/html/BasicProcedure_LTE_HARQ.html" target="_blank" rel="noopener">advanced retransmission schemes</a> significantly reduce losses at the transport layer. Below, we outline our results running tests on our mock application:</p><table><thead><tr><th><strong>Network Metrics</strong></th><th><strong>Values</strong></th></tr></thead><tbody><tr><td><strong>RTT in msecs [50%,75%, 95%,99%]</strong></td><td>[350, 425, 725, 2300]</td></tr><tr><td><strong>RTT variance in secs</strong></td><td>Average ~ 1.2 seconds</td></tr><tr><td><strong>Packet Loss Rate in lossy connections</strong></td><td>Average ~3.5% (7% in congestion areas)</td></tr></tbody></table><p>Almost half of these connections saw at least one packet loss, with a significant number of connections suffering losses of SYN and SYN-ACK packets. Since TCP uses highly conservative RTO values for retransmitting SYN and SYN-ACK packets compared to data packets, most TCP implementations use an initial RTO of one second for SYN packets, with the RTO exponentially increased for subsequent losses. The initial load time of the application can suffer as TCP takes more time to setup the connections.</p><p>In the case of data packets, high RTOs effectively reduce network utilization in the presence of transient losses in the wireless networks. We found that the average time to retransmit is around <em>one</em> <em>second</em>, with tail-end times being almost 30 seconds. These high delays in the TCP layer were causing the HTTPS transfer to timeout and retry the request, leading to further latency and network inefficiency.</p><p>While the 75th percentile of the measured RTTs on our networks was around 425 milliseconds, the 75th percentile of TCP back-off was almost three seconds. This result implies that losses cause TCP to take 7 times-10 times round-trips to actually transmit the data successfully. This can be attributed to the inefficient computation of RTOs, TCP’s inability to react quickly to loss of last few packets in a window (<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41217.pdf" target="_blank" rel="noopener">tail loss</a>), and inefficiencies in the congestion control algorithm, which does not differentiate between wireless losses and losses due to network congestion. Below, we outline the results of our TCP packet loss tests:</p><table><thead><tr><th><strong>TCP Packet Loss Stats</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>Percentage of connections with at least 1 packet loss</td><td>45%</td></tr><tr><td>Percentage of connections with loss that have packet loss during connection establishment</td><td>30%</td></tr><tr><td>Percentage of connections with loss that have packet loss during data exchange</td><td>76%</td></tr><tr><td>Distribution of delays in retransmission in seconds [50%, 75%, 95%,99%]</td><td>[1, 2.8, 15, 28]</td></tr><tr><td>Distribution of the number of retransmissions for a given packet or TCP segment</td><td>[1,3,6,7]</td></tr></tbody></table><h2 id="Adopting-QUIC"><a href="#Adopting-QUIC" class="headerlink" title="Adopting QUIC"></a>Adopting QUIC</h2><p>Originally designed by Google, <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf" target="_blank" rel="noopener">QUIC</a> is a stream-multiplexed modern transport protocol implemented over UDP.  Currently, QUIC is being standardized as a part of an ongoing <a href="https://quicwg.github.io/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">IETF effort</a>. As depicted in Figure 5, below, QUIC transparently sits under HTTP/3 (HTTP/2 over QUIC is being standardized as HTTP/3). It replaces portions of HTTPS and TCP layers on the stack, using UDP for packet framing. QUIC only supports secure data transmission, hence the TLS layer is completely embedded within QUIC.</p><p><img src="/gallery/common/image8.png" alt="Figure 5: QUIC sits under HTTP/3, absorbing the secure TLS layer which formerly ran under HTTP/2."></p><p>Below, we outline <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf" target="_blank" rel="noopener">features</a> that made it compelling for us to adopt QUIC in addition to TCP for this edge communication:</p><ul><li><strong>0-RTT connection establishment:</strong> QUIC allows reuse of the security credential established in previous connections, reducing the overhead of secure connection handshakes by way of sending data in the first round trip. In the future, <a href="https://www.ietf.org/blog/tls13/" target="_blank" rel="noopener">TLS1.3</a> will support 0-RTT, but the TCP three-way handshake will still be required.</li><li><strong>Overcoming HoL blocking:</strong> HTTP/2 uses a single TCP connection to each origin to improve performance, but this can lead to head-of-line (HoL) blocking. For instance, an object B (e.g, trip request) may get blocked behind another object A (e.g, logging request) which experiences loss. In this case, delivery of B is delayed until A can recover from the loss. However, QUIC facilitates multiplexing and delivers a request to the application independent of other requests that are being exchanged.  </li><li><strong>Congestion control:</strong> QUIC sits in the application layer, making it easier to update the core algorithm of the transport protocol that controls the sending rate based on network conditions, such as packet loss and RTT. Most TCP deployments use the <a href="https://www.cs.princeton.edu/courses/archive/fall16/cos561/papers/Cubic08.pdf" target="_blank" rel="noopener">CUBIC</a> algorithm, which is not optimal for delay-sensitive traffic. Recently developed algorithms, such as <a href="https://queue.acm.org/detail.cfm?id=3022184" target="_blank" rel="noopener">BBR</a>, model the network more accurately and optimize for latency. QUIC lets us enable BBR and update the algorithm as it <a href="https://datatracker.ietf.org/meeting/102/materials/slides-102-iccrg-an-update-on-bbr-work-at-google-00" target="_blank" rel="noopener">evolves</a>.</li><li><strong>Loss Recovery:</strong> QUIC invokes two tail loss probes (<a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01" target="_blank" rel="noopener">TLP</a>) before RTO is triggered even when a loss is outstanding, which is different from some TCP implementations. TLP essentially retransmits the last packet (or a new packet, if available) to trigger fast recovery. Tail loss handling is particularly useful for Uber’s network traffic patterns, which are composed of short, sporadic latency-sensitive transfers.</li><li><strong>Optimized ACKing:</strong> Since each packet carries a unique sequence number, the <a href="https://www.extrahop.com/company/blog/2016/karns-algorithm/" target="_blank" rel="noopener">problem</a> of distinguishing retransmission from delayed packets is eliminated. The ACK packets also contain the time to process the packet and generate the ACK at the client level. These features ensure that QUIC more accurately estimates the RTT. QUIC’s ACKs support up to 256 <a href="https://webrtcglossary.com/nack/" target="_blank" rel="noopener">NACK</a> ranges, helping the sender to be more resilient to packet reordering and ensuring fewer bytes on the wire. Selective ACK (<a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">SACK</a>) in TCP does not resolve this problem in all cases.</li><li><strong>Connection Migration:</strong> QUIC connections are identified by a 64 bit connection ID, so that if a client changes IP addresses, it can continue to use the old connection ID from the new IP address without interrupting any in-flight requests. This is a common occurrence in mobile applications when a user switches between WiFi and cellular connections.</li></ul><h3 id="Alternatives-to-QUIC-considered"><a href="#Alternatives-to-QUIC-considered" class="headerlink" title="Alternatives to QUIC considered"></a>Alternatives to QUIC considered</h3><p>Before settling on QUIC, we looked into alternative approaches to improving TCP performance across our apps.</p><p>We first tried deploying TCP Points of Presence (PoPs) to terminate the TCP connections closer to users. Essentially, PoPs terminates the TCP connection to the mobile device closer to the cellular network and reverse proxies the traffic to the original infrastructure. By terminating the TCP closer, we can potentially reduce the RTT, and ensure that TCP is more reactive to the dynamic wireless environment. However, our experiments proved that the bulk of the RTT and loss is coming from cellular networks and use of PoPs did not provide a significant performance improvement.</p><p>We also looked into tuning the parameters of TCP to improve app performance. Tuning TCP stacks across our heterogeneous edge servers was challenging, since TCP has disparate implementations across different versions of the OS. It was difficult to apply and verify the different configuration changes across the network. Tuning the TCP configurations on the mobile devices themselves was impossible due to a lack of privileges. More fundamentally, features like 0-RTT connections and better RTT estimation are central to protocol design and it is not possible to reap such benefits by simply tuning TCP alone.</p><p>Finally, we assessed a few <a href="https://en.wikipedia.org/wiki/Real-Time_Media_Flow_Protocol" target="_blank" rel="noopener">UDP</a>-based protocols that have addressed shortcomings for video streaming to see if they might be leveraged for our use case.  However, they lack industry grade security features and typically assume a complementary TCP connection for metadata and control information.</p><p>To the best of our knowledge and based on our research, QUIC was one of very few protocols that addressed the general problem for Internet traffic, taking into account both security and performance.</p><h3 id="QUIC-integration-on-the-Uber-platform"><a href="#QUIC-integration-on-the-Uber-platform" class="headerlink" title="QUIC integration on the Uber platform"></a>QUIC integration on the Uber platform</h3><p>To successfully integrate QUIC and improve app performance in low connectivity networks, we replaced Uber’s legacy networking stack (HTTP/2 over TLS/TCP) with the QUIC protocol. We leveraged the <a href="https://developer.android.com/guide/topics/connectivity/cronet" target="_blank" rel="noopener">Cronet¹</a> networking library from the <a href="https://www.chromium.org/Home" target="_blank" rel="noopener">Chromium Projects</a> which implement a version of the QUIC protocol (gQUIC) that was originally designed by Google. The implementation is continuously <a href="https://groups.google.com/a/chromium.org/forum/#!topic/proto-quic/b6gZ18W5qn0" target="_blank" rel="noopener">evolving</a> to follow the latest IETF specification.</p><p>We first integrated Cronet into our Android applications to enable QUIC support. The integration was done in a way to ensure zero migration cost for our mobile engineers. Instead of completely replacing our legacy network stack that used the <a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a> library, we integrated the Cronet library under the OkHttp API framework. By performing the integration in this way, we avoided changes to the API layer of our network calls, which rely on <a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a>.</p><p>In addition, we also avoided changing core networking functions that perform such tasks as failover, redirects, and compression. We leveraged the interceptor mechanism of OkHttp to implement middleware to seamlessly intercept HTTP traffic from the application and send the traffic to the Cronet library using Java <a href="https://developer.android.com/guide/topics/connectivity/cronet" target="_blank" rel="noopener">APIs</a>. We still use the OkHttp library in cases where the Cronet library fails to load for certain Android devices.</p><p>Similar to our Android approach, we integrated Cronet into Uber’s iOS applications by intercepting HTTP traffic from the iOS networking <a href="https://developer.apple.com/documentation/foundation/nsurlsession" target="_blank" rel="noopener">APIs</a> using <a href="https://developer.apple.com/documentation/foundation/nsurlprotocol" target="_blank" rel="noopener">NSURLProtocol</a>. This abstraction, provided by the iOS Foundation, handles loading protocol-specific URL data and ensures that we can integrate Cronet into our iOS applications without significant migration costs.</p><h3 id="QUIC-termination-on-Google-Cloud-Load-Balancers"><a href="#QUIC-termination-on-Google-Cloud-Load-Balancers" class="headerlink" title="QUIC termination on Google Cloud Load Balancers"></a>QUIC termination on Google Cloud Load Balancers</h3><p>On the backend, the QUIC termination is <a href="https://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml" target="_blank" rel="noopener">provided</a> by a Google Cloud Load balancing infrastructure that supports QUIC using the <a href="https://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml" target="_blank" rel="noopener">alt-svc</a> header on responses. Essentially, on every HTTP response, the load balancer adds an alt-svc header that validates QUIC support for that domain. When the Cronet client receives an HTTP response with an alt-svc header, it uses QUIC for the following HTTP requests sent to that domain. Once the load balancer terminates QUIC, our infrastructure transparently forwards it over HTTP2/TCP to our back-end data centers.</p><h2 id="Performance-results"><a href="#Performance-results" class="headerlink" title="Performance results"></a>Performance results</h2><p>Given performance is the primary reason for our exploration of a better transport protocol, we first set up a <a href="https://code.fb.com/production-engineering/augmented-traffic-control-a-tool-to-simulate-network-conditions/" target="_blank" rel="noopener">network emulation</a> testbed to study how QUIC performs under different network profiles in the lab. To verify QUIC’s performance gains in real networks, we then conducted on-road experiments in New Delhi using emulated traffic that closely replays the highly frequent HTTPS network calls in our rider application.</p><h3 id="Experiment-one"><a href="#Experiment-one" class="headerlink" title="Experiment one"></a>Experiment one</h3><p>The experiment setup, outlined below, consists of the following components:</p><ol><li>Android test devices with the OkHttp and Cronet network stack to ensure we can run HTTPS traffic over both TCP and QUIC, respectively.</li><li>A Java-based emulation server that sends stubbed HTTPS response headers and payloads to the client devices upon receiving HTTPS requests.</li><li>Proxies placed in a cloud region close to India to terminate the TCP and QUIC connections. While we used the <a href="https://www.nginx.com/" target="_blank" rel="noopener">NGINX</a> reverse proxy to terminate TCP, it was challenging to find an openly available reverse proxy for QUIC. We built a QUIC reverse proxy in-house using the core QUIC stack from Chromium and <a href="https://chromium.googlesource.com/chromium/src/+/4380217c0aa51adff8f624ba412e415e6493413a" target="_blank" rel="noopener">contributed</a> the proxy back to Chromium as open source.</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/gallery/common/image9-768x294.png" alt=""></td><td><img src="/gallery/common/image6-300x225.png" alt=""></td></tr></tbody></table><p><em>Figure 6 : Our on-road experimental setup to test QUIC versus TCP performance consisted of Android devices running the OkHttp and Cronet stacks, cloud-based proxies to terminate the connections, and an emulation server.</em></p><p>The results from this experiment showed that QUIC consistently and very significantly outperformed TCP in terms of latency when downloading the HTTPS responses on the devices. Specifically, we witnessed a 50 percent reduction in latencies across the board, from the 50th percentile to 99th percentile.</p><h3 id="Experiment-two"><a href="#Experiment-two" class="headerlink" title="Experiment two"></a>Experiment two</h3><p>Once Google made QUIC available within <a href="https://cloud.google.com/blog/products/gcp/introducing-quic-support-https-load-balancing" target="_blank" rel="noopener">Google Cloud Load Balancing</a>, we repeated the same experiment setup with one modification: instead of using NGINX, we used the Google Cloud load balancers to terminate the TCP and QUIC connections from the devices and forward the HTTPS traffic to an emulated server. These load balancers are spread across the globe, with the closest PoP server selected based on the geolocation of the device.</p><p><img src="/gallery/common/image5-1068x455.png" alt="Figure 8: In our second experimental setup, we wanted to compare the latency of TCP and QUIC terminating at the Google Cloud versus using our own cloud-based proxy."></p><p>We encountered a few interesting insights from this second experiment:</p><ul><li><strong>PoP termination improved TCP performance:</strong> Since the Google Cloud load balancers terminate the TCP connection closer to users and are well-tuned for performance, the resulting lower RTTs significantly improved the TCP performance. Although QUIC’s gains were lower, it still out-performed TCP by about a 10-30 percent reduction in tail-end latency.</li><li><strong>Long tail impacted by</strong> <a href="https://en.wikipedia.org/wiki/Hop_(networking" target="_blank" rel="noopener"><strong>cellular/wireless hops</strong></a>)<strong>:</strong> Even though our in-house QUIC proxy  was farther away from the device (approximately 50 milliseconds higher latency) than the Google Cloud load balancers, it offered similar performance gains (a 15 percent reduction as opposed to a 20 percent reduction in the 99th percentile against TCP). These results suggests that the last-mile cellular hop is the main bottleneck in the network.</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/gallery/common/image12.png" alt=""></td><td><img src="/gallery/common/image2.png" alt=""></td></tr></tbody></table><p><em>Figure 7. Results from two experiments we ran testing latency showed significant performance gains for QUIC versus TCP.</em></p><h3 id="Production-traffic"><a href="#Production-traffic" class="headerlink" title="Production traffic"></a>Production traffic</h3><p>Encouraged by previous tests, we proceeded by adding QUIC support into our Android and iOS applications. We performed an A/B test between QUIC and TCP to quantify the impact of QUIC across all cities in which Uber operates. Overall, we saw significant reductions in the tail-end latencies across various dimensions, such as region, carrier, and network type.</p><p>Figure 9, below, depicts the percentage improvements in the tail-end latencies (95th and 99th percentile) across different mega-regions and network types (including LTE, 3G, and 2G.):</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/gallery/common/image11.png" alt=""></td><td><img src="/gallery/common/image7.png" alt=""></td></tr></tbody></table><p><em>Figure 8. In our production tests, QUIC consistently outperformed TCP in terms of latency over regions and network types.</em></p><h2 id="Moving-forward"><a href="#Moving-forward" class="headerlink" title="Moving forward"></a>Moving forward</h2><p>We are just getting started: deploying QUIC for mobile applications at our scale has paved the way for several exciting avenues to improve application performance across both high and low connectivity networks, including:</p><h3 id="Increase-QUIC-coverage"><a href="#Increase-QUIC-coverage" class="headerlink" title="Increase QUIC coverage"></a>Increase QUIC coverage</h3><p>Based on the analysis of the protocol’s actual performance on real traffic, we observed that around 80 percent of sessions successfully used QUIC for all requests, while about 15 percent of them used a mix of TCP and QUIC. Our current hypothesis about this mix is that the Cronet code library switches back to TCP upon timeouts since it cannot distinguish UDP failures and actual poor network conditions. We are currently working to solve this problem as we move forward with leveraging the QUIC protocol.</p><h3 id="QUIC-optimization"><a href="#QUIC-optimization" class="headerlink" title="QUIC optimization"></a>QUIC optimization</h3><p>The traffic from Uber’s mobile applications are typically latency-sensitive as opposed to bandwidth-intensive. Also, our applications are primarily accessed using cellular networks. Based on our experiments, the tail-end latencies are still higher despite using proxies that terminate TCP and QUIC close to the user. Our team is actively working on investigating further improvements to control congestion and improve loss recovery algorithms for QUIC to optimize for latency based on our traffic and user access patterns.</p><p>With these improvements and others, we plan to  further enhance the user experience on our platform regardless of network or region, making convenient and seamless transportation more accessible across our global markets.</p><p><em>Interested in building technologies to advance the future of networking? Consider joining <a href="https://www.uber.com/us/en/careers/teams/engineering/" target="_blank" rel="noopener">our team</a>.</em></p><p><strong><em>Acknowledgements</em></strong></p><p><em>Special thanks to James Yu, Sivabalan</em> <em>Narayanan,</em> <em>Minh Pham, Z. Morley Mao, Dilpreet Singh, Praveen Neppalli Naga, Ganesh Srinivasan,</em> <em>Bill Fumerola**, Ali-Reza Adl-Tabatabai, Jatin Lodhia and Liang Ma for their contributions to the project.</em></p><p>¹<em>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (</em><a href="http://www.openssl.org/" target="_blank" rel="noopener"><em>http://www.openssl.org/</em></a><em>). This product includes cryptographic software written by Eric Young (</em><a href="mailto:eay@cryptsoft.com" target="_blank" rel="noopener"><em>eay@cryptsoft.com</em></a><em>).</em></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://eng.uber.com/employing-quic-protocol/" target="_blank" rel="noopener">Employing QUIC Protocol to Optimize Uber’s App Performance</a></li><li><a href="https://www.slideshare.net/dhaval2025/uber-mobility-high-performance-networking" target="_blank" rel="noopener">Uber mobility - High Performance Networking</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://eng.uber.com/employing-quic-protocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Employing QUIC Protocol to Optimize Uber’s App Performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Uber operates on a global scale across more than 600 cities, with our apps relying entirely on wireless connectivity from over 4,500 mobile carriers. To deliver the real-time performance expected from Uber’s users, our mobile apps require low-latency and highly reliable network communication. Unfortunately, the &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP/2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP/2&lt;/a&gt; stack fares poorly in dynamic, lossy wireless networks, and we learned that poor performance can often be traced directly to Transmission Control Protocol (TCP) implementations buried in OS kernels.&lt;/p&gt;
&lt;p&gt;Uber在全球600个城市运营，我们的APP完全依赖于4500家移动网络运营商提供的无线网络服务。为了提供Uber用户期望的实时性能，我们的手机应用需要低延迟、高可用的网络通信。不幸的是，HTTP/2协议在动态、有损的无线网络中表现不佳，我们了解到低性能的原因通常被追溯定位到内核中的TCP实现。&lt;/p&gt;
&lt;p&gt;To address these pain points, we adopted the &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QUIC protocol&lt;/a&gt;, a stream-multiplexed modern transport protocol implemented over UDP, which enables us to better control the transport protocol performance. QUIC is currently being standardized by the &lt;a href=&quot;https://www.ietf.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Internet Engineering Task Force&lt;/a&gt; (IETF) as &lt;a href=&quot;https://github.com/quicwg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP/3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After thorough testing of QUIC, we concluded that integrating QUIC in our apps would fchroreduce the tail-end latencies compared to TCP. We witnessed a reduction of 10-30 percent in tail-end latencies for HTTPS traffic at scale in our rider and driver apps. In addition to improving the performance of our apps in low connectivity networks, QUIC gives us end-to-end control over the flow of packets in the user space.&lt;/p&gt;
&lt;p&gt;In this article, we share our experiences optimizing TCP performance for Uber’s apps by moving to a network stack that supports the QUIC protocol.&lt;/p&gt;
&lt;h2 id=&quot;State-of-the-Art-TCP&quot;&gt;&lt;a href=&quot;#State-of-the-Art-TCP&quot; class=&quot;headerlink&quot; title=&quot;State of the Art: TCP&quot;&gt;&lt;/a&gt;State of the Art: TCP&lt;/h2&gt;&lt;p&gt;On today’s Internet, &lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP&lt;/a&gt; is the most widely adopted transport protocol for carrying HTTPS traffic. TCP provides a reliable byte stream, dealing with the complexities of network &lt;a href=&quot;https://en.wikipedia.org/wiki/TCP_congestion_control&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;congestion&lt;/a&gt; and link layer &lt;a href=&quot;https://tools.ietf.org/html/rfc2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;losses&lt;/a&gt;. The widespread use of TCP for HTTPS traffic is mainly attributed to ubiquity (almost every OS includes TCP), availability on a wide range of infrastructure, such as load balancers, HTTPS &lt;a href=&quot;https://www.nginx.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxies&lt;/a&gt;, and &lt;a href=&quot;https://www.akamai.com/us/en/resources/content-distribution-network.jsp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CDNs&lt;/a&gt;, and it’s out-of-the-box functionality for most platforms and networks.&lt;/p&gt;
&lt;p&gt;Most users access Uber’s services on the move, and the tail-end latencies of our applications running on TCP were far from meeting the requirements of the real-time nature of our HTTPS traffic. Specifically, users perceived high tail-end latencies across the world. In Figure 1, below, we plot the tail-end latencies of our HTTPS network calls across major cities:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/common/image3-1068x531.png&quot; alt=&quot;Figure 1. Tail-end latencies vary across the major cities where Uber operates.&quot;&gt;&lt;/p&gt;
&lt;p&gt;Although the latencies in India and Brazil’s networks were worse than those in the US and UK, the tail-end latencies are significantly higher than the average latencies, even in the case of the US and UK.&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://itimetraveler.github.io/categories/Web/"/>
    
    
      <category term="QUIC" scheme="https://itimetraveler.github.io/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Wifi代理抓包原理</title>
    <link href="https://itimetraveler.github.io/2019/11/27/%E3%80%90Android%E3%80%91Wifi%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://itimetraveler.github.io/2019/11/27/【Android】Wifi设置代理原理解析/</id>
    <published>2019-11-27T14:20:55.000Z</published>
    <updated>2019-11-27T09:20:55.687Z</updated>
    
    <content type="html"><![CDATA[<p>无论是Android还是iOS，都可以在wifi配置中设置一个<strong>代理服务器ip和port</strong>，很多人用这个功能来对移动设备APP的网络请求（准确来说是HTTP请求）进行抓包。这其中的原理是什么？怎么实现的？</p><h1 id="Android源码分析"><a href="#Android源码分析" class="headerlink" title="Android源码分析"></a>Android源码分析</h1><p>从wifi设置中配置了代理服务ip和port之后的生效流程，可以参考这篇文章：<a href="https://bbs.pediy.com/thread-252161.htm" target="_blank" rel="noopener">[原创]Android4.4 wifi代理流程</a></p><a id="more"></a><h1 id="HTTP代理原理"><a href="#HTTP代理原理" class="headerlink" title="HTTP代理原理"></a>HTTP代理原理</h1><h1 id="OkHttp对代理的处理"><a href="#OkHttp对代理的处理" class="headerlink" title="OkHttp对代理的处理"></a>OkHttp对代理的处理</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.jianshu.com/p/ae4d433597ce" target="_blank" rel="noopener">安卓抓包工具开发</a></li><li><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">HTTP 代理原理及实现（一）</a></li><li><a href="https://www.zhihu.com/question/20467503" target="_blank" rel="noopener">如何在 Android 手机上实现抓包？</a></li><li>源码分析 - <a href="https://bbs.pediy.com/thread-252161.htm" target="_blank" rel="noopener">[原创]Android4.4 wifi代理流程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是Android还是iOS，都可以在wifi配置中设置一个&lt;strong&gt;代理服务器ip和port&lt;/strong&gt;，很多人用这个功能来对移动设备APP的网络请求（准确来说是HTTP请求）进行抓包。这其中的原理是什么？怎么实现的？&lt;/p&gt;
&lt;h1 id=&quot;Android源码分析&quot;&gt;&lt;a href=&quot;#Android源码分析&quot; class=&quot;headerlink&quot; title=&quot;Android源码分析&quot;&gt;&lt;/a&gt;Android源码分析&lt;/h1&gt;&lt;p&gt;从wifi设置中配置了代理服务ip和port之后的生效流程，可以参考这篇文章：&lt;a href=&quot;https://bbs.pediy.com/thread-252161.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[原创]Android4.4 wifi代理流程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>移动端(Android、iOS)接入Cronet实践</title>
    <link href="https://itimetraveler.github.io/2019/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8E%A5%E5%85%A5Cronet%E7%BD%91%E7%BB%9C%E5%BA%93%E5%AE%9E%E8%B7%B5/"/>
    <id>https://itimetraveler.github.io/2019/07/25/移动端接入Cronet网络库实践/</id>
    <published>2019-07-25T14:20:55.000Z</published>
    <updated>2019-08-09T05:07:58.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h2><p><a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC, a multiplexed stream transport over UDP</a> 是Chromium使用的通信协议，是基于UDP实现的类似于 TCP+TLS+HTTP/2 的协议。也是HTTP 3.0的设计方案。有兴趣的话大家可参考文档： <a href="https://www.chromium.org/quic/playing-with-quic" target="_blank" rel="noopener">Playing with QUIC</a></p><p>Chromium项目是开源的，The Chromium Projects(<a href="http://dev.chromium.org/chromium-projects" target="_blank" rel="noopener">http://dev.chromium.org/chromium-projects</a>) 文档详细介绍了Chromium项目的实现原理，以及如何获取源码并进行编译。</p><p>Cronet 库是Chrome使用的移动端网络库。支持 HTTP、HTTP/2 以及 QUIC 协议。支持 Android 和 iOS 平台。 其编译工具是 gn 和 ninja，类似于 cmake 与 make 的关系。 下面介绍 Cronet 库的编译及编译注意事项。</p><h2 id="获取Chromium源码"><a href="#获取Chromium源码" class="headerlink" title="获取Chromium源码"></a>获取Chromium源码</h2><p>可以参考官方文档：<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/mac_build_instructions.md" target="_blank" rel="noopener">Checking out and building Chromium for Mac</a></p><p>获取源码之前，首先需要下载安装 <a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up" target="_blank" rel="noopener">depot_tools</a> 工具。在一个适当的目录下clone depot_tools包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span></span><br></pre></td></tr></table></figure><p>将<code>depot_tools</code>的路径（最好是绝对路径，<code>~</code>需替换为<code>$HOME</code>）加进环境变量PATH中，假设 <code>depot_tools</code> 工程在<code>/path/to/depot_tools</code>目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/path/to/depot_tools</span><br></pre></td></tr></table></figure><p>如果从来没有下载过Chromium的代码的话，为源码创建一个文件夹并下载源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir chromium &amp;&amp; cd chromium</span><br><span class="line">fetch --no-history chromium       # 可能花费30min或几小时，依网络速度而不同</span><br></pre></td></tr></table></figure><p><code>–no-history</code> 可以节省代码下载时间，它忽略仓库的历史信息；整个代码量较大，约 14G，且<strong>需要翻墙</strong>，1M 左右的速度需要 20~30 分钟。若中间拉取失败，可以执行 <code>gclient sync</code> 继续拉取， 拉取结束后，该目录会生成一个 src 目录，包含 cronet 源码。</p><a id="more"></a><p>获取源码是很漫长的过程，Chromium项目的源码有8G。我花了2个半小时才完成。中途遇到了download_from_google_storage.py 下载文件没反应的问题，参考了<a href="https://www.jianshu.com/p/08aa03e8ce18" target="_blank" rel="noopener">Chromium的源码获取与编译（2018-06-06）</a></p><p>最终<code>chromium/src</code>代码大小如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -d 1 -h | sort -h</span></span><br><span class="line"> 48K./google_update</span><br><span class="line"> 56K./build_overrides</span><br><span class="line">184K./apps</span><br><span class="line">208K./styleguide</span><br><span class="line">420K./gin</span><br><span class="line">424K./rlz</span><br><span class="line">480K./cloud_print</span><br><span class="line">540K./crypto</span><br><span class="line">564K./jingle</span><br><span class="line">596K./infra</span><br><span class="line">632K./dbus</span><br><span class="line">684K./sql</span><br><span class="line">876K./printing</span><br><span class="line">916K./fuchsia</span><br><span class="line">916K./url</span><br><span class="line">1.0M./ipc</span><br><span class="line">1.0M./pdf</span><br><span class="line">1.1M./skia</span><br><span class="line">2.1M./google_apis</span><br><span class="line">3.4M./storage</span><br><span class="line">3.7M./sandbox</span><br><span class="line">5.0M./courgette</span><br><span class="line">6.2M./build</span><br><span class="line">6.5M./headless</span><br><span class="line">7.4M./chromecast</span><br><span class="line">7.8M./android_webview</span><br><span class="line">7.8M./mojo</span><br><span class="line">9.2M./device</span><br><span class="line">9.2M./testing</span><br><span class="line"> 10M./docs</span><br><span class="line"> 12M./cc</span><br><span class="line"> 13M./ppapi</span><br><span class="line"> 15M./gpu</span><br><span class="line"> 17M./chromeos</span><br><span class="line"> 18M./services</span><br><span class="line"> 19M./remoting</span><br><span class="line"> 20M./extensions</span><br><span class="line"> 22M./base</span><br><span class="line"> 27M./ash</span><br><span class="line"> 41M./native_client_sdk</span><br><span class="line"> 49M./ios</span><br><span class="line"> 75M./ui</span><br><span class="line"> 78M./buildtools</span><br><span class="line"> 80M./media</span><br><span class="line"> 94M./content</span><br><span class="line"> 98M./out</span><br><span class="line">112M./net</span><br><span class="line">158M./tools</span><br><span class="line">295M./components</span><br><span class="line">737M./v8</span><br><span class="line">784M./chrome</span><br><span class="line">1007M./.git</span><br><span class="line">2.0G./native_client</span><br><span class="line"> 13G./third_party</span><br><span class="line"> 19G.</span><br></pre></td></tr></table></figure><p>命令行翻墙，需要使用 http proxy 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8118 </span><br><span class="line">export https_proxy=http://127.0.0.1:8118 </span><br><span class="line"></span><br><span class="line">// git代理，我没有使用</span><br><span class="line">git config --global http.proxy 'socks5://127.0.0.1:1080' </span><br><span class="line">git config --global https.proxy 'socks5://127.0.0.1:1080'</span><br></pre></td></tr></table></figure><p>启动 privoxy 转换 socks5 为 http proxy：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privoxy --no-daemon /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure></p><h2 id="编译Cronet"><a href="#编译Cronet" class="headerlink" title="编译Cronet"></a>编译Cronet</h2><p>Cronet的源码位于 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/" target="_blank" rel="noopener"><code>src/components/cronet</code></a> 目录，官方编译流程可参考<a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/build_instructions.md" target="_blank" rel="noopener">Cronet build instructions</a>，编译环境要求：</p><ul><li>Linux：python 2.7.5，及 jdk 8，较高版本由于接口不兼容需避免使用。</li><li>Mac: python 2.7.5，jdk 8，以及 xcode。 进入 chromium/src 目录，执行下面命令</li></ul><h3 id="Android-iOS-builds"><a href="#Android-iOS-builds" class="headerlink" title="Android / iOS builds"></a>Android / iOS builds</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./components/cronet/tools/cr_cronet.py gn --out_dir=out/Cronet   <span class="comment"># 生成 ninja 文件</span></span></span><br></pre></td></tr></table></figure><p>如果主机是linux，build的是Android的库。如果主机是MacOS，build的是ios库。以下命令在Mac上会生成 cronet 静态库，目录 obj/components/cronet/ios/libcronet*.a</p><h3 id="Desktop-builds-targets-the-current-OS"><a href="#Desktop-builds-targets-the-current-OS" class="headerlink" title="Desktop builds (targets the current OS)"></a>Desktop builds (targets the current OS)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen out/Cronet</span><br></pre></td></tr></table></figure><h3 id="Running-the-ninja-files"><a href="#Running-the-ninja-files" class="headerlink" title="Running the ninja files"></a>Running the ninja files</h3><p>输入 ninja 文件执行编译，必须指定为 cronet_package</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ninja -C out/Cronet cronet_package</span></span><br></pre></td></tr></table></figure><p>这个命令会编译 cronet 模块，及其依赖的所有模块，包括base，crypto，boringssl，protobuf，url等。编译Cronet库，最终文件可以在<code>out/Cronet/cornet</code>中寻找。</p><h3 id="生成的文件"><a href="#生成的文件" class="headerlink" title="生成的文件"></a>生成的文件</h3><p>iOS 库：</p><ul><li>out/MyCronet/obj/components/cronet/ios/libcronet.a， 大小为 89M；</li><li>out/MyCronet/obj/components/cronet/ios/libcronet_static.a， 大小为 17M；</li><li>out/MyCronet/obj/components/cronet/ios/libcronet_deps_complete.a，大小为 1G。</li></ul><p>Android 库：</p><ul><li>out/Cronet-android/lib.java/components/cronet/android/ 所有 jar 包在此目录下，一般不用；</li><li>out/Cronet-android/cronet/  <strong>需要使用cronet库的java API的so、及jar包都在此目录下</strong>；</li><li>out/Cronet-android/libcronet.77.0.3825.0.so，strip 后的库，6M；</li><li>out/Cronet-android/lib.unstripped，未 strip 的库在此目录下。50.9M;</li><li>out/Cronet-android/gen/components/cronet/android/cronet_jni_registration.h，该文件便是自动生成的JNI头文件</li></ul><h2 id="使用Cronet"><a href="#使用Cronet" class="headerlink" title="使用Cronet"></a>使用Cronet</h2><h3 id="Debug-Log"><a href="#Debug-Log" class="headerlink" title="Debug Log"></a>Debug Log</h3><p>C++层的日志可以通过 <code>adb logcat</code> 输出. 但是默认只显示 FATAL 级别的日志。如果想要更改日志输出级别，可以通过以下命令打开chromium日志输出:</p><h4 id="See-VLOG-1-and-VLOG-2-logging"><a href="#See-VLOG-1-and-VLOG-2-logging" class="headerlink" title="See VLOG(1) and VLOG(2) logging:"></a>See VLOG(1) and VLOG(2) logging:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell setprop log.tag.CronetUrlRequestContext VERBOSE</span></span><br></pre></td></tr></table></figure><h4 id="See-VLOG-1-logging"><a href="#See-VLOG-1-logging" class="headerlink" title="See VLOG(1) logging:"></a>See VLOG(1) logging:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell setprop log.tag.CronetUrlRequestContext DEBUG</span></span><br></pre></td></tr></table></figure><h4 id="See-NO-only-FATAL-logging"><a href="#See-NO-only-FATAL-logging" class="headerlink" title="See NO (only FATAL) logging:"></a>See NO (only FATAL) logging:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell setprop log.tag.CronetUrlRequestContext NONE</span></span><br></pre></td></tr></table></figure><h3 id="Network-Log"><a href="#Network-Log" class="headerlink" title="Network Log"></a>Network Log</h3><p>NetLog 是 Chromium 网络模块的日志：<a href="https://www.chromium.org/developers/design-documents/network-stack/netlog" target="_blank" rel="noopener">NetLog: Chrome’s network logging system</a>。可以使用下面两行代码操作 dump 出 chromium 网络模块的日志:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CronetEngine.startNetLogToFile()</span><br><span class="line">CronetEngine.stopNetLog()</span><br></pre></td></tr></table></figure><p>Chromium网络模块的日志输出内容是 JSON 格式的，所以<strong>需要主动调用 <code>stopNetLog()</code> 方法保证 JSON日志的完整性。</strong></p><p>导出的log文件可以使用 <a href="https://netlog-viewer.appspot.com/#import" target="_blank" rel="noopener">https://netlog-viewer.appspot.com/#import</a> 分析。如果打不开，可以使用 <a href="https://chrome.google.com/webstore/detail/chromium-netlog-dump-view/hfnehammfofphmomkllapngelnabmcho" target="_blank" rel="noopener">Chromium NetLog dump viewer</a> 这个Chrome扩展程序。</p><h2 id="GN语法"><a href="#GN语法" class="headerlink" title="GN语法"></a>GN语法</h2><p>参考 <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/quick_start.md" target="_blank" rel="noopener">GN Quick Start guide</a> 和 <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md#Targets" target="_blank" rel="noopener">GN Language and Operation</a>，建议大家先了解下target的概念，因为gn命令操作的基本上都是target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出指定构建目录下所有的targets</span></span><br><span class="line">$ gn ls out/Default </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前环境的配置参数</span></span><br><span class="line">$ gn args --list out/Default</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示关于一个给定target或config的信息。</span></span><br><span class="line"><span class="comment">// usage:  gn desc &lt;out_dir&gt; &lt;label or pattern&gt; [&lt;what to show&gt;] [--blame] [--format=json]</span></span><br><span class="line">$ gn desc out/Default net</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找两个taregets之间的依赖路径</span></span><br><span class="line">$ gn path out/Default <span class="comment">//base //net --all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找反向的依赖(也就是依赖此target的其他targets)</span></span><br><span class="line">$ gn refs out/Default/ <span class="comment">//net</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查头文件依赖的有效性</span></span><br><span class="line">$ gn check out/Default/ <span class="comment">//net</span></span><br></pre></td></tr></table></figure><h2 id="Cronet-request-lifecycle"><a href="#Cronet-request-lifecycle" class="headerlink" title="Cronet request lifecycle"></a>Cronet request lifecycle</h2><p><img src="/gallery/android_commoncronet-lifecycle.svg" alt="The Cronet request lifecycle"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ninja -<span class="built_in">help</span></span></span><br><span class="line">usage: ninja [options] [targets...]</span><br><span class="line"></span><br><span class="line">if targets are unspecified, builds the 'default' target (see manual).</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  --version  print ninja version ("1.8.2")</span><br><span class="line"></span><br><span class="line">  -C DIR   change to DIR before doing anything else</span><br><span class="line">  -f FILE  specify input build file [default=build.ninja]</span><br><span class="line"></span><br><span class="line">  -j N     run N jobs in parallel [default=6, derived from CPUs available]</span><br><span class="line">  -k N     keep going until N jobs fail [default=1]</span><br><span class="line">  -l N     do not start new jobs if the load average is greater than N</span><br><span class="line">  -n       dry run (don't run commands but act like they succeeded)</span><br><span class="line">  -v       show all command lines while building</span><br><span class="line"></span><br><span class="line">  -d MODE  enable debugging (use -d list to list modes)</span><br><span class="line">  -t TOOL  run a subtool (use -t list to list subtools)</span><br><span class="line">    terminates toplevel options; further flags are passed to the tool</span><br><span class="line">  -w FLAG  adjust warnings (use -w list to list warnings)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/build_instructions.md" target="_blank" rel="noopener">Cronet build instructions</a> - Google chromium官方文档 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/" target="_blank" rel="noopener">Cronet源码</a></li><li><a href="https://mp.weixin.qq.com/s/NbewZ1NU49qSjIcdFrpotw" target="_blank" rel="noopener">QUIC协议初探-iOS实践</a></li><li><a href="https://www.infoq.cn/article/mogujie-app-chromium-network-layer/" target="_blank" rel="noopener">蘑菇街 App Chromium 网络栈实践</a></li><li><a href="https://juejin.im/post/5d087863f265da1b6029053c" target="_blank" rel="noopener">Cronet 库编译指南</a></li><li><a href="https://eng.uber.com/employing-quic-protocol/" target="_blank" rel="noopener">Employing QUIC Protocol to Optimize Uber’s App Performance</a> - Uber Engineering Blog</li><li><a href="https://developer.android.com/guide/topics/connectivity/cronet/lifecycle" target="_blank" rel="noopener">Cronet request lifecycle</a></li><li><a href="https://www.infoq.cn/article/2017/10/qzone-quic-practise" target="_blank" rel="noopener">QQ 空间已在生产环境中使用 QUIC 协议</a></li><li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=786559" target="_blank" rel="noopener">Cronet should provide Native API for use on Android and iOS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;QUIC协议&quot;&gt;&lt;a href=&quot;#QUIC协议&quot; class=&quot;headerlink&quot; title=&quot;QUIC协议&quot;&gt;&lt;/a&gt;QUIC协议&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.chromium.org/quic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QUIC, a multiplexed stream transport over UDP&lt;/a&gt; 是Chromium使用的通信协议，是基于UDP实现的类似于 TCP+TLS+HTTP/2 的协议。也是HTTP 3.0的设计方案。有兴趣的话大家可参考文档： &lt;a href=&quot;https://www.chromium.org/quic/playing-with-quic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Playing with QUIC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chromium项目是开源的，The Chromium Projects(&lt;a href=&quot;http://dev.chromium.org/chromium-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dev.chromium.org/chromium-projects&lt;/a&gt;) 文档详细介绍了Chromium项目的实现原理，以及如何获取源码并进行编译。&lt;/p&gt;
&lt;p&gt;Cronet 库是Chrome使用的移动端网络库。支持 HTTP、HTTP/2 以及 QUIC 协议。支持 Android 和 iOS 平台。 其编译工具是 gn 和 ninja，类似于 cmake 与 make 的关系。 下面介绍 Cronet 库的编译及编译注意事项。&lt;/p&gt;
&lt;h2 id=&quot;获取Chromium源码&quot;&gt;&lt;a href=&quot;#获取Chromium源码&quot; class=&quot;headerlink&quot; title=&quot;获取Chromium源码&quot;&gt;&lt;/a&gt;获取Chromium源码&lt;/h2&gt;&lt;p&gt;可以参考官方文档：&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/mac_build_instructions.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Checking out and building Chromium for Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;获取源码之前，首先需要下载安装 &lt;a href=&quot;https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;depot_tools&lt;/a&gt; 工具。在一个适当的目录下clone depot_tools包：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://chromium.googlesource.com/chromium/tools/depot_tools.git&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将&lt;code&gt;depot_tools&lt;/code&gt;的路径（最好是绝对路径，&lt;code&gt;~&lt;/code&gt;需替换为&lt;code&gt;$HOME&lt;/code&gt;）加进环境变量PATH中，假设 &lt;code&gt;depot_tools&lt;/code&gt; 工程在&lt;code&gt;/path/to/depot_tools&lt;/code&gt;目录下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:/path/to/depot_tools&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果从来没有下载过Chromium的代码的话，为源码创建一个文件夹并下载源码：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir chromium &amp;amp;&amp;amp; cd chromium&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch --no-history chromium       # 可能花费30min或几小时，依网络速度而不同&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;–no-history&lt;/code&gt; 可以节省代码下载时间，它忽略仓库的历史信息；整个代码量较大，约 14G，且&lt;strong&gt;需要翻墙&lt;/strong&gt;，1M 左右的速度需要 20~30 分钟。若中间拉取失败，可以执行 &lt;code&gt;gclient sync&lt;/code&gt; 继续拉取， 拉取结束后，该目录会生成一个 src 目录，包含 cronet 源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】 使用VPN实现抓包</title>
    <link href="https://itimetraveler.github.io/2019/07/25/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8VPN%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"/>
    <id>https://itimetraveler.github.io/2019/07/25/【Android】使用VPN实现抓包/</id>
    <published>2019-07-25T14:20:55.000Z</published>
    <updated>2019-12-13T09:54:12.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VPN抓包"><a href="#VPN抓包" class="headerlink" title="VPN抓包"></a>VPN抓包</h2><p>使用VPN技术可以直接获得网络三层IP报文，可以不可以基于此实现移动端抓包呢？肯定可以，Android已经有大批开源库基于该思路实现抓包。我们来学习下原理。</p><h2 id="VpnService"><a href="#VpnService" class="headerlink" title="VpnService"></a>VpnService</h2><p>VpnService是开发Android VPN的基础，下面是<a href="https://developer.android.com/reference/android/net/VpnService" target="_blank" rel="noopener">官方文档</a>的阐释</p><blockquote><p>VpnService is a base class for applications to extend and build their own VPN solutions. In general, it creates a virtual network interface, configures addresses and routing rules, and returns a file descriptor to the application. Each read from the descriptor retrieves an outgoing packet which was routed to the interface. Each write to the descriptor injects an incoming packet just like it was received from the interface. The interface is running on Internet Protocol (IP), so packets are always started with IP headers. The application then completes a VPN connection by processing and exchanging packets with the remote server over a tunnel.</p></blockquote><p>上面的阐释的重点是：</p><ul><li>虚拟一个网卡</li><li>返回文件描述符</li><li>读写的内容是ip数据报</li></ul><p>首先推荐Android官方提供了的Example：<a href="https://android.googlesource.com/platform/development/+/master/samples/ToyVpn" target="_blank" rel="noopener">ToyVpn</a>。这个例子比较简单，实操一遍可以帮助理解VPN原理。</p><p>初步搭一个vpn应用框架也可以参考<a href="https://www.tuicool.com/articles/uuiMje" target="_blank" rel="noopener">这篇文章</a>，这个仅仅是搭建了框架，功能（ip数据包的收发）则没有实现。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Android系统提供的API是VpnService，我们调用<code>establish()</code>方法之后会返回一个FD。然后我们读取该FD就能获得ip数据报文，通过发往VPN Server，再获得Server的回复报文之后再写入该FD，就可以实现VPN通信。</p><h3 id="VpnService-establish"><a href="#VpnService-establish" class="headerlink" title="VpnService#establish()"></a>VpnService#establish()</h3><p>[-&gt; frameworks/base/core/java/android/net/VpnService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Create a VPN interface using the parameters supplied to this</span></span><br><span class="line"><span class="comment">* builder. The interface works on IP packets, and a file descriptor</span></span><br><span class="line"><span class="comment">* is returned for the application to access them. Each read</span></span><br><span class="line"><span class="comment">* retrieves an outgoing packet which was routed to the interface.</span></span><br><span class="line"><span class="comment">* Each write injects an incoming packet just like it was received</span></span><br><span class="line"><span class="comment">* from the interface. The file descriptor is put into non-blocking</span></span><br><span class="line"><span class="comment">* mode by default to avoid blocking Java threads. To use the file</span></span><br><span class="line"><span class="comment">* descriptor completely in native space, see</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> ParcelFileDescriptor#detachFd()&#125;. The application MUST</span></span><br><span class="line"><span class="comment">* close the file descriptor when the VPN connection is terminated.</span></span><br><span class="line"><span class="comment">* The VPN interface will be removed and the network will be</span></span><br><span class="line"><span class="comment">* restored by the system automatically.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;To avoid conflicts, there can be only one active VPN interface</span></span><br><span class="line"><span class="comment">* at the same time. Usually network parameters are never changed</span></span><br><span class="line"><span class="comment">* during the lifetime of a VPN connection. It is also common for an</span></span><br><span class="line"><span class="comment">* application to create a new file descriptor after closing the</span></span><br><span class="line"><span class="comment">* previous one. However, it is rare but not impossible to have two</span></span><br><span class="line"><span class="comment">* interfaces while performing a seamless handover. In this case, the</span></span><br><span class="line"><span class="comment">* old interface will be deactivated when the new one is created</span></span><br><span class="line"><span class="comment">* successfully. Both file descriptors are valid but now outgoing</span></span><br><span class="line"><span class="comment">* packets will be routed to the new interface. Therefore, after</span></span><br><span class="line"><span class="comment">* draining the old file descriptor, the application MUST close it</span></span><br><span class="line"><span class="comment">* and start using the new file descriptor. If the new interface</span></span><br><span class="line"><span class="comment">* cannot be created, the existing interface and its file descriptor</span></span><br><span class="line"><span class="comment">* remain untouched.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;An exception will be thrown if the interface cannot be created</span></span><br><span class="line"><span class="comment">* for any reason. However, this method returns &#123;<span class="doctag">@code</span> null&#125; if the</span></span><br><span class="line"><span class="comment">* application is not prepared or is revoked. This helps solve</span></span><br><span class="line"><span class="comment">* possible race conditions between other VPN applications.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ParcelFileDescriptor&#125; of the VPN interface, or</span></span><br><span class="line"><span class="comment">*         &#123;<span class="doctag">@code</span> null&#125; if the application is not prepared.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException if a parameter is not accepted</span></span><br><span class="line"><span class="comment">*         by the operating system.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalStateException if a parameter cannot be applied</span></span><br><span class="line"><span class="comment">*         by the operating system.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> SecurityException if the service is not properly declared</span></span><br><span class="line"><span class="comment">*         in &#123;<span class="doctag">@code</span> AndroidManifest.xml&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> VpnService</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParcelFileDescriptor <span class="title">establish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   mConfig.addresses = mAddresses;</span><br><span class="line">   mConfig.routes = mRoutes;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getService().establishVpn(mConfig);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Use IConnectivityManager since those methods are hidden and not</span></span><br><span class="line"><span class="comment">* available in ConnectivityManager.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IConnectivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IConnectivityManager.Stub.asInterface(</span><br><span class="line">          ServiceManager.getService(Context.CONNECTIVITY_SERVICE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是调用了ConnectivityService 这个系统服务的 <code>establishVpn(mConfig)</code>方法。</p><h3 id="ConnectivityService-establishVpn"><a href="#ConnectivityService-establishVpn" class="headerlink" title="ConnectivityService#establishVpn()"></a>ConnectivityService#establishVpn()</h3><p>[-&gt; frameworks/base/services/core/java/com/android/server/ConnectivityService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SparseArray&lt;Vpn&gt; mVpns = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Configure a TUN interface and return its file descriptor. Parameters</span></span><br><span class="line"><span class="comment">  * are encoded and opaque to this class. This method is used by VpnBuilder</span></span><br><span class="line"><span class="comment">  * and not available in ConnectivityManager. Permissions are checked in</span></span><br><span class="line"><span class="comment">  * Vpn class.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ParcelFileDescriptor <span class="title">establishVpn</span><span class="params">(VpnConfig config)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> user = UserHandle.getUserId(Binder.getCallingUid());</span><br><span class="line">     <span class="keyword">synchronized</span> (mVpns) &#123;</span><br><span class="line">         throwIfLockdownEnabled();</span><br><span class="line">         <span class="comment">// mVpns其实是个Vpn数组</span></span><br><span class="line">         <span class="keyword">return</span> mVpns.get(user).establish(config);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Vpn-establish"><a href="#Vpn-establish" class="headerlink" title="Vpn#establish()"></a>Vpn#establish()</h3><p>[-&gt; frameworks/base/services/core/java/com/android/server/connectivity/Vpn.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Establish a VPN network and return the file descriptor of the VPN interface. This methods</span></span><br><span class="line"><span class="comment"> * returns &#123;<span class="doctag">@code</span> null&#125; if the application is revoked or not prepared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config The parameters to configure the network.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The file descriptor of the VPN interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ParcelFileDescriptor <span class="title">establish</span><span class="params">(VpnConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check if the caller is already prepared.</span></span><br><span class="line">    UserManager mgr = UserManager.get(mContext);</span><br><span class="line">    <span class="keyword">if</span> (Binder.getCallingUid() != mOwnerUID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check to ensure consent hasn't been revoked since we were prepared.</span></span><br><span class="line">    <span class="keyword">if</span> (!isVpnUserPreConsented(mPackage)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check if the service is properly declared.</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(VpnConfig.SERVICE_INTERFACE);</span><br><span class="line">    intent.setClassName(mPackage, config.user);</span><br><span class="line">    <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Restricted users are not allowed to create VPNs, they are tied to Owner</span></span><br><span class="line">        UserInfo user = mgr.getUserInfo(mUserHandle);</span><br><span class="line">        <span class="keyword">if</span> (user.isRestricted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Restricted users cannot establish VPNs"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent,</span><br><span class="line">                <span class="keyword">null</span>, <span class="number">0</span>, mUserHandle);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Cannot find "</span> + config.user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(config.user + <span class="string">" does not require "</span> + BIND_VPN_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Cannot find "</span> + config.user);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the old config in case we need to go back.</span></span><br><span class="line">    VpnConfig oldConfig = mConfig;</span><br><span class="line">    String oldInterface = mInterface;</span><br><span class="line">    Connection oldConnection = mConnection;</span><br><span class="line">    NetworkAgent oldNetworkAgent = mNetworkAgent;</span><br><span class="line">    Set&lt;UidRange&gt; oldUsers = mNetworkCapabilities.getUids();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用jniCreate方法创建了一个FD</span></span><br><span class="line">    <span class="comment">// Configure the interface. Abort if any of these steps fails.</span></span><br><span class="line">    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String interfaze = jniGetName(tun.getFd());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TEMP use the old jni calls until there is support for netd address setting</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (LinkAddress address : config.addresses) &#123;</span><br><span class="line">            builder.append(<span class="string">" "</span>);</span><br><span class="line">            builder.append(address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jniSetAddresses(interfaze, builder.toString()) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"At least one address must be specified"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Connection connection = <span class="keyword">new</span> Connection();</span><br><span class="line">        <span class="keyword">if</span> (!mContext.bindServiceAsUser(intent, connection,</span><br><span class="line">                Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,</span><br><span class="line">                <span class="keyword">new</span> UserHandle(mUserHandle))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot bind "</span> + config.user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mConnection = connection;</span><br><span class="line">        mInterface = interfaze;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill more values.</span></span><br><span class="line">        config.user = mPackage;</span><br><span class="line">        config.interfaze = mInterface;</span><br><span class="line">        config.startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        mConfig = config;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up forwarding and DNS rules.</span></span><br><span class="line">        <span class="comment">// First attempt to do a seamless handover that only changes the interface name and</span></span><br><span class="line">        <span class="comment">// parameters. If that fails, disconnect.</span></span><br><span class="line">        <span class="keyword">if</span> (oldConfig != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) &#123;</span><br><span class="line">            <span class="comment">// Keep mNetworkAgent unchanged</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNetworkAgent = <span class="keyword">null</span>;</span><br><span class="line">            updateState(DetailedState.CONNECTING, <span class="string">"establish"</span>);</span><br><span class="line">            <span class="comment">// Set up forwarding and DNS rules.</span></span><br><span class="line">            agentConnect();</span><br><span class="line">            <span class="comment">// Remove the old tun's user forwarding rules</span></span><br><span class="line">            <span class="comment">// The new tun's user rules have already been added above so they will take over</span></span><br><span class="line">            <span class="comment">// as rules are deleted. This prevents data leakage as the rules are moved over.</span></span><br><span class="line">            agentDisconnect(oldNetworkAgent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mContext.unbindService(oldConnection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldInterface != <span class="keyword">null</span> &amp;&amp; !oldInterface.equals(interfaze)) &#123;</span><br><span class="line">            jniReset(oldInterface);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot set tunnel's fd as blocking="</span> + config.blocking, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        IoUtils.closeQuietly(tun);</span><br><span class="line">        <span class="comment">// If this is not seamless handover, disconnect partially-established network when error</span></span><br><span class="line">        <span class="comment">// occurs.</span></span><br><span class="line">        <span class="keyword">if</span> (oldNetworkAgent != mNetworkAgent) &#123;</span><br><span class="line">            agentDisconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// restore old state</span></span><br><span class="line">        mConfig = oldConfig;</span><br><span class="line">        mConnection = oldConnection;</span><br><span class="line">        mNetworkCapabilities.setUids(oldUsers);</span><br><span class="line">        mNetworkAgent = oldNetworkAgent;</span><br><span class="line">        mInterface = oldInterface;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"Established by "</span> + config.user + <span class="string">" on "</span> + mInterface);</span><br><span class="line">    <span class="keyword">return</span> tun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>establish()</code>方法除了权限校验之外，主要是通过<code>jniCreate</code>方法创建了一个FD并返回，这个FD其实就是tun设备。而此处的<code>jniCreate</code>方法是native方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">jniCreate</span><span class="params">(<span class="keyword">int</span> mtu)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">jniGetName</span><span class="params">(<span class="keyword">int</span> tun)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">jniSetAddresses</span><span class="params">(String interfaze, String addresses)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jniReset</span><span class="params">(String interfaze)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">jniCheck</span><span class="params">(String interfaze)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">jniAddAddress</span><span class="params">(String interfaze, String address, <span class="keyword">int</span> prefixLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">jniDelAddress</span><span class="params">(String interfaze, String address, <span class="keyword">int</span> prefixLen)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到一系列的native方法，这些方法都位于<code>com_android_server_connectivity_Vpn.cpp</code>中：</p><h3 id="jniCreate"><a href="#jniCreate" class="headerlink" title="jniCreate()"></a>jniCreate()</h3><p>[-&gt; frameworks/base/services/core/jni/com_android_server_connectivity_Vpn.cpp]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"jniCreate"</span>, <span class="string">"(I)I"</span>, (<span class="keyword">void</span> *)create&#125;,</span><br><span class="line">    &#123;<span class="string">"jniGetName"</span>, <span class="string">"(I)Ljava/lang/String;"</span>, (<span class="keyword">void</span> *)getName&#125;,</span><br><span class="line">    &#123;<span class="string">"jniSetAddresses"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;)I"</span>, (<span class="keyword">void</span> *)setAddresses&#125;,</span><br><span class="line">    &#123;<span class="string">"jniReset"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, (<span class="keyword">void</span> *)reset&#125;,</span><br><span class="line">    &#123;<span class="string">"jniCheck"</span>, <span class="string">"(Ljava/lang/String;)I"</span>, (<span class="keyword">void</span> *)check&#125;,</span><br><span class="line">    &#123;<span class="string">"jniAddAddress"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;I)Z"</span>, (<span class="keyword">void</span> *)addAddress&#125;,</span><br><span class="line">    &#123;<span class="string">"jniDelAddress"</span>, <span class="string">"(Ljava/lang/String;Ljava/lang/String;I)Z"</span>, (<span class="keyword">void</span> *)delAddress&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tun设备</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">create</span><span class="params">(JNIEnv *env, jobject <span class="comment">/* thiz */</span>, jint mtu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tun = create_interface(mtu);</span><br><span class="line">    <span class="keyword">if</span> (tun &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        throwException(env, tun, <span class="string">"Cannot create interface"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_interface</span><span class="params">(<span class="keyword">int</span> mtu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tun = open(<span class="string">"/dev/tun"</span>, O_RDWR | O_NONBLOCK | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    ifreq ifr4;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr4, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr4));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate interface.</span></span><br><span class="line">    ifr4.ifr_flags = IFF_TUN | IFF_NO_PI;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(tun, TUNSETIFF, &amp;ifr4)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Cannot allocate TUN: %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activate interface.</span></span><br><span class="line">    ifr4.ifr_flags = IFF_UP;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(inet4, SIOCSIFFLAGS, &amp;ifr4)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Cannot activate %s: %s"</span>, ifr4.ifr_name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set MTU if it is specified.</span></span><br><span class="line">    ifr4.ifr_mtu = mtu;</span><br><span class="line">    <span class="keyword">if</span> (mtu &gt; <span class="number">0</span> &amp;&amp; ioctl(inet4, SIOCSIFMTU, &amp;ifr4)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Cannot set MTU on %s: %s"</span>, ifr4.ifr_name, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tun;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    close(tun);</span><br><span class="line">    <span class="keyword">return</span> SYSTEM_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就很明显能看到最终调用的是<code>create_interface</code>方法，该方法其实就是打开<code>/dev/tun</code>文件，然后设置一下MTU并返回这个FD。</p><p><code>/dev/tun</code>文件就是Linux中的TUN设备。</p><h2 id="TUN-TAP是什么"><a href="#TUN-TAP是什么" class="headerlink" title="TUN/TAP是什么"></a>TUN/TAP是什么</h2><p>tap/tun 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。<br><strong>TAP</strong> 设备与 <strong>TUN</strong> 设备都是虚拟网络设备，工作方式完全相同，但它们的工作层次不太一样：</p><ul><li>tap 是一个二层设备（或者以太网设备），只能处理二层的以太网帧；</li><li>tun 是一个点对点的三层设备（或网络层设备），只能处理三层的 IP 数据包。</li></ul><p>作为网络设备，tap/tun 也需要配套相应的驱动程序才能工作。tap/tun 驱动程序包括两个部分，一个是字符设备驱动，一个是网卡驱动。这两部分驱动程序分工不太一样，字符驱动负责数据包在内核空间和用户空间的传送，网卡驱动负责数据包在 TCP/IP 网络协议栈上的传输和处理。</p><h3 id="字符驱动-内核空间和用户空间的数据传输"><a href="#字符驱动-内核空间和用户空间的数据传输" class="headerlink" title="字符驱动 - 内核空间和用户空间的数据传输"></a>字符驱动 - 内核空间和用户空间的数据传输</h3><p>在 Linux 中，用户空间和内核空间的数据传输有多种方式，字符设备就是其中的一种。tap/tun 通过驱动程序和一个与之关联的字符设备，来实现用户空间和内核空间的通信接口。</p><p>在 Linux 内核 2.6.x 之后的版本中，tap/tun 对应的字符设备文件分别为：</p><ul><li>tap：/dev/tap0</li><li>tun：/dev/tun0</li></ul><p>设备文件即充当了用户空间和内核空间通信的接口。当应用程序打开设备文件时，驱动程序就会创建并注册相应的虚拟设备接口，一般以 <code>tunX</code> 或 <code>tapX</code> 命名。当应用程序关闭文件时，驱动也会自动删除 <code>tunX</code> 和 <code>tapX</code> 设备，还会删除已经建立起来的路由等信息。</p><p>tap/tun 设备文件就像一个管道，一端连接着用户空间，一端连接着内核空间。当用户程序向文件 <code>/dev/net/tun</code> 或 <code>/dev/tap0</code> 写数据时，内核就可以从对应的 <code>tunX</code> 或 <code>tapX</code> 接口读到数据，反之，内核可以通过相反的方式向用户程序发送数据。</p><h3 id="网卡驱动-数据包在-TCP-IP-协议栈的传输"><a href="#网卡驱动-数据包在-TCP-IP-协议栈的传输" class="headerlink" title="网卡驱动 - 数据包在 TCP/IP 协议栈的传输"></a>网卡驱动 - 数据包在 TCP/IP 协议栈的传输</h3><p>参考<a href="https://blog.kghost.info/2013/03/27/linux-network-tun/" target="_blank" rel="noopener">网络虚拟化技术（二）: TUN/TAP MACVLAN MACVTAP</a>，先来看看物理网卡是如何工作的：</p><p><img src="/gallery/android_common/tunortap-eth0.png" alt="真实网卡的工作机制"></p><p>普通网卡通过网线收发数据包，所有物理网卡收到的包会交给内核的 Network Stack 处理，然后通过 Socket API 通知给用户程序。</p><p>但是 TUN 设备通过一个<code>/dev/tunX</code>文件收发数据包。所有对该文件的写操作会通过 TUN 设备转换成一个数据包送给内核；当内核发送一个包给 TUN 设备时，通过读这个文件可以拿到包的内容。</p><p>如果我们使用 TUN 设备搭建一个基于 UDP VPN，那么整个处理过程就是这样：</p><p><img src="/gallery/android_common/tunortap-tun.png" alt="基于 UDP 的 VPN 工作机制"></p><p>数据包会通过内核网络栈两次。但是经过 App 的处理后，数据包可能已经加密，并且原有的 ip 头被封装在 udp 内部，所以第二次通过网络栈内核看到的添加了新的IP头和UDP头的数据包。</p><p><img src="/gallery/android_common/090751088583813.jpg" alt="第二次进入网络栈内核后的IP数据包变化"></p><p>tap/tun 通过实现相应的网卡驱动程序来和网络协议栈通信。一般的流程和物理网卡和协议栈的交互流程是一样的，不同的是物理网卡一端是连接物理网络，而 tap/tun 虚拟网卡一般连接到用户空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                                                                |</span><br><span class="line">|  +--------------------+      +--------------------+            |</span><br><span class="line">|  | User Application A |      | User Application B |&lt;-----+     |</span><br><span class="line">|  +--------------------+      +--------------------+      |     |</span><br><span class="line">|               | <span class="number">1</span>                    | <span class="number">5</span>                 |     |</span><br><span class="line">|...............|......................|...................|.....|</span><br><span class="line">|               ↓                      ↓                   |     |</span><br><span class="line">|         +----------+           +----------+              |     |</span><br><span class="line">|         | socket A |           | socket B |              |     |</span><br><span class="line">|         +----------+           +----------+              |     |</span><br><span class="line">|                 | <span class="number">2</span>               | <span class="number">6</span>                    |     |</span><br><span class="line">|.................|.................|......................|.....|</span><br><span class="line">|                 ↓                 ↓                      |     |</span><br><span class="line">|             +------------------------+                 <span class="number">4</span> |     |</span><br><span class="line">|             | Newwork Protocol Stack |                   |     |</span><br><span class="line">|             +------------------------+                   |     |</span><br><span class="line">|                | <span class="number">7</span>                 | <span class="number">3</span>                   |     |</span><br><span class="line">|................|...................|.....................|.....|</span><br><span class="line">|                ↓                   ↓                     |     |</span><br><span class="line">|        +----------------+    +----------------+          |     |</span><br><span class="line">|        |      eth0      |    |      tun0      |          |     |</span><br><span class="line">|        +----------------+    +----------------+          |     |</span><br><span class="line">|    <span class="number">10.32</span>.0.11  |                   |   <span class="number">192.168</span>.3.11      |     |</span><br><span class="line">|                | <span class="number">8</span>                 +---------------------+     |</span><br><span class="line">|                |                                               |</span><br><span class="line">+----------------|-----------------------------------------------+</span><br><span class="line">                 ↓</span><br><span class="line">         Physical Network</span><br></pre></td></tr></table></figure><p>上图中有两个应用程序A和B，都在用户层，而其它的socket、协议栈（Newwork Protocol Stack）和网络设备（eth0和tun0）部分都在内核层，其实socket是协议栈的一部分，这里分开来的目的是为了看的更直观。</p><a id="more"></a><p>tun0是一个Tun/Tap虚拟设备，从上图中可以看出它和物理设备eth0的差别，它们的一端虽然都连着协议栈，但另一端不一样，eth0的另一端是物理网络，这个物理网络可能就是一个交换机，而tun0的另一端是一个用户层的程序，协议栈发给tun0的数据包能被这个应用程序读取到，并且应用程序能直接向tun0写数据。</p><p>这里假设eth0配置的IP是10.32.0.11，而tun0配置的IP是192.168.3.11.</p><blockquote><p>这里列举的是一个典型的tun/tap设备的应用场景，发到192.168.3.0/24网络的数据通过程序B这个隧道，利用10.32.0.11发到远端网络的10.33.0.1，再由10.33.0.1转发给相应的设备，从而实现VPN。</p></blockquote><p>下面来看看数据包的流程：</p><ol><li>应用程序A是一个普通的程序，通过socket A发送了一个数据包，假设这个数据包的目的IP地址是192.168.3.1</li><li>socket将这个数据包丢给协议栈</li><li>协议栈根据数据包的目的IP地址，匹配本地路由规则，知道这个数据包应该由tun0出去，于是将数据包交给tun0</li><li>tun0收到数据包之后，发现另一端被进程B打开了，于是将数据包丢给了进程B</li><li>进程B收到数据包之后，做一些跟业务相关的处理，然后构造一个新的数据包，将原来的数据包嵌入在新的数据包中，最后通过socket B将数据包转发出去，这时候新数据包的源地址变成了eth0的地址，而目的IP地址变成了一个其它的地址，比如是10.33.0.1.</li><li>socket B将数据包丢给协议栈</li><li>协议栈根据本地路由，发现这个数据包应该要通过eth0发送出去，于是将数据包交给eth0</li><li>eth0通过物理网络将数据包发送出去</li></ol><p>10.33.0.1收到数据包之后，会打开数据包，读取里面的原始数据包，并转发给本地的192.168.3.1，然后等收到192.168.3.1的应答后，再构造新的应答包，并将原始应答包封装在里面，再由原路径返回给应用程序B，应用程序B取出里面的原始应答包，最后返回给应用程序A</p><blockquote><p>这里不讨论Tun/Tap设备tun0是怎么和用户层的进程B进行通信的，对于Linux内核来说，有很多种办法来让内核空间和用户空间的进程交换数据。</p></blockquote><p>从上面的流程中可以看出，数据包选择走哪个网络设备完全由路由表控制，所以如果我们想让某些网络流量走应用程序B的转发流程，就需要配置路由表让这部分数据走tun0。</p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>根据<a href="https://nicelee.top/blog/2019/02/14/java-android-vpnservice/" target="_blank" rel="noopener">Android VpnService初探</a></p><ul><li>什么IP包会往虚拟网卡发？或者说，虚拟网卡出入的IP报文怎么才算有效的？<ul><li>只有本地到外地，或者外地到本地的报文，才会途径虚拟网卡。</li><li>比如说， 本地6666端口，往本地9999端口发送了一个UDP包，其对应的IP报文不会经过虚拟网卡，不要指望读<strong>ParcelFileDescriptor</strong>实例能够得到这份IP报文。</li><li>比如说， 本地6666端口，往外地<code>8.8.8.8:53</code>发送了一个UDP包。虚拟网卡收到后，将其目的地改为指向本地<strong>UDPServer</strong>，<code>6.6.6.6:6666</code>，重新写入虚拟网卡。<br>但这时本地<strong>UDPServer</strong>并不会收到这个报文，只有将这个IP报文的源地址更改一下，例如由本地ip改为<strong>8.8.8.8</strong>(原目的地址)，这个报文才会被本地<strong>UDPServer</strong>收到。</li></ul></li><li>关于DNS报文<ul><li>似乎如果不在Builder生成时指定DNS服务器，手机本身另有一套机制，使得系统默认的DNS查询不会经过虚拟网卡。如果有需要，不妨再加一条：<br><code>builder.addDnsServer(&quot;114.114.114.114&quot;)</code></li></ul></li></ul><p>这个讨论也很有信息量：<a href="https://www.v2ex.com/t/589264" target="_blank" rel="noopener">VpnService 能否原样将三层的 IP 报文发出去？</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://arloor.com/posts/other/android-vpnservice-and-vpn-dev/" target="_blank" rel="noopener">安卓Vpn开发思路</a></li><li><a href="https://blog.csdn.net/jsqfengbao/article/details/52462125" target="_blank" rel="noopener">使用Android系统自带的VpnService截取流量</a></li><li><a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener">Linux虚拟网络设备之tun/tap</a></li><li><a href="https://www.thegeekstuff.com/2014/06/android-vpn-service/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Android VPN Service Explained with Packet Bypass Example Program</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VPN抓包&quot;&gt;&lt;a href=&quot;#VPN抓包&quot; class=&quot;headerlink&quot; title=&quot;VPN抓包&quot;&gt;&lt;/a&gt;VPN抓包&lt;/h2&gt;&lt;p&gt;使用VPN技术可以直接获得网络三层IP报文，可以不可以基于此实现移动端抓包呢？肯定可以，Android已经有大批开源库基于该思路实现抓包。我们来学习下原理。&lt;/p&gt;
&lt;h2 id=&quot;VpnService&quot;&gt;&lt;a href=&quot;#VpnService&quot; class=&quot;headerlink&quot; title=&quot;VpnService&quot;&gt;&lt;/a&gt;VpnService&lt;/h2&gt;&lt;p&gt;VpnService是开发Android VPN的基础，下面是&lt;a href=&quot;https://developer.android.com/reference/android/net/VpnService&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;的阐释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VpnService is a base class for applications to extend and build their own VPN solutions. In general, it creates a virtual network interface, configures addresses and routing rules, and returns a file descriptor to the application. Each read from the descriptor retrieves an outgoing packet which was routed to the interface. Each write to the descriptor injects an incoming packet just like it was received from the interface. The interface is running on Internet Protocol (IP), so packets are always started with IP headers. The application then completes a VPN connection by processing and exchanging packets with the remote server over a tunnel.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的阐释的重点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟一个网卡&lt;/li&gt;
&lt;li&gt;返回文件描述符&lt;/li&gt;
&lt;li&gt;读写的内容是ip数据报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先推荐Android官方提供了的Example：&lt;a href=&quot;https://android.googlesource.com/platform/development/+/master/samples/ToyVpn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ToyVpn&lt;/a&gt;。这个例子比较简单，实操一遍可以帮助理解VPN原理。&lt;/p&gt;
&lt;p&gt;初步搭一个vpn应用框架也可以参考&lt;a href=&quot;https://www.tuicool.com/articles/uuiMje&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;，这个仅仅是搭建了框架，功能（ip数据包的收发）则没有实现。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;Android系统提供的API是VpnService，我们调用&lt;code&gt;establish()&lt;/code&gt;方法之后会返回一个FD。然后我们读取该FD就能获得ip数据报文，通过发往VPN Server，再获得Server的回复报文之后再写入该FD，就可以实现VPN通信。&lt;/p&gt;
&lt;h3 id=&quot;VpnService-establish&quot;&gt;&lt;a href=&quot;#VpnService-establish&quot; class=&quot;headerlink&quot; title=&quot;VpnService#establish()&quot;&gt;&lt;/a&gt;VpnService#establish()&lt;/h3&gt;&lt;p&gt;[-&amp;gt; frameworks/base/core/java/android/net/VpnService.java]&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* Create a VPN interface using the parameters supplied to this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* builder. The interface works on IP packets, and a file descriptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* is returned for the application to access them. Each read&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* retrieves an outgoing packet which was routed to the interface.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* Each write injects an incoming packet just like it was received&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* from the interface. The file descriptor is put into non-blocking&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* mode by default to avoid blocking Java threads. To use the file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* descriptor completely in native space, see&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; ParcelFileDescriptor#detachFd()&amp;#125;. The application MUST&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* close the file descriptor when the VPN connection is terminated.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* The VPN interface will be removed and the network will be&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* restored by the system automatically.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &amp;lt;p&amp;gt;To avoid conflicts, there can be only one active VPN interface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* at the same time. Usually network parameters are never changed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* during the lifetime of a VPN connection. It is also common for an&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* application to create a new file descriptor after closing the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* previous one. However, it is rare but not impossible to have two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* interfaces while performing a seamless handover. In this case, the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* old interface will be deactivated when the new one is created&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* successfully. Both file descriptors are valid but now outgoing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* packets will be routed to the new interface. Therefore, after&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* draining the old file descriptor, the application MUST close it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* and start using the new file descriptor. If the new interface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* cannot be created, the existing interface and its file descriptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* remain untouched.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &amp;lt;p&amp;gt;An exception will be thrown if the interface cannot be created&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* for any reason. However, this method returns &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; null&amp;#125; if the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* application is not prepared or is revoked. This helps solve&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* possible race conditions between other VPN applications.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; ParcelFileDescriptor&amp;#125; of the VPN interface, or&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*         &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; null&amp;#125; if the application is not prepared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; IllegalArgumentException if a parameter is not accepted&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*         by the operating system.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; IllegalStateException if a parameter cannot be applied&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*         by the operating system.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; SecurityException if the service is not properly declared&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*         in &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; AndroidManifest.xml&amp;#125;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* &lt;span class=&quot;doctag&quot;&gt;@see&lt;/span&gt; VpnService&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ParcelFileDescriptor &lt;span class=&quot;title&quot;&gt;establish&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   mConfig.addresses = mAddresses;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   mConfig.routes = mRoutes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; getService().establishVpn(mConfig);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RemoteException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* Use IConnectivityManager since those methods are hidden and not&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* available in ConnectivityManager.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IConnectivityManager &lt;span class=&quot;title&quot;&gt;getService&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; IConnectivityManager.Stub.asInterface(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ServiceManager.getService(Context.CONNECTIVITY_SERVICE));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实是调用了ConnectivityService 这个系统服务的 &lt;code&gt;establishVpn(mConfig)&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;ConnectivityService-establishVpn&quot;&gt;&lt;a href=&quot;#ConnectivityService-establishVpn&quot; class=&quot;headerlink&quot; title=&quot;ConnectivityService#establishVpn()&quot;&gt;&lt;/a&gt;ConnectivityService#establishVpn()&lt;/h3&gt;&lt;p&gt;[-&amp;gt; frameworks/base/services/core/java/com/android/server/ConnectivityService.java]&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SparseArray&amp;lt;Vpn&amp;gt; mVpns = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SparseArray&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * Configure a TUN interface and return its file descriptor. Parameters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * are encoded and opaque to this class. This method is used by VpnBuilder&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * and not available in ConnectivityManager. Permissions are checked in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * Vpn class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * &lt;span class=&quot;doctag&quot;&gt;@hide&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ParcelFileDescriptor &lt;span class=&quot;title&quot;&gt;establishVpn&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(VpnConfig config)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; user = UserHandle.getUserId(Binder.getCallingUid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (mVpns) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         throwIfLockdownEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// mVpns其实是个Vpn数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mVpns.get(user).establish(config);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Vpn-establish&quot;&gt;&lt;a href=&quot;#Vpn-establish&quot; class=&quot;headerlink&quot; title=&quot;Vpn#establish()&quot;&gt;&lt;/a&gt;Vpn#establish()&lt;/h3&gt;&lt;p&gt;[-&amp;gt; frameworks/base/services/core/java/com/android/server/connectivity/Vpn.java]&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Establish a VPN network and return the file descriptor of the VPN interface. This methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * returns &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; null&amp;#125; if the application is revoked or not prepared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; config The parameters to configure the network.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; The file descriptor of the VPN interface.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; ParcelFileDescriptor &lt;span class=&quot;title&quot;&gt;establish&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(VpnConfig config)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Check if the caller is already prepared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UserManager mgr = UserManager.get(mContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Binder.getCallingUid() != mOwnerUID) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Check to ensure consent hasn&#39;t been revoked since we were prepared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isVpnUserPreConsented(mPackage)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Check if the service is properly declared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(VpnConfig.SERVICE_INTERFACE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intent.setClassName(mPackage, config.user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; token = Binder.clearCallingIdentity();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Restricted users are not allowed to create VPNs, they are tied to Owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UserInfo user = mgr.getUserInfo(mUserHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (user.isRestricted()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SecurityException(&lt;span class=&quot;string&quot;&gt;&quot;Restricted users cannot establish VPNs&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, mUserHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SecurityException(&lt;span class=&quot;string&quot;&gt;&quot;Cannot find &quot;&lt;/span&gt; + config.user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SecurityException(config.user + &lt;span class=&quot;string&quot;&gt;&quot; does not require &quot;&lt;/span&gt; + BIND_VPN_SERVICE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RemoteException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SecurityException(&lt;span class=&quot;string&quot;&gt;&quot;Cannot find &quot;&lt;/span&gt; + config.user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Binder.restoreCallingIdentity(token);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Save the old config in case we need to go back.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    VpnConfig oldConfig = mConfig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String oldInterface = mInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Connection oldConnection = mConnection;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NetworkAgent oldNetworkAgent = mNetworkAgent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Set&amp;lt;UidRange&amp;gt; oldUsers = mNetworkCapabilities.getUids();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 调用jniCreate方法创建了一个FD&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Configure the interface. Abort if any of these steps fails.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String interfaze = jniGetName(tun.getFd());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// TEMP use the old jni calls until there is support for netd address setting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StringBuilder builder = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (LinkAddress address : config.addresses) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            builder.append(&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            builder.append(address);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (jniSetAddresses(interfaze, builder.toString()) &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;At least one address must be specified&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Connection connection = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Connection();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mContext.bindServiceAsUser(intent, connection,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UserHandle(mUserHandle))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;string&quot;&gt;&quot;Cannot bind &quot;&lt;/span&gt; + config.user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mConnection = connection;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mInterface = interfaze;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Fill more values.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.user = mPackage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.interfaze = mInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        config.startTime = SystemClock.elapsedRealtime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mConfig = config;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Set up forwarding and DNS rules.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// First attempt to do a seamless handover that only changes the interface name and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// parameters. If that fails, disconnect.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldConfig != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;amp;&amp;amp; updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Keep mNetworkAgent unchanged&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mNetworkAgent = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            updateState(DetailedState.CONNECTING, &lt;span class=&quot;string&quot;&gt;&quot;establish&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Set up forwarding and DNS rules.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            agentConnect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Remove the old tun&#39;s user forwarding rules&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// The new tun&#39;s user rules have already been added above so they will take over&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// as rules are deleted. This prevents data leakage as the rules are moved over.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            agentDisconnect(oldNetworkAgent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldConnection != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mContext.unbindService(oldConnection);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldInterface != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !oldInterface.equals(interfaze)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            jniReset(oldInterface);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;string&quot;&gt;&quot;Cannot set tunnel&#39;s fd as blocking=&quot;&lt;/span&gt; + config.blocking, e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RuntimeException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        IoUtils.closeQuietly(tun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// If this is not seamless handover, disconnect partially-established network when error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// occurs.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldNetworkAgent != mNetworkAgent) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            agentDisconnect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// restore old state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mConfig = oldConfig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mConnection = oldConnection;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mNetworkCapabilities.setUids(oldUsers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mNetworkAgent = oldNetworkAgent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mInterface = oldInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Log.i(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Established by &quot;&lt;/span&gt; + config.user + &lt;span class=&quot;string&quot;&gt;&quot; on &quot;&lt;/span&gt; + mInterface);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tun;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;establish()&lt;/code&gt;方法除了权限校验之外，主要是通过&lt;code&gt;jniCreate&lt;/code&gt;方法创建了一个FD并返回，这个FD其实就是tun设备。而此处的&lt;code&gt;jniCreate&lt;/code&gt;方法是native方法，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mtu)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;jniGetName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tun)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniSetAddresses&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String interfaze, String addresses)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniReset&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String interfaze)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniCheck&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String interfaze)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniAddAddress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String interfaze, String address, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; prefixLen)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;jniDelAddress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String interfaze, String address, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; prefixLen)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到一系列的native方法，这些方法都位于&lt;code&gt;com_android_server_connectivity_Vpn.cpp&lt;/code&gt;中：&lt;/p&gt;
&lt;h3 id=&quot;jniCreate&quot;&gt;&lt;a href=&quot;#jniCreate&quot; class=&quot;headerlink&quot; title=&quot;jniCreate()&quot;&gt;&lt;/a&gt;jniCreate()&lt;/h3&gt;&lt;p&gt;[-&amp;gt; frameworks/base/services/core/jni/com_android_server_connectivity_Vpn.cpp]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; JNINativeMethod gMethods[] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniCreate&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(I)I&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)create&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniGetName&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(I)Ljava/lang/String;&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)getName&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniSetAddresses&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(Ljava/lang/String;Ljava/lang/String;)I&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)setAddresses&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniReset&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(Ljava/lang/String;)V&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)reset&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniCheck&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(Ljava/lang/String;)I&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)check&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniAddAddress&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(Ljava/lang/String;Ljava/lang/String;I)Z&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)addAddress&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;jniDelAddress&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;(Ljava/lang/String;Ljava/lang/String;I)Z&quot;&lt;/span&gt;, (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)delAddress&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建tun设备&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; jint &lt;span class=&quot;title&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(JNIEnv *env, jobject &lt;span class=&quot;comment&quot;&gt;/* thiz */&lt;/span&gt;, jint mtu)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tun = create_interface(mtu);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tun &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throwException(env, tun, &lt;span class=&quot;string&quot;&gt;&quot;Cannot create interface&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tun;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;create_interface&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mtu)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tun = open(&lt;span class=&quot;string&quot;&gt;&quot;/dev/tun&quot;&lt;/span&gt;, O_RDWR | O_NONBLOCK | O_CLOEXEC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ifreq ifr4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(&amp;amp;ifr4, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ifr4));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Allocate interface.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ifr4.ifr_flags = IFF_TUN | IFF_NO_PI;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ioctl(tun, TUNSETIFF, &amp;amp;ifr4)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ALOGE(&lt;span class=&quot;string&quot;&gt;&quot;Cannot allocate TUN: %s&quot;&lt;/span&gt;, strerror(errno));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Activate interface.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ifr4.ifr_flags = IFF_UP;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ioctl(inet4, SIOCSIFFLAGS, &amp;amp;ifr4)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ALOGE(&lt;span class=&quot;string&quot;&gt;&quot;Cannot activate %s: %s&quot;&lt;/span&gt;, ifr4.ifr_name, strerror(errno));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Set MTU if it is specified.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ifr4.ifr_mtu = mtu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mtu &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ioctl(inet4, SIOCSIFMTU, &amp;amp;ifr4)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ALOGE(&lt;span class=&quot;string&quot;&gt;&quot;Cannot set MTU on %s: %s&quot;&lt;/span&gt;, ifr4.ifr_name, strerror(errno));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tun;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    close(tun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SYSTEM_ERROR;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里就很明显能看到最终调用的是&lt;code&gt;create_interface&lt;/code&gt;方法，该方法其实就是打开&lt;code&gt;/dev/tun&lt;/code&gt;文件，然后设置一下MTU并返回这个FD。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/dev/tun&lt;/code&gt;文件就是Linux中的TUN设备。&lt;/p&gt;
&lt;h2 id=&quot;TUN-TAP是什么&quot;&gt;&lt;a href=&quot;#TUN-TAP是什么&quot; class=&quot;headerlink&quot; title=&quot;TUN/TAP是什么&quot;&gt;&lt;/a&gt;TUN/TAP是什么&lt;/h2&gt;&lt;p&gt;tap/tun 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。&lt;br&gt;&lt;strong&gt;TAP&lt;/strong&gt; 设备与 &lt;strong&gt;TUN&lt;/strong&gt; 设备都是虚拟网络设备，工作方式完全相同，但它们的工作层次不太一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tap 是一个二层设备（或者以太网设备），只能处理二层的以太网帧；&lt;/li&gt;
&lt;li&gt;tun 是一个点对点的三层设备（或网络层设备），只能处理三层的 IP 数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为网络设备，tap/tun 也需要配套相应的驱动程序才能工作。tap/tun 驱动程序包括两个部分，一个是字符设备驱动，一个是网卡驱动。这两部分驱动程序分工不太一样，字符驱动负责数据包在内核空间和用户空间的传送，网卡驱动负责数据包在 TCP/IP 网络协议栈上的传输和处理。&lt;/p&gt;
&lt;h3 id=&quot;字符驱动-内核空间和用户空间的数据传输&quot;&gt;&lt;a href=&quot;#字符驱动-内核空间和用户空间的数据传输&quot; class=&quot;headerlink&quot; title=&quot;字符驱动 - 内核空间和用户空间的数据传输&quot;&gt;&lt;/a&gt;字符驱动 - 内核空间和用户空间的数据传输&lt;/h3&gt;&lt;p&gt;在 Linux 中，用户空间和内核空间的数据传输有多种方式，字符设备就是其中的一种。tap/tun 通过驱动程序和一个与之关联的字符设备，来实现用户空间和内核空间的通信接口。&lt;/p&gt;
&lt;p&gt;在 Linux 内核 2.6.x 之后的版本中，tap/tun 对应的字符设备文件分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tap：/dev/tap0&lt;/li&gt;
&lt;li&gt;tun：/dev/tun0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设备文件即充当了用户空间和内核空间通信的接口。当应用程序打开设备文件时，驱动程序就会创建并注册相应的虚拟设备接口，一般以 &lt;code&gt;tunX&lt;/code&gt; 或 &lt;code&gt;tapX&lt;/code&gt; 命名。当应用程序关闭文件时，驱动也会自动删除 &lt;code&gt;tunX&lt;/code&gt; 和 &lt;code&gt;tapX&lt;/code&gt; 设备，还会删除已经建立起来的路由等信息。&lt;/p&gt;
&lt;p&gt;tap/tun 设备文件就像一个管道，一端连接着用户空间，一端连接着内核空间。当用户程序向文件 &lt;code&gt;/dev/net/tun&lt;/code&gt; 或 &lt;code&gt;/dev/tap0&lt;/code&gt; 写数据时，内核就可以从对应的 &lt;code&gt;tunX&lt;/code&gt; 或 &lt;code&gt;tapX&lt;/code&gt; 接口读到数据，反之，内核可以通过相反的方式向用户程序发送数据。&lt;/p&gt;
&lt;h3 id=&quot;网卡驱动-数据包在-TCP-IP-协议栈的传输&quot;&gt;&lt;a href=&quot;#网卡驱动-数据包在-TCP-IP-协议栈的传输&quot; class=&quot;headerlink&quot; title=&quot;网卡驱动 - 数据包在 TCP/IP 协议栈的传输&quot;&gt;&lt;/a&gt;网卡驱动 - 数据包在 TCP/IP 协议栈的传输&lt;/h3&gt;&lt;p&gt;参考&lt;a href=&quot;https://blog.kghost.info/2013/03/27/linux-network-tun/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络虚拟化技术（二）: TUN/TAP MACVLAN MACVTAP&lt;/a&gt;，先来看看物理网卡是如何工作的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/tunortap-eth0.png&quot; alt=&quot;真实网卡的工作机制&quot;&gt;&lt;/p&gt;
&lt;p&gt;普通网卡通过网线收发数据包，所有物理网卡收到的包会交给内核的 Network Stack 处理，然后通过 Socket API 通知给用户程序。&lt;/p&gt;
&lt;p&gt;但是 TUN 设备通过一个&lt;code&gt;/dev/tunX&lt;/code&gt;文件收发数据包。所有对该文件的写操作会通过 TUN 设备转换成一个数据包送给内核；当内核发送一个包给 TUN 设备时，通过读这个文件可以拿到包的内容。&lt;/p&gt;
&lt;p&gt;如果我们使用 TUN 设备搭建一个基于 UDP VPN，那么整个处理过程就是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/tunortap-tun.png&quot; alt=&quot;基于 UDP 的 VPN 工作机制&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据包会通过内核网络栈两次。但是经过 App 的处理后，数据包可能已经加密，并且原有的 ip 头被封装在 udp 内部，所以第二次通过网络栈内核看到的添加了新的IP头和UDP头的数据包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/090751088583813.jpg&quot; alt=&quot;第二次进入网络栈内核后的IP数据包变化&quot;&gt;&lt;/p&gt;
&lt;p&gt;tap/tun 通过实现相应的网卡驱动程序来和网络协议栈通信。一般的流程和物理网卡和协议栈的交互流程是一样的，不同的是物理网卡一端是连接物理网络，而 tap/tun 虚拟网卡一般连接到用户空间。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                                                                |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  +--------------------+      +--------------------+            |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  | User Application A |      | User Application B |&amp;lt;-----+     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  +--------------------+      +--------------------+      |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               | &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;                    | &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;                 |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|...............|......................|...................|.....|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               ↓                      ↓                   |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|         +----------+           +----------+              |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|         | socket A |           | socket B |              |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|         +----------+           +----------+              |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;               | &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;                    |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|.................|.................|......................|.....|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 ↓                 ↓                      |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|             +------------------------+                 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|             | Newwork Protocol Stack |                   |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|             +------------------------+                   |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                | &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;                 | &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;                   |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|................|...................|.....................|.....|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                ↓                   ↓                     |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|        +----------------+    +----------------+          |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|        |      eth0      |    |      tun0      |          |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|        +----------------+    +----------------+          |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    &lt;span class=&quot;number&quot;&gt;10.32&lt;/span&gt;.0.11  |                   |   &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;.3.11      |     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                | &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;                 +---------------------+     |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                |                                               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------|-----------------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 ↓&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         Physical Network&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上图中有两个应用程序A和B，都在用户层，而其它的socket、协议栈（Newwork Protocol Stack）和网络设备（eth0和tun0）部分都在内核层，其实socket是协议栈的一部分，这里分开来的目的是为了看的更直观。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】ADB工具原理探究</title>
    <link href="https://itimetraveler.github.io/2019/06/07/Android%20ADB%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>https://itimetraveler.github.io/2019/06/07/Android ADB原理探究/</id>
    <published>2019-06-07T14:20:55.000Z</published>
    <updated>2019-06-08T09:20:54.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ADB简介"><a href="#ADB简介" class="headerlink" title="ADB简介"></a>ADB简介</h1><blockquote class="pullquote right"><p><img src="/gallery/android_common/ADB-feature.png" alt=""></p></blockquote><p>Android Debug Bridge (adb) 是一个Android的命令行工具。可以用来连接模拟器或实际的移动设备。比如 adb logcat, adb shell。Dalvik Debug Monitor Server(DDMS) 后台也是运行的adb来实现监控调试移动设备。</p><p>总体而言，adb有两个用途：</p><ul><li><strong>监控连接设备</strong> ：adb会监控所有已经连接设备(包括模拟器)，譬如设备所处的状态：ONLINE，OFFLINE, BOOTLOADER或RECOVERY。</li><li><strong>提供操作命令</strong> ：adb提供了很多命令(<code>adb shell</code>，<code>adb pull</code>)，来实现对设备的操控。这些操作命令在adb的体系里面，都称为“服务”。</li></ul><h1 id="ADB-实现原理"><a href="#ADB-实现原理" class="headerlink" title="ADB 实现原理"></a>ADB 实现原理</h1><p>Adb的全称为 Android Debug Bridge：Android调试桥，下图为Android官方对adb的介绍：</p><p><img src="/gallery/android_common/adb-introduce.png" alt=""></p><a id="more"></a><p>Android Debug Bridge (adb) 是一个通用命令行工具，其允许我们与模拟器或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用，并提供对 Unix shell（可用来在模拟器或连接的设备上运行各种命令）的访问。该工具是一个C/S架构实现的程序，包括三个组件：</p><ul><li><strong>ADB Client</strong>：运行在PC上，通过在命令行执行adb，就启动了ADB Client程序</li><li><strong>ADB Server</strong>：运行于PC的后台进程，用于管理ADB Client和Daemon间的通信</li><li><strong>ADB Daemon</strong> (即adbd) ：运行在模拟器或移动设备上的后台服务。当Android系统启动时，由init程序启动adbd。如果adbd挂了，则adbd会由init重新启动。</li></ul><p>您可以在 <code>android_sdk/platform-tools/</code> 中找到 <code>adb</code> 工具。</p><p><img src="/gallery/android_common/adb_architecture.png" alt=""></p><h2 id="ADB-源码"><a href="#ADB-源码" class="headerlink" title="ADB 源码"></a>ADB 源码</h2><p>adb的源码在 <a href="[http://androidxref.com/8.1.0_r33/xref/system/core/adb/](http://androidxref.com/8.1.0_r33/xref/system/core/adb/">system/core/adb</a> 目录下，adb和adbd两个二进制程序都是从这个目录下的代码中编译出来的，可以参考 <a href="http://androidxref.com/8.1.0_r33/xref/system/core/adb/Android.mk" target="_blank" rel="noopener"><code>Android.mk</code></a> 文件，通过宏编译开关<strong>ADB_HOST</strong>来控制：</p><h3 id="Client-和-Server-调用的是adb"><a href="#Client-和-Server-调用的是adb" class="headerlink" title="Client 和 Server 调用的是adb"></a><strong>Client 和 Server 调用的是<code>adb</code></strong></h3><p>ADB_HOST=1</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CFLAGS += \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_CFLAGS)</span> \</span><br><span class="line">    -D_GNU_SOURCE \</span><br><span class="line">    -DADB_HOST=1 \</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS_windows := \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_windows_CFLAGS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS_linux := \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_linux_CFLAGS)</span> \</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS_darwin := \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_darwin_CFLAGS)</span> \</span><br><span class="line">    -Wno-sizeof-pointer-memaccess -Wno-unused-parameter \</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := adb</span><br></pre></td></tr></table></figure><h3 id="而-emulator-device-调用adbd"><a href="#而-emulator-device-调用adbd" class="headerlink" title="而 emulator/device 调用adbd"></a><strong>而 emulator/device 调用<code>adbd</code></strong></h3><p>ADB_HOST=0</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CFLAGS := \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_CFLAGS)</span> \</span><br><span class="line">    <span class="variable">$(ADB_COMMON_linux_CFLAGS)</span> \</span><br><span class="line">    -DADB_HOST=0 \</span><br><span class="line">    -D_GNU_SOURCE \</span><br><span class="line">    -Wno-deprecated-declarations \</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS += -DALLOW_ADBD_NO_AUTH=<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">filter</span> userdebug eng,<span class="variable">$(TARGET_BUILD_VARIANT)</span>)</span>,1,0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(<span class="built_in">filter</span> userdebug eng,<span class="variable">$(TARGET_BUILD_VARIANT)</span>)</span>)</span><br><span class="line">LOCAL_CFLAGS += -DALLOW_ADBD_DISABLE_VERITY=1</span><br><span class="line">LOCAL_CFLAGS += -DALLOW_ADBD_ROOT=1</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := adbd</span><br></pre></td></tr></table></figure><p>1、 在PC HOST端，<code>adb</code>会fork出一个守护进程（不是adbd），即ADB Server，而父进程（ADB Client）继续处理Client请求，所有的Client通过TCP端口号5037进行与Server通信，而Server创建 local socket 与 remote socket，前者用于和Client通信，后者用与远端进行通信，emulator通过TCP，real device则通过usb。</p><p>2、在emulator/device端，<code>adbd</code>也创建 local socket 和 remote socket，前者与通过 jdwp 与Java虚拟机进程通信，后者通过 TCP/USB 与 PC HOST通信。</p><p><img src="/gallery/android_common/daemon_server.png" alt=""></p><p>Client和Server虽然是同一个执行程序，但在命令行输入一条<code>adb</code>命令后，实际上完成了一次通信。在Server启动的时候，会将自己绑定到本地的<code>5037</code>端口，当Client有请求到来时，便通过TCP连接Server的5037端口。</p><p>通过以下命令，可以看到server的启动日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb <span class="built_in">kill</span>-server &amp;&amp; adb devices</span><br><span class="line">* daemon not running. starting it now on port 5037 *</span><br><span class="line">* daemon started successfully *</span><br></pre></td></tr></table></figure><p>通过以下命令，可以看到TCP的5037端口，在侦听连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -l | grep 5037</span><br><span class="line">Proto Recv-Q Send-Q    Local Address   Foreign Address     State</span><br><span class="line">tcp        0      0    127.0.0.1:5037  0.0.0.0:*           LISTEN</span><br></pre></td></tr></table></figure><p>当我们执行一些常用的adb命令时，譬如<code>adb devices</code>、<code>adb shell</code>，server就自动启动了，也可以通过<code>adb start-server</code>来启动；如果想要停止server的运行，可以通过<code>adb kill-server</code>来杀掉server进程。</p><h2 id="PC上命令行输入adb命令后发生了什么"><a href="#PC上命令行输入adb命令后发生了什么" class="headerlink" title="PC上命令行输入adb命令后发生了什么"></a>PC上命令行输入adb命令后发生了什么</h2><p><img src="/gallery/android_common/5521037-139ea4a56038e33e.webp" alt=""></p><ol><li>Client 调用某个 <code>adb</code> 命令</li><li>adb 进程 fork 出一个子进程作为 Server</li><li>Server 查找当前连接的 emulator/device</li><li>Server 接收到来自 Client 请求</li><li>Server 处理请求，将本地处理不了的请求发给 emulator/device</li><li>位于 emulator/device 的 <code>adbd</code>拿到请求后交给对应的java虚拟机进程。</li><li>adbd 将结果发回给 Server</li><li>Server 将结果发回给 Client</li></ol><p><img src="/gallery/android_common/adb_communication.png" alt=""></p><h1 id="ADB-Protocol-通信协议"><a href="#ADB-Protocol-通信协议" class="headerlink" title="ADB Protocol 通信协议"></a>ADB Protocol 通信协议</h1><h2 id="1-ADB-Client-和-ADB-Server-间的通信"><a href="#1-ADB-Client-和-ADB-Server-间的通信" class="headerlink" title="1. ADB Client 和 ADB Server 间的通信"></a>1. ADB Client 和 ADB Server 间的通信</h2><p>这个数据通道是一个本地TCP连接，ADB Server启动以后，在本地的5037端口侦听。ADB Client通过本地的随机端口与5037端口建立连接。</p><p>在这个通道上，Client向Server发送的命令都遵循如下格式：</p><ol><li><strong>命令的长度(Length)</strong>，由四位的十六进制表示</li><li><strong>实际的命令(Payload)</strong>，通过ASCII编码</li></ol><p>Client 和 Server 间传输的命令定义源码在 <a href="http://androidxref.com/8.1.0_r33/xref/system/core/adb/SERVICES.TXT" target="_blank" rel="noopener">/system/core/adb/SERVICES.TXT</a> 文件中，截取部分命令如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">This file tries to document all requests a client can make</span><br><span class="line">to the ADB server of an adbd daemon. See the OVERVIEW.TXT document</span><br><span class="line">to understand what&apos;s going on here.</span><br><span class="line"></span><br><span class="line">HOST SERVICES:</span><br><span class="line"></span><br><span class="line">host:version</span><br><span class="line">    Ask the ADB server for its internal version number.</span><br><span class="line"></span><br><span class="line">    As a special exception, the server will respond with a 4-byte</span><br><span class="line">    hex string corresponding to its internal version number, without</span><br><span class="line">    any OKAY or FAIL.</span><br><span class="line"></span><br><span class="line">host:kill</span><br><span class="line">    Ask the ADB server to quit immediately. This is used when the</span><br><span class="line">    ADB client detects that an obsolete server is running after an</span><br><span class="line">    upgrade.</span><br><span class="line"></span><br><span class="line">host:devices</span><br><span class="line">host:devices-l</span><br><span class="line">    Ask to return the list of available Android devices and their</span><br><span class="line">    state. devices-l includes the device paths in the state.</span><br><span class="line">    After the OKAY, this is followed by a 4-byte hex len,</span><br><span class="line">    and a string that will be dumped as-is by the client, then</span><br><span class="line">    the connection is closed</span><br><span class="line">    </span><br><span class="line">// 以下省略...</span><br></pre></td></tr></table></figure><p>譬如，查看adb当前的版本，Client会发起如下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>Chost:version</span><br></pre></td></tr></table></figure><p>000C：表示”host:version”这条命令的长度为12个字节；</p><p>host前缀：是为了区分其他类型的命令(后面还会看到shell前缀的命令)；</p><p><img src="/gallery/android_common/adbclient_hostversion.png" alt=""></p><p>Server收到Client的请求后，返回的数据遵循如下格式：</p><ol><li>如果成功，则返回四个字节的字符串”<strong>OKAY</strong>“</li><li>如果失败，则返回四个字节的字符串”<strong>FAIL</strong>“和<strong>出错原因</strong></li><li>如果异常，则返回<strong>错误码</strong></li></ol><p>当Client收到Server返回的”<strong>OKAY</strong>“后，就可以发继续发起其他操作命令了。</p><p><img src="/gallery/android_common/adbclient_OKAY.png" alt=""></p><h2 id="2-ADB-Daemon-和-ADB-Server-间的通信-—-transport协议"><a href="#2-ADB-Daemon-和-ADB-Server-间的通信-—-transport协议" class="headerlink" title="2. ADB Daemon 和 ADB Server 间的通信 — transport协议"></a>2. ADB Daemon 和 ADB Server 间的通信 — transport协议</h2><p>Android 源码中关于 transport 协议的定义在  <a href="[http://androidxref.com/8.1.0_r33/xref/system/core/adb/protocol.txt](http://androidxref.com/8.1.0_r33/xref/system/core/adb/protocol.txt">system/core/adb/protocol.txt</a> 文件中。下面是 message header 的格式，共占用24字节，分为6个字段（即每个字段占用4字节）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The transport layer deals in <span class="string">"messages"</span>, which consist of a <span class="number">24</span> byte</span><br><span class="line">header followed (optionally) by a payload.  The header consists of 6</span><br><span class="line"><span class="number">32</span> bit words which are sent across the wire in little endian format.</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> command;       <span class="comment">/* command identifier constant (A_CNXN, ...) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> arg0;          <span class="comment">/* first argument                            */</span></span><br><span class="line">    <span class="keyword">unsigned</span> arg1;          <span class="comment">/* second argument                           */</span></span><br><span class="line">    <span class="keyword">unsigned</span> data_length;   <span class="comment">/* length of payload (0 is allowed)          */</span></span><br><span class="line">    <span class="keyword">unsigned</span> data_crc32;    <span class="comment">/* crc32 of data payload                     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> magic;         <span class="comment">/* command ^ 0xffffffff                      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且定义了7种 command，以及每种指令后携带的参数含义 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- message command constants ------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_SYNC 0x434e5953</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_CNXN 0x4e584e43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_AUTH 0x48545541</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_OPEN 0x4e45504f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_OKAY 0x59414b4f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_CLSE 0x45534c43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A_WRTE 0x45545257</span></span><br></pre></td></tr></table></figure><p><img src="/gallery/android_common/adbtransport_auth.png" alt="使用TCP连接的ADB抓到的包（同一wifi下）"></p><h1 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h1><p>一、<strong>PC上为什么要有一个ADB Server，而不是ADB Client 和 ADB Daemon 直接通信呢？</strong></p><p>因为 ADB 是一个需要支持多对多架构的工具，一个PC可以连接多台手机设备或虚拟机，一个手机也可以同时连接多台PC。就需要一个统一的Sever管理多个设备的连接。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/bf58b58afb1d" target="_blank" rel="noopener">【android】Android ADB工具 adb,adbd,client,server之间的关系</a></li><li><a href="https://duanqz.github.io/2015-05-21-Intro-adb" target="_blank" rel="noopener">adb介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ADB简介&quot;&gt;&lt;a href=&quot;#ADB简介&quot; class=&quot;headerlink&quot; title=&quot;ADB简介&quot;&gt;&lt;/a&gt;ADB简介&lt;/h1&gt;&lt;blockquote class=&quot;pullquote right&quot;&gt;&lt;p&gt;&lt;img src=&quot;/gallery/android_common/ADB-feature.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android Debug Bridge (adb) 是一个Android的命令行工具。可以用来连接模拟器或实际的移动设备。比如 adb logcat, adb shell。Dalvik Debug Monitor Server(DDMS) 后台也是运行的adb来实现监控调试移动设备。&lt;/p&gt;
&lt;p&gt;总体而言，adb有两个用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控连接设备&lt;/strong&gt; ：adb会监控所有已经连接设备(包括模拟器)，譬如设备所处的状态：ONLINE，OFFLINE, BOOTLOADER或RECOVERY。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供操作命令&lt;/strong&gt; ：adb提供了很多命令(&lt;code&gt;adb shell&lt;/code&gt;，&lt;code&gt;adb pull&lt;/code&gt;)，来实现对设备的操控。这些操作命令在adb的体系里面，都称为“服务”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;ADB-实现原理&quot;&gt;&lt;a href=&quot;#ADB-实现原理&quot; class=&quot;headerlink&quot; title=&quot;ADB 实现原理&quot;&gt;&lt;/a&gt;ADB 实现原理&lt;/h1&gt;&lt;p&gt;Adb的全称为 Android Debug Bridge：Android调试桥，下图为Android官方对adb的介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/adb-introduce.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Doze模式识别与检测</title>
    <link href="https://itimetraveler.github.io/2019/05/25/Android%20Doze%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    <id>https://itimetraveler.github.io/2019/05/25/Android Doze模式识别/</id>
    <published>2019-05-25T14:20:55.000Z</published>
    <updated>2019-07-01T13:23:18.368Z</updated>
    
    <content type="html"><![CDATA[<p>从 Android 6.0（API 级别 23）开始，Android 引入了两个省电功能：Doze模式（官方翻译为低电耗模式）和 App Standby模式（官方翻译为应用待机模式），可通过管理应用在设备未连接至电源时的行为方式为用户延长电池寿命。<strong>Doze模式</strong>通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络 Activity 来减少电池消耗。<strong>App Standby模式</strong>可推迟用户近期未与之交互的应用的后台网络 Activity。</p><h2 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h2><p>满足以下条件的设备会进入Doze低电耗模式。</p><ul><li>用户设备未插接电源</li><li>处于静止状态一段时间</li><li>屏幕关闭 </li></ul><p>在低电耗模式下，系统会尝试通过限制应用对网络和 CPU 密集型服务的访问来节省电量。 这还可以阻止应用访问网络并推迟其作业、同步和标准闹铃。</p><p>系统会定期退出Doze低电耗模式一会儿，好让应用完成其已推迟的 Activity。在此维护时段内，系统会运行所有待定同步、作业和闹铃并允许应用访问网络。</p><p><img src="/gallery/android_common/doze.png" alt="图 1. 低电耗模式提供了定期维护时段，可供应用使用网络并处理待定 Activity。"></p><a id="more"></a><p>在每个维护时段结束后，系统会再次进入低电耗模式，暂停网络访问并推迟作业、同步和闹铃。 随着时间的推移，系统安排维护时段的次数越来越少，这有助于在设备未连接至充电器的情况下长期处于不活动状态时降低电池消耗。</p><p>一旦用户有以下行为，系统就会立即退出低电耗模式，并且所有应用都将返回到正常 Activity。</p><ul><li>移动手机设备（通过运动检测传感器识别）</li><li>打开屏幕</li><li>连接到充电器唤醒设备</li></ul><h3 id="Doze模式下的限制"><a href="#Doze模式下的限制" class="headerlink" title="Doze模式下的限制"></a>Doze模式下的限制</h3><p>在低电耗模式下，您的应用会受到以下限制：</p><ul><li>暂停访问网络。</li><li>系统将忽略 <a href="https://developer.android.com/reference/android/os/PowerManager.WakeLock.html" target="_blank" rel="noopener">wake locks</a>。</li><li>标准 <code>AlarmManager</code> 闹铃（包括 <code>setExact()</code> 和 <code>setWindow()</code>）推迟到下一维护时段。</li><li><ul><li>如果您需要设置在低电耗模式下触发的闹铃，请使用 <code>setAndAllowWhileIdle()</code> 或 <code>setExactAndAllowWhileIdle()</code>。</li><li>一般情况下，使用 <code>setAlarmClock()</code> 设置的闹铃将继续触发 — 但系统会在这些闹铃触发之前不久退出低电耗模式。</li></ul></li><li>系统不执行 Wi-Fi 扫描。</li><li>系统不允许运行<a href="https://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html" target="_blank" rel="noopener">同步适配器</a>。</li><li>系统不允许运行 <code>JobScheduler</code>。</li></ul><h3 id="在Doze模式下测试"><a href="#在Doze模式下测试" class="headerlink" title="在Doze模式下测试"></a>在Doze模式下测试</h3><p>可按以下步骤测试doze模式：</p><ol><li>使用 Android 6.0（API 级别 23）或更高版本的系统映像配置硬件设备或虚拟设备。</li><li>将设备连接到开发计算机并安装应用</li><li>运行应用并使其保持活动状态</li><li>关闭设备屏幕。（应用保持活动状态。）</li><li><p>通过运行以下命令强制系统在Doze低电耗模式之间循环切换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> adb shell dumpsys battery unplug</span><br><span class="line"><span class="meta">$</span> adb shell dumpsys deviceidle step</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果没有生效，可以尝试以下命令</span><br><span class="line"><span class="meta">$</span> adb shell dumpsys deviceidle force-idle</span><br></pre></td></tr></table></figure><p>您可能需要多次运行第二个命令。不断地重复，直到设备变为空闲状态。</p></li><li>在重新激活设备后观察应用的行为。确保应用在设备退出Doze低电耗模式时正常恢复。</li></ol><h2 id="App-Standby-模式"><a href="#App-Standby-模式" class="headerlink" title="App Standby 模式"></a>App Standby 模式</h2><p>App Standby 模式（也称为应用待机模式）允许系统判定应用在用户未主动使用它时处于空闲状态。 当用户有一段时间未触摸应用时，系统便会作出此判定，以下条件均不适用：</p><ul><li>用户显式启动应用。</li><li>应用当前有一个进程位于前台（表现为 Activity 或前台服务形式，或被另一 Activity 或前台服务占用）。</li><li>应用生成用户可在锁屏或通知托盘中看到的通知。</li></ul><p>当用户将设备插入电源时，系统将从待机状态释放应用，从而让它们可以自由访问网络并执行任何待定作业和同步。 如果设备长时间处于空闲状态，系统将按每天大约一次的频率允许空闲应用访问网络。</p><h3 id="在-App-Standby-模式下测试"><a href="#在-App-Standby-模式下测试" class="headerlink" title="在 App Standby 模式下测试"></a>在 App Standby 模式下测试</h3><p>要在App Standby模式下测试应用，可以执行以下操作：</p><ol><li>使用 Android 6.0（API 级别 23）或更高版本的系统映像配置硬件设备或虚拟设备。</li><li>将设备连接到开发计算机并安装应用</li><li>运行应用并使其保持活动状态</li><li><p>通过运行以下命令强制应用进入应用待机模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> adb shell dumpsys battery unplug</span><br><span class="line"><span class="meta">$</span> adb shell am set-inactive &lt;packageName&gt; true</span><br></pre></td></tr></table></figure></li><li><p>使用以下命令模拟唤醒应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell am <span class="built_in">set</span>-inactive &lt;packageName&gt; <span class="literal">false</span></span><br><span class="line">$ adb shell am get-inactive &lt;packageName&gt;</span><br></pre></td></tr></table></figure></li><li><p>观察唤醒后的应用行为。确保应用从待机模式中正常恢复。 特别地，您应检查应用的通知和后台作业是否按预期继续运行</p></li></ol><h2 id="Doze-模式和-App-Standby-模式的区别"><a href="#Doze-模式和-App-Standby-模式的区别" class="headerlink" title="Doze 模式和 App Standby 模式的区别"></a><strong>Doze 模式和 App Standby 模式的区别</strong></h2><p>Doze模式需要屏幕关闭（通常晚上睡觉或长时间屏幕关闭才会进入），而App Standby不需要屏幕关闭，App进入后台一段时间也会受到连接网络等限制。</p><h2 id="Doze-模式和休眠模式的区别"><a href="#Doze-模式和休眠模式的区别" class="headerlink" title="Doze 模式和休眠模式的区别"></a>Doze 模式和休眠模式的区别</h2><p>可以参考 StackOverflow 中的回答： <a href="https://android.stackexchange.com/questions/149442/difference-between-doze-mode-and-sleep-mode-in-android-marshmallow" target="_blank" rel="noopener">Difference between Doze Mode and Sleep Mode in Android Marshmallow</a></p><blockquote><p><strong>Sleep Mode</strong> - means CPU will be sleeping and will not accept any command except from RIL(Radio Interface Layer) and alarms. CPU will go to sleep mode with in fraction of seconds after LCD is turned off.</p><p><strong>Doze Mode</strong> - means that apps on your phone will have no network access, the system will ignore “wakelocks” when apps try to keep the device from going to sleep, and no background tasks will be allowed to run. That certainly makes it sound like your phone won’t do you much good, but there are a few ways Doze preserves functionality. While apps can’t wake the device up to run sync jobs and other background tasks, high-priority push messages will still show up. So for example, a Hangouts message will appear on a device that’s in Doze mode.</p><p><strong>App Standby</strong> - an app that goes into standby loses all network access and all its background sync jobs are suspended. These restrictions are temporarily lifted when your phone is plugged in and for a few minutes every day or two. This gives suspended apps a chance to run any pending sync jobs, but they won’t be allowed to continue running. A high-priority push notification will also be able to wake an app from standby for a short time.</p></blockquote><h2 id="Doze-模式源码分析"><a href="#Doze-模式源码分析" class="headerlink" title="Doze 模式源码分析"></a>Doze 模式源码分析</h2><p>在Android M版本中为了实现Doze模式，新增了一个DeviceIdle的服务，其实现的代码位于<code>frameworks/base/services/core/java/com/android/server/DeviceIdleController.java</code>中。<code>SystemServer</code>在开机时会启动这个服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.startService(DeviceIdleController.class);</span><br></pre></td></tr></table></figure><p>关于doze模式的控制逻辑都是在这个新增的服务中实现的，进入doze之后的几个功耗策略：限制网络连接、阻止partial类型的wakelock、阻止Alarm、系统不扫描wifi热点、阻止sync任务、不允许JobScheduler进行任务调度。所以除了控制逻辑之外，还在NetworkPolicyManagerService、JobSchedulerService、SyncManager、PowerManagerService和AlarmManagerService中加入了对doze状态的监听和查询接口来进行响应的操作。其控制逻辑和策略实现的代码关系如下图所示。在DeviceIdleController中实现对设备状态的控制和改变，并且通知其他相关注册了AppIdleStateChangeListener接口的服务进行处理，而反过来这些服务也可以向DeviceIdleController查询device的状态，是一种交互的关系。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Device is currently active. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_ACTIVE = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Device is inactive (screen off, no motion) and we are waiting to for idle. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_INACTIVE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Device is past the initial inactive period, and waiting for the next idle period. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IDLE_PENDING = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** Device is currently sensing motion. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_SENSING = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** Device is currently finding location (and may still be sensing). */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_LOCATING = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/** Device is in the idle state, trying to stay asleep as much as possible. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IDLE = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** Device is in the idle state, but temporarily out of idle to do regular maintenance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IDLE_MAINTENANCE = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>Doze模式具体包含了7种状态：</p><ol><li><strong>ACTIVE</strong>：当设备亮屏或者处于正常使用状态时其就为ACTIVE状态；</li><li><strong>INACTIVE</strong>：ACTIVE状态下不插充电器或者usb且灭屏设备就会切换到INACTIVE状态；</li><li><strong>IDLE_PENDING</strong>：INACTIVE状态经过30分钟，期间检测没有打断状态的行为Doze就切换到IDLE_PENDING的状态；</li><li><strong>SENSING</strong>：然后再经过30分钟以及一系列的判断，状态切换到SENSING；</li><li><strong>LOCATION</strong>：在SENSING状态下会去检测是否有地理位置变化，没有的话就切到LOCATION状态；</li><li><strong>IDLE</strong>：LOCATION状态下再经过30s的检测时间之后就进入了Doze的核心状态IDLE；</li><li><strong>IDLE_MAINTANCE</strong>：在IDLE模式下每隔一段时间就会进入一次IDLE_MAINTANCE，此间用来处理之前被挂起的一些任务；</li><li>IDLE_MAINTANCE状态持续5分钟之后会重新回到IDLE状态；</li><li>在除ACTIVE以外的所有状态中，检测到打断的行为如亮屏、插入充电器，位置的改变等状态就会回到ACTIVE，重新开始下一个轮回。 </li></ol><p><img src="/gallery/android_commondoze_modestate.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/training/monitoring-device-state/doze-standby" target="_blank" rel="noopener">Optimize for Doze and App Standby</a> - Google Developer</li><li><a href="https://cloud.tencent.com/developer/article/1030692" target="_blank" rel="noopener">Android M doze特性预研</a> - 微信终端开发团队</li><li><a href="https://cloud.tencent.com/developer/article/1004430" target="_blank" rel="noopener">ndroid M 特性 Doze and App Standby模式详解</a> - QQ空间开发团队</li><li><a href="https://android.stackexchange.com/questions/149442/difference-between-doze-mode-and-sleep-mode-in-android-marshmallow" target="_blank" rel="noopener">Difference between Doze Mode and Sleep Mode in Android Marshmallow</a> - StackOverflow</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 Android 6.0（API 级别 23）开始，Android 引入了两个省电功能：Doze模式（官方翻译为低电耗模式）和 App Standby模式（官方翻译为应用待机模式），可通过管理应用在设备未连接至电源时的行为方式为用户延长电池寿命。&lt;strong&gt;Doze模式&lt;/strong&gt;通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络 Activity 来减少电池消耗。&lt;strong&gt;App Standby模式&lt;/strong&gt;可推迟用户近期未与之交互的应用的后台网络 Activity。&lt;/p&gt;
&lt;h2 id=&quot;Doze模式&quot;&gt;&lt;a href=&quot;#Doze模式&quot; class=&quot;headerlink&quot; title=&quot;Doze模式&quot;&gt;&lt;/a&gt;Doze模式&lt;/h2&gt;&lt;p&gt;满足以下条件的设备会进入Doze低电耗模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户设备未插接电源&lt;/li&gt;
&lt;li&gt;处于静止状态一段时间&lt;/li&gt;
&lt;li&gt;屏幕关闭 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在低电耗模式下，系统会尝试通过限制应用对网络和 CPU 密集型服务的访问来节省电量。 这还可以阻止应用访问网络并推迟其作业、同步和标准闹铃。&lt;/p&gt;
&lt;p&gt;系统会定期退出Doze低电耗模式一会儿，好让应用完成其已推迟的 Activity。在此维护时段内，系统会运行所有待定同步、作业和闹铃并允许应用访问网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/doze.png&quot; alt=&quot;图 1. 低电耗模式提供了定期维护时段，可供应用使用网络并处理待定 Activity。&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPv6安全浅析</title>
    <link href="https://itimetraveler.github.io/2019/03/13/IPv6%E5%AE%89%E5%85%A8%E6%B5%85%E6%9E%90/"/>
    <id>https://itimetraveler.github.io/2019/03/13/IPv6安全浅析/</id>
    <published>2019-03-13T03:51:55.000Z</published>
    <updated>2019-03-13T11:55:51.285Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 ：<a href="https://www.huawei.com/ilink/en/download/HW_079734" target="_blank" rel="noopener">IPv6安全浅析 - Huawei - 2010.12 第52期</a> </p></blockquote><p>“缺乏安全性是互联网天生的弱点，这与是否采用IPv6关系不大。事实上，IPv6并没有引入新的安全问题，反而由于IPSec的引入以及发送设备采用永久性IP地址而解决了网络层溯源难题，给网络安全提供了根本的解决途径，有望实现端到端安全性。”中国电信科技委主任韦乐平这样评价IPv6安全。</p><h2 id="IPv6协议设计的安全考虑"><a href="#IPv6协议设计的安全考虑" class="headerlink" title="IPv6协议设计的安全考虑"></a>IPv6协议设计的安全考虑</h2><p>从协议的角度，IPv6作为IPv4的下一代，与IPv4同属于网络层的传输协议。然而，协议上最核心、最本质的差别就是地址空间的扩大，由IPv4下的32位地址空间变为128位的地址空间，这正是IPv6被选作新网络的承载协议并逐渐商用部署的根本驱动力。IPv6拥有如此巨大的地址空间，甚至可以为每一粒沙子都分配一个IP地址。而IPv4网络的地址分配是不规则的，并且很多时候是一个地址被多台主机共用。使用IPv6之后，我们能够将每个地址指定给一个责任体，就像给每个人一个身份证号，每辆车一个车牌号一样，每个地址都是唯一的；IPv6的地址分配采用逐级、层次化的结构，这就使得追踪定位、攻击溯源有了很大的改善。</p><p>另外，IPv6提出了新的地址生成方式——密码生成地址。密码生成地址与公私钥对绑定，保证地址不能被他人伪造。这如同汽车的车牌印上了指纹，别人不可能伪造这样的车牌，因为指纹造不了假。在IPv6协议设计之初，IP Sec（IPSecurity）协议族中的AH（AuthenticationHeader，报文认证头）和ESP（EncapsulationSecurity Payload，报文封装安全载荷）就内嵌到协议栈中，作为IPv6的扩展头出现在IP报文中，提供完整性、保密性和源认保护，这无疑是从协议上较大地提升安全性。</p><p>整体上看，IPv4协议的设计没有任何的安全考虑，特别是报文地址的伪造与欺骗使得无法对网络进行有效的监管和控制。因此，当出现网络攻击与安全威胁时，我们只能围绕攻击事件做好事前、事中和事后的防范、检测和过滤防御，缺乏有效的技术支撑手段，无法对攻击者形成真正的打击和管控。</p><p>而在IPv6网络的安全体系下，用户、报文和攻击可以一一对应，用户对自己的任何行为都必须负责，具有不可否认性，所以IPv6建立起严密的围绕攻击者的管控机制，实现对用户行为的安全监控。</p><a id="more"></a><h2 id="IPv6能减缓现有攻击"><a href="#IPv6能减缓现有攻击" class="headerlink" title="IPv6能减缓现有攻击"></a>IPv6能减缓现有攻击</h2><p>扫描几乎是任何攻击手段的必需前提。攻击者利用扫描收集目标网络的数据，据此分析、推断目标网络的拓扑结构、开放的服务、知名端口等有用信息，以作为真正攻击的基础。扫描的主要目的是通过ping每个地址，找到作为潜在攻击目标的在线主机或设备。</p><p>在IPv6时代，每个地址为128位，协议中规定的默认网络前缀为64位。换句话说，就是一个网段内有264个地址，假设攻击者以10M/s的速度来扫描，也得需要大约5万年的时间才能遍历。IPv6大大增大了扫描难度，由此增加了网络攻击的成本和代价。此时，黑客如果想侵占一定数量的主机发起DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，那么其将会付出更多的代价，这在一定程度上减少了DDoS攻击发生的可能性。</p><p>IPv6协议定义了多播地址类型，而取消了IPv4下的广播地址，有效避免IPv4网络中的利用广播地址发起的广播风暴攻击和DDoS攻击。同时，IPv6协议规定了不允许向使用多播地址的报文回复ICMPv6（Internet Control Management Protocol Version6）差错消息，因此也能防止ICMPv6报文造成的放大攻击。</p><p>IPv6下的密码生成地址是新的地址生成方式，将公私钥对中的公钥与IPv6地址进行绑定。使用此类地址，能够保证报文的源地址不被他人伪造。在这样的安全机制保护下，在网络中传输的每一个报文均对应于一台主机，如果发生任何的攻击或者违法犯罪行为，都能够根据攻击报文追踪到发出此报文的主机，进而追查到攻击者。这种可靠的追踪溯源机制，使得黑客和攻击者容易被发现，这样就减少了网络攻击发生的可能。</p><h2 id="IPv6面临的新威胁"><a href="#IPv6面临的新威胁" class="headerlink" title="IPv6面临的新威胁"></a>IPv6面临的新威胁</h2><p>IPv6协议对IPv4协议的根本改变是发生在IP层，因此针对IPv6协议所定义的包<br>头及扩展头的、容易发生的安全威胁，我们需要进行充分的准备。常见的针对IPv6扩展头的攻击，主要包括利用分片扩展头发起分片攻击，逃避防火墙/IDS（Intrusion Detection System，入侵检测系统）的检查或者发动DDoS攻击；利用路由扩展头的type 0类型，在网络中发起放大攻击。</p><p>在IPv4向IPv6的演进过程中，我们还需要考虑各种过渡技术与方案的安全隐患。由于在共存时期，IPv4网络与IPv6网络同时存在，且有互通需求，这就要求来自两种不同IP协议网络的威胁不能够交叉感染。另外，运营商所选择部署的各种过渡技术，由于尚无成熟的使用经验，因此很可能存在潜在的安全风险。</p><p>具体来看，隧道技术是对报文进行一层封装。隧道报文在经过网络安全设备时，如果需要被检查与过滤，那网络安全技术就得支持各种新的隧道协议，能够对隧道进行解封装，而后才能对内嵌报文进行处理。在建立各种隧道的时候，对隧道节点的认证是十分必要的。否则，所建立的隧道是不可靠的，隧道就会被黑客和攻击者利用，成为进<br>入某个目标网络的通路。</p><p>而在利用翻译技术将IPv6与IPv4网络进行互联互通时，要改变报文的IP层及传输层的相关信息，这样会对端到端的安全产生影响，导致IPSec的三层安全隧道在翻译设备处出现断点。同时，翻译设备作为网络互通的关键节点，会成为DDoS攻击的主要目标。</p><p>总之，安全隐患的主要根源是网络协议设计的缺陷和网络设备开发的bug，或者是网络协议的部署与使用出现问题。在IPv6商用之初，我们应利用IPv6协议提供的新安全特性，先解决部分类似IPv4下已有的威胁。随着IPv6网络的扩大以及各种应用的迁移和增多，我们需要更多关注新型攻击。</p><h2 id="IPv6的安全机制和策略"><a href="#IPv6的安全机制和策略" class="headerlink" title="IPv6的安全机制和策略"></a>IPv6的安全机制和策略</h2><blockquote><p>在IPv6/IPv4共存时期，过渡技术的安全部署尤为重要。各种网络安全设备都要具备对IPv6和IPv4威胁的防护能力。我们在使用隧道技术时，要尽可能采用静态配置隧道，以降低动态隧道的伪造和非法接入威胁。</p></blockquote><h3 id="充分利用地址自身的安全特性"><a href="#充分利用地址自身的安全特性" class="headerlink" title="充分利用地址自身的安全特性"></a>充分利用地址自身的安全特性</h3><p>在合适的场景下，使用密码生成地址有助于发现针对ND（Neighbor Discovery，邻居发现）协议和DHCPv6（Dynamic Host Configuration Protocol for IPv6，IPv6动态主机配置协议）协议的欺骗和伪造等问题。由于拥有自身的公私钥对，密码生成地址还可用于IPSec的协商，在某些场景下可以简化协商过程，提高IPSec的性能。</p><p>另一种关于地址的安全机制是隐私扩展。由于IPv6网络不需要地址转换，因此没有NAT（Network Address Translation，网络地址转换）设备，这样一来就会将内网的结构及相关信息暴露。所以，内网的网络设备要依靠隐私扩展机制，通过周期性的地址改变，防止内部网络信息的泄露。</p><h3 id="设定精细的过滤策略"><a href="#设定精细的过滤策略" class="headerlink" title="设定精细的过滤策略"></a>设定精细的过滤策略</h3><p>面对IPv6地址结构以及相关协议的改变，防火墙或者网络边界设备需要设定更加精细的过滤规则。防火墙需要拒绝对内网知名多播地址访问的报文，关闭不必要的服务端口，过滤内网使用的地址。在对ICMP报文的处理上，由于IPv6对ICMPv6的依赖程度远远超过了IPv4，ICMPv6除了完成ping及错误消息外，还新增了地址分配、地址解析、多播管理和移动IPv6下的使用等功能，因此ICMPv6报文的过滤策略需要根据实际情况小心设置，避免影响正常的服务和应用。</p><p>为了防护IPv6扩展头的隐患，防火墙需检查扩展头的合法性。对于分片报文，防火墙能拒绝发送到网络中间设备的分片，并支持重组，具备防DDoS攻击能力。防火墙能识别type 0类型的路由扩展头报文，对其进行过滤。入口过滤机制在防火墙和边界设备上的实现也是必要的，以缓解网络间的源地址伪造威胁。</p><h3 id="合理的部署策略"><a href="#合理的部署策略" class="headerlink" title="合理的部署策略"></a>合理的部署策略</h3><p>在IPv6/IPv4共存时期，过渡技术的安全部署尤为重要。各种网络安全设备都要具备对IPv6和IPv4威胁的防护能力。我们在使用隧道技术时，要尽可能采用静态配置隧道，以降低动态隧道的伪造和非法接入威胁。防火墙要设置对非授权隧道报文的过滤，同时识别各种隧道协议，能够对隧道报文的内嵌封装报文做访问控制。翻译设备则要做好自身的DDoS攻击防范。</p><p>2010年是IPv6的商用元年，各大运营商纷纷制定过渡方案，宣布演进计划，开启试点城市。华为的安全产品已经为IPv6商用做好了充分准备，2009年通过了IPv6 Ready认证。值得一提的是，华为IPv6防火墙在国内首家通过IPv6 Ready第二阶段增强认证，而且能将当前多种主流的过渡技术与方案集成于同一设备，满足了当前IPv6商用的市场需求。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.huawei.com/ilink/en/download/HW_079734" target="_blank" rel="noopener">IPv6安全浅析 - Huawei - 2010.12 第52期</a> </li><li><a href="http://iot.10086.cn:81/Uploads/file/news/20181205/20181205173726_92618.pdf" target="_blank" rel="noopener">IPv6安全白皮书 - 中移物联网 - 中国移动</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接 ：&lt;a href=&quot;https://www.huawei.com/ilink/en/download/HW_079734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IPv6安全浅析 - Huawei - 2010.12 第52期&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“缺乏安全性是互联网天生的弱点，这与是否采用IPv6关系不大。事实上，IPv6并没有引入新的安全问题，反而由于IPSec的引入以及发送设备采用永久性IP地址而解决了网络层溯源难题，给网络安全提供了根本的解决途径，有望实现端到端安全性。”中国电信科技委主任韦乐平这样评价IPv6安全。&lt;/p&gt;
&lt;h2 id=&quot;IPv6协议设计的安全考虑&quot;&gt;&lt;a href=&quot;#IPv6协议设计的安全考虑&quot; class=&quot;headerlink&quot; title=&quot;IPv6协议设计的安全考虑&quot;&gt;&lt;/a&gt;IPv6协议设计的安全考虑&lt;/h2&gt;&lt;p&gt;从协议的角度，IPv6作为IPv4的下一代，与IPv4同属于网络层的传输协议。然而，协议上最核心、最本质的差别就是地址空间的扩大，由IPv4下的32位地址空间变为128位的地址空间，这正是IPv6被选作新网络的承载协议并逐渐商用部署的根本驱动力。IPv6拥有如此巨大的地址空间，甚至可以为每一粒沙子都分配一个IP地址。而IPv4网络的地址分配是不规则的，并且很多时候是一个地址被多台主机共用。使用IPv6之后，我们能够将每个地址指定给一个责任体，就像给每个人一个身份证号，每辆车一个车牌号一样，每个地址都是唯一的；IPv6的地址分配采用逐级、层次化的结构，这就使得追踪定位、攻击溯源有了很大的改善。&lt;/p&gt;
&lt;p&gt;另外，IPv6提出了新的地址生成方式——密码生成地址。密码生成地址与公私钥对绑定，保证地址不能被他人伪造。这如同汽车的车牌印上了指纹，别人不可能伪造这样的车牌，因为指纹造不了假。在IPv6协议设计之初，IP Sec（IPSecurity）协议族中的AH（AuthenticationHeader，报文认证头）和ESP（EncapsulationSecurity Payload，报文封装安全载荷）就内嵌到协议栈中，作为IPv6的扩展头出现在IP报文中，提供完整性、保密性和源认保护，这无疑是从协议上较大地提升安全性。&lt;/p&gt;
&lt;p&gt;整体上看，IPv4协议的设计没有任何的安全考虑，特别是报文地址的伪造与欺骗使得无法对网络进行有效的监管和控制。因此，当出现网络攻击与安全威胁时，我们只能围绕攻击事件做好事前、事中和事后的防范、检测和过滤防御，缺乏有效的技术支撑手段，无法对攻击者形成真正的打击和管控。&lt;/p&gt;
&lt;p&gt;而在IPv6网络的安全体系下，用户、报文和攻击可以一一对应，用户对自己的任何行为都必须负责，具有不可否认性，所以IPv6建立起严密的围绕攻击者的管控机制，实现对用户行为的安全监控。&lt;/p&gt;
    
    </summary>
    
      <category term="IPv6" scheme="https://itimetraveler.github.io/categories/IPv6/"/>
    
    
      <category term="IPv6" scheme="https://itimetraveler.github.io/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS原理与证书生成</title>
    <link href="https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/"/>
    <id>https://itimetraveler.github.io/2018/10/30/HTTPS原理与证书/</id>
    <published>2018-10-30T03:08:00.000Z</published>
    <updated>2018-11-06T02:33:44.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS与HTTP是什么关系呢？我们可以对比下HTTP与HTTPS的请求过程：</p><p><img src="/gallery/common/http-state.png" alt="HTTP请求过程"></p><p>HTTPS 在 TCP 和 HTTP 之间增加了 TLS（Transport Layer Security，传输层安全），提供了<strong>内容加密</strong>、<strong>身份认证</strong>和<strong>数据完整性</strong>三大功能。</p><p><img src="/gallery/common/https-state.png" alt="HTTPS请求过程"></p><a id="more"></a><p>HTTPS也就是HTTP over SSL/TLS，所有的http数据都是在SSL/TLS协议封装之上传输的。Https协议在Http协议的基础上，添加了SSL/TLS握手以及数据加密传输，也属于应用层协议。所以，研究Https协议原理，最终其实是研究SSL/TLS协议。</p><p><img src="/gallery/common/diagram5-session-resumption.png" alt=""></p><p>可以看到，假设服务端和客户端之间单次传输耗时 28ms，那么客户端需要等到 168ms 之后才能开始发送 HTTP 请求报文，这还没把客户端和服务端处理时间算进去。光是 TLS 握手就需要消耗两个 RTT（Round-Trip Time，往返时间），这就是造成 HTTPS 更慢的主要原因。当然，HTTPS 要求数据加密传输，加解密相比 HTTP 也会带来额外的开销，不过对称加密本来就很快，加上硬件性能越来越好，所以这部分开销还好。</p><h3 id="TLS历史"><a href="#TLS历史" class="headerlink" title="TLS历史"></a>TLS历史</h3><p>传输层安全协议（Transport Layer Security，缩写：TLS），及其前身安全套接层（Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p><p><img src="/gallery/common/hpbn_0401.png" alt=""></p><p>SSL包含记录层（Record Layer）和传输层，记录层协议确定了传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p><blockquote><p>1994年早期，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br>1994年11月，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>1996年11月，SSL 3.0版问世，得到大规模应用。<br>1999年1月，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noopener">TLS 1.0版</a>。<br>2006年4月和2008年8月，TLS进行了两次升级，分别为<a href="https://tools.ietf.org/html/rfc4346" target="_blank" rel="noopener">TLS 1.1</a>版和<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">TLS 1.2</a>版。最新的变动是2011年TLS 1.2的修订版。<br>现在正在制定 <a href="https://github.com/tlswg/tls13-spec" target="_blank" rel="noopener">tls 1.3</a>。</p></blockquote><h2 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h2><p>TLS的握手阶段是发生在TCP握手之后。握手实际上是一种协商的过程，对协议所必需的一些参数进行协商。TLS握手过程如下：</p><p><img src="/gallery/common/TLS-handshake-protocol.png" alt=""></p><p>如上图所示，简述如下：</p><ul><li>ClientHello：客户端生成一个随机数 <code>random-client</code>，传到服务器端（Say Hello)</li><li>ServerHello：服务器端生成一个随机数 <code>random-server</code>，和着公钥，一起回馈给客户端（I got it)</li><li>客户端收到的东西原封不动，加上 <code>premaster secret</code>（通过 <code>random-client</code>、<code>random-server</code> 经过一定算法生成的东西），再一次送给服务器端，这次传过去的东西会使用公钥加密</li><li>服务器端先使用私钥解密，拿到 <code>premaster secret</code>，此时客户端和服务器端都拥有了三个要素：<code>random-client</code>、<code>random-server</code> 和 <code>premaster secret</code></li><li>此时安全通道已经建立，以后的交流都会校检上面的三个要素通过算法算出的 <code>session key</code></li></ul><h3 id="Client-Hello-gt"><a href="#Client-Hello-gt" class="headerlink" title="Client Hello =&gt;"></a>Client Hello =&gt;</h3><p>在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。即ClientHello主要包含以下信息：</p><blockquote><ol><li>支持的协议版本，比如 TLS 1.2</li><li>一个客户端⽣成的随机数，稍后用于生成”对话密钥”</li><li>支持的加密方法，⽐如 RSA 公钥加密。</li><li>支持的压缩方法。</li></ol></blockquote><h3 id="Server-Hello-lt"><a href="#Server-Hello-lt" class="headerlink" title="Server Hello &lt;="></a>Server Hello &lt;=</h3><p>上图中，从Server Hello到Server Done，有些服务端的实现是每条单独发送，有服务端实现是合并到一起发送。Sever Hello和Server Done都是只有头没有内容的数据。</p><p>服务端在接收到客户端的Client Hello之后，服务端需要将自己的证书发送给客户端。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。另外，证书还有有效期。</p><p>在服务端向客户端发送的证书中没有提供足够的信息的时候，还可以向客户端发送一个Server Key Exchange。</p><p>此外，对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出Cerficate Request消息，要求客户端发送证书对客户端的合法性进行验证。</p><p>跟客户端一样，服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生Master Secret。最后服务端会发送一个Server Hello Done消息给客户端，表示Server Hello消息结束了。</p><blockquote><ol><li>确认使⽤的加密通信协议版本，⽐如 TLS 1.0 版本。如果浏览器与服务器⽀持的版本不一致，服务器关闭加密通信。</li><li>一个服务器⽣成的随机数，稍后用于生成”对话密钥”。</li><li>确认使用的加密方法，⽐如 RSA 公钥加密。</li><li>服务器证书</li></ol></blockquote><h3 id="Client-Key-Exchange-gt"><a href="#Client-Key-Exchange-gt" class="headerlink" title="Client Key Exchange =&gt;"></a>Client Key Exchange =&gt;</h3><p>如果服务端需要对客户端进行验证，在客户端收到服务端的Server Hello消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。</p><p>在此之前的所有TLS握手信息都是明文传送的。在收到服务端的证书等信息之后，客户端会使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个48个字节的随机数Key，这个Key叫PreMaster Secret，很多材料上也被称作<code>PreMaster Key</code>。这是整个TLS握手期间的第三个随机数。最终通过<code>Master secret</code>生成<code>session secret</code>， <code>session secret</code>就是用来对应用数据进行加解密的会话秘钥。为什么需要<code>PreMaster secret</code>这第三个随机数的Key呢？因为前两个随机数Client Random和Server Random都是明文传输的。中间人可能早已监听到了。如果只使用这两个随机数计算最终的会话秘钥中间人也可以生成。所以<code>PreMaster secret</code>使用RSA非对称加密的方式，使用服务端传过来的公钥进行加密，然后传给服务端。</p><p>接着，客户端需要对服务端的证书进行检查，检查证书的完整性以及证书跟服务端域名是否吻合。</p><p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并传输了。</p><p>在ChangecipherSpec传输完毕之后，客户端会使用之前协商好的加密套件和session secret加密一段Finish的数据传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。</p><blockquote><ol><li>一个随机数<code>PreMaster Key</code>。该随机数用服务器公钥加密，防⽌被窃听。</li><li>编码改变通知，表示随后的信息都将⽤双⽅商定的加密⽅法和密钥发送。</li><li>客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时也是前⾯发送的所有内容的 hash 值，⽤来供服务器校验。</li></ol></blockquote><h3 id="Server-Finish-lt"><a href="#Server-Finish-lt" class="headerlink" title="Server Finish &lt;="></a>Server Finish &lt;=</h3><p>服务端在接收到客户端传过来的PreMaster加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成<code>session secret</code>，一切准备好之后，会给客户端发送一个ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和<code>session secret</code>加密数据了。之后，服务端也会使用<code>session secret</code>加密后一段Finish消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p><blockquote><ol><li>编码改变通知，表示随后的信息都将⽤双方商定的加密⽅法和密钥发送。</li><li>服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时也是前⾯发送的所有内容的 hash 值，⽤来供客户端校验。</li></ol></blockquote><h3 id="应用数据传输"><a href="#应用数据传输" class="headerlink" title="应用数据传输"></a>应用数据传输</h3><p>在所有的握手阶段都完成之后，就可以开始传送应用数据了。应用数据在传输之前，首先要附加上MAC secret，然后再对这个数据包使用write encryption key进行加密。在服务端收到密文之后，使用Client write encryption key进行解密，客户端收到服务端的数据之后使用Server write encryption key进行解密，然后使用各自的write MAC key对数据的完整性包括是否被串改进行验证。</p><h2 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h2><p>在详述过程之前，我们需要了解一下，在过程中会出现的内容。</p><ul><li><code>session key</code>: 这是 TLS/SSL 最后协商的结果，用来进行对称加密。</li><li><code>client random</code>: 是一个 32B 的序列值，每次连接来时，都会动态生成，即，每次连接生成的值都不会一样。因为，他包含了 4B 的时间戳和 28B 的随机数。</li><li><code>server random</code>: 和 <code>client random</code> 一样，只是由 server 端生成。</li><li><code>premaster secret</code>: 这是 48B 的 blob 数据。它能和 client &amp; server random 通过 <code>pseudorandom</code> (PRF) 一起生成 session key。</li><li><code>cipher suite</code>: 用来定义 TLS 连接用到的算法。通常有 4 部分：<ul><li>非对称加密 (ECDH 或 RSA)</li><li>证书验证 (证书的类型)</li><li>保密性 (对称加密算法)</li><li>数据完整性 (产生 hash 的函数) 比如<code>AES128-SHA</code>代表着：<ul><li>RSA 算法进行非对称加密</li><li>RSA 进行证书验证</li><li>128bit AES 对称加密</li><li>160bit SHA 数据加密算法</li></ul></li><li>比如<code>ECDHE-ECDSA-AES256-GCM-SHA384</code>代表着<ul><li>ECDHE 算法进行非对称加密</li><li>ECDSA 进行证书验证</li><li>265bit AES 对称加密</li><li>384bit SHA 数据加密算法</li></ul></li></ul></li></ul><p>上面主要是根据 RSA 加密方式来讲解的。因为 RSA 才会在 TLS/SSL 过程中，将 pre-master secret 显示的进行传输，这样的结果有可能造成，hacker 拿到了 private key 那么他也可以生成一模一样的 sessionKey。即，该次连接的安全性就没了。</p><p>接下来，我们主要讲解一下另外一种加密方式 DH。它和 RSA 的主要区别就是，到底传不传 pre-master secret。RSA 传而 DH 不传。根据 <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/nwmm4058zw/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-16%2022.38.38.png" target="_blank" rel="noopener">cloudflare</a> 的讲解可以清楚的了解到两者的区别：</p><p>这是 RSA 的传输方式，基本过程如上述。</p><p><img src="/gallery/common/https_handshake.png" alt="使用RSA加密算法的TLS握手过程"></p><p>而 DH 具体区别在下图：</p><p><img src="/gallery/common/ssl_handshake_diffie_hellman.jpg" alt="使用DH加密算法的TLS握手过程"></p><p>这里先补充一下 DH 算法的知识。因为，PreMaster secret 就是根据这个生成的。DH 基本过程也不算太难，详情可以参考 <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Description" target="_blank" rel="noopener">wiki</a>。 它主要运用到的公式就是:</p><p><img src="/gallery/common/7b09ebb75344061a3bd483c1369b31a45adad94f.svg" alt=""></p><p>为了防止在 DH 参数交换时，数据过大，DH 使用的是取模数的方式，这样就能限制传输的值永远在 [1,p-1]。这里，先说明一下 DH 算法的基本条件：</p><ul><li>公共条件： p 和 g 都是已知，并且公开。即，第三方也可以随便获取到。</li><li>私有条件： a 和 b 是两端自己生成的，第三方获取不到。</li></ul><p>基本流程就是：</p><p><img src="/gallery/common/屏幕快照 2016-10-17 11.24.41.png" alt="DH算法流程"></p><p>我们只要把上图的 DH parameter 替换为相对应的 X/Y 即可。而最后的 Z 就是我们想要的 Premaster secret。 之后，就和 RSA 加密算法一致，加上两边的 random-num 生成 sessionKey。通过，我们常常称 DH 也叫作 <code>Ephemeral Diffie-Hellman handshake</code>。 因为，他每次一的 sessionKey 都是不同的。</p><p>而 RSA 和 DH 两者之间的具体的区别就在于：RSA 会将 premaster secret 显示的传输，这样有可能会造成私钥泄露引起的安全问题。而 DH 不会将 premaster secret 显示的传输。</p><h2 id="实际抓包"><a href="#实际抓包" class="headerlink" title="实际抓包"></a>实际抓包</h2><p>通过 Wireshark 抓包可以清楚地看到完整 TLS 握手过程所需的两个 RTT，如下图（来自：<a href="https://imququ.com/post/optimize-tls-handshake.html" target="_blank" rel="noopener">TLS 握手优化详解</a>）：</p><p><img src="/gallery/common/wireshake-tls-full-handshake.png" alt=""></p><h2 id="私钥的作用"><a href="#私钥的作用" class="headerlink" title="私钥的作用"></a>私钥的作用</h2><p>握手阶段有三点需要注意。</p><blockquote><p>（1）生成对话密钥一共需要三个随机数。</p><p>（2）握手之后的对话使用”对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密），无其他作用。</p><p>（3）服务器公钥放在服务器的数字证书之中。</p></blockquote><p>从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。</p><p>某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。</p><p><img src="/gallery/common/bg2014092006.png" alt=""></p><p>上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。</p><h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><p>证书是HTTPS实现加密的必要途径，一般的HTTPS服务都是单向认证的过程，单向认证就是对服务器的认证，保证服务器的可靠性，正确的生成证书的方式是服务器（也就是https服务的提供者）产生私钥和公钥对，然后将公钥交给CA（就是证书颁发结构）,CA会给用户的公钥进行签名生成证书，然后将证书颁发给服务端，这样用户访问https服务的时候，就能获得服务端的证书，由于是第三方可靠的CA进行签名过的证书，客户端就会信任HTTPS网站，并且不做安全提醒，如果证书不是由第三方受信任的CA机构颁发，客户端就会提示服务器危险信息。</p><p>HTTPS也有双向认证，双向认证需要客户端也生成证书，客户端检查服务器的证书，服务器检查客户端的证书，一般都不做客户端的检查认证，所以基本都是单向认证。</p><h3 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h3><p>什么叫自签名呢？就是自己通过keytool去生成一个证书，然后使用，并不是CA机构去颁发的。生成的思路是先生成CA证书，在用生成的CA证书签发自己的证书。使用自签名证书的网站，大家在使用浏览器访问的时候，一般都是报风险警告，比如之前的12306就是这么干的，<a href="https://kyfw.12306.cn/otn/" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/</a> ，点击进入12306的购票页面就能看到了。当然现在我重新试了一下已经不是这样了。</p><p><img src="/gallery/common/1440987432776078.png" alt=""></p><h3 id="服务端生成自签证书"><a href="#服务端生成自签证书" class="headerlink" title="服务端生成自签证书"></a>服务端生成自签证书</h3><p>Golang服务端可以参考这里：<a href="https://gist.github.com/denji/12b3a568f092ab951456" target="_blank" rel="noopener">https://gist.github.com/denji/12b3a568f092ab951456</a> 和 <a href="https://gist.github.com/croxton/ebfb5f3ac143cd86542788f972434c96" target="_blank" rel="noopener">Generate ssl certificates with Subject Alt Names on OSX</a></p><h4 id="生成服务端私钥-Generate-private-key-key"><a href="#生成服务端私钥-Generate-private-key-key" class="headerlink" title="生成服务端私钥 Generate private key (.key)"></a>生成服务端私钥 Generate private key (.key)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Key considerations for algorithm "RSA" ≥ 2048-bit</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># Key considerations for algorithm "ECDSA" ≥ secp384r1</span></span><br><span class="line"><span class="comment"># List ECDSA the supported curves (openssl ecparam -list_curves)</span></span><br><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br></pre></td></tr></table></figure><h4 id="生成服务端自签名证书-Generation-of-self-signed-x509-public-key-PEM-encodings-pem-crt-based-on-the-private-key"><a href="#生成服务端自签名证书-Generation-of-self-signed-x509-public-key-PEM-encodings-pem-crt-based-on-the-private-key" class="headerlink" title="生成服务端自签名证书 Generation of self-signed(x509) public key (PEM-encodings .pem|.crt) based on the private (.key)"></a>生成服务端自签名证书 Generation of self-signed(x509) public key (PEM-encodings <code>.pem</code>|<code>.crt</code>) based on the private (<code>.key</code>)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650</span><br></pre></td></tr></table></figure><p>在这里需要大家填写资料（有些地方可以空着）</p><blockquote><p> Country Name (2 letter code) [AU]:CN<br> State or Province Name (full name) [Some-State]:Guangdong<br> Locality Name (eg, city) []:FoShan<br> Organization Name (eg, company) [Internet Widgits Pty Ltd]:TestCA<br> Organizational Unit Name (eg, section) []:<br> Common Name (e.g. server FQDN or YOUR name) []:localhost<br> Email Address []:</p></blockquote><p>这里有点要注意， <code>Common Name (e.g. server FQDN or YOUR name) []:</code> 这一项，是最后可以访问的域名，我这里为了方便测试，写成 localhost ，如果是为了给网站生成证书，需要写成 xxxx.com 。</p><h4 id="Simple-Golang-HTTPS-TLS-Server"><a href="#Simple-Golang-HTTPS-TLS-Server" class="headerlink" title="Simple Golang HTTPS/TLS Server"></a>Simple Golang HTTPS/TLS Server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// "fmt"</span></span><br><span class="line">    <span class="comment">// "io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"This is an example server.\n"</span>))</span><br><span class="line">    <span class="comment">// fmt.Fprintf(w, "This is an example server.\n")</span></span><br><span class="line">    <span class="comment">// io.WriteString(w, "This is an example server.\n")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</span><br><span class="line">    err := http.ListenAndServeTLS(<span class="string">":443"</span>, <span class="string">"server.crt"</span>, <span class="string">"server.key"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端访问（Android）"><a href="#客户端访问（Android）" class="headerlink" title="客户端访问（Android）"></a>客户端访问（Android）</h3><p>当大家使用Android 中的OkHttp访问一个使用自签名的HTTPS的站点，它会抛出一个<code>SSLHandshakeException</code>的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br><span class="line">    at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:<span class="number">322</span>)</span><br><span class="line">    at com.android.okhttp.Connection.upgradeToTls(Connection.java:<span class="number">201</span>)</span><br><span class="line">    at com.android.okhttp.Connection.connect(Connection.java:<span class="number">155</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpEngine.connect(HttpEngine.java:<span class="number">276</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpEngine.sendRequest(HttpEngine.java:<span class="number">211</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpURLConnectionImpl.execute(HttpURLConnectionImpl.java:<span class="number">382</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">332</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:<span class="number">199</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.DelegatingHttpsURLConnection.getInputStream(DelegatingHttpsURLConnection.java:<span class="number">210</span>)</span><br><span class="line">    at com.android.okhttp.internal.http.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:<span class="number">25</span>)</span><br><span class="line">    at me.longerian.abcandroid.datetimepicker.TestDateTimePickerActivity$<span class="number">1</span>.run(TestDateTimePickerActivity.java:<span class="number">236</span>)</span><br><span class="line">Caused by: java.security.cert.CertificateException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br><span class="line">    at com.android.org.conscrypt.TrustManagerImpl.checkTrusted(TrustManagerImpl.java:<span class="number">318</span>)</span><br><span class="line">    at com.android.org.conscrypt.TrustManagerImpl.checkServerTrusted(TrustManagerImpl.java:<span class="number">219</span>)</span><br><span class="line">    at com.android.org.conscrypt.Platform.checkServerTrusted(Platform.java:<span class="number">114</span>)</span><br><span class="line">    at com.android.org.conscrypt.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:<span class="number">550</span>)</span><br><span class="line">    at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method)</span><br><span class="line">    at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:<span class="number">318</span>)</span><br><span class="line"> ... <span class="number">10</span> more</span><br><span class="line">Caused by: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br><span class="line"> ... <span class="number">16</span> more</span><br></pre></td></tr></table></figure><p>这是因为Android 手机有一套共享证书的机制，如果目标 URL 服务器下发的证书不在已信任的证书列表里，或者该证书是自签名的，不是由权威机构颁发，那么会出异常。我们可以通过自定义的验证机制让证书通过验证。解决方案大家可以移步这里：<a href="http://pingguohe.net/2016/02/26/Android-App-secure-ssl.html" target="_blank" rel="noopener">Android App 安全的HTTPS 通信</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a> - 阮一峰</li><li><a href="https://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/" target="_blank" rel="noopener">HTTPS证书生成原理和部署细节</a></li><li><a href="https://imququ.com/post/optimize-tls-handshake.html" target="_blank" rel="noopener">TLS 握手优化详解</a></li><li><a href="https://www.villainhr.com/page/2016/10/26/TLS%20&amp;%20SSL%20%E5%BF%AB%E9%80%9F%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">TLS &amp; SSL 快速进阶</a></li><li><a href="http://pingguohe.net/2016/02/26/Android-App-secure-ssl.html" target="_blank" rel="noopener">Android App 安全的HTTPS 通信</a></li><li><a href="https://colobu.com/2016/06/07/simple-golang-tls-examples/" target="_blank" rel="noopener">使用Go实现TLS 服务器和客户端</a></li><li><a href="https://gist.github.com/croxton/ebfb5f3ac143cd86542788f972434c96" target="_blank" rel="noopener">Generate ssl certificates with Subject Alt Names on OSX</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;HTTPS与HTTP是什么关系呢？我们可以对比下HTTP与HTTPS的请求过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/common/http-state.png&quot; alt=&quot;HTTP请求过程&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTPS 在 TCP 和 HTTP 之间增加了 TLS（Transport Layer Security，传输层安全），提供了&lt;strong&gt;内容加密&lt;/strong&gt;、&lt;strong&gt;身份认证&lt;/strong&gt;和&lt;strong&gt;数据完整性&lt;/strong&gt;三大功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/common/https-state.png&quot; alt=&quot;HTTPS请求过程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://itimetraveler.github.io/categories/Web/"/>
    
    
      <category term="HTTPS" scheme="https://itimetraveler.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议浅析</title>
    <link href="https://itimetraveler.github.io/2018/10/27/WebSocket%E5%8D%8F%E8%AE%AE%E6%B5%85%E6%9E%90/"/>
    <id>https://itimetraveler.github.io/2018/10/27/WebSocket协议浅析/</id>
    <published>2018-10-27T03:08:00.000Z</published>
    <updated>2018-11-24T09:27:54.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议的缺点"><a href="#HTTP协议的缺点" class="headerlink" title="HTTP协议的缺点"></a>HTTP协议的缺点</h2><p><img src="/gallery/common/http-protocol-drawback.jpg" alt="HTTP协议的缺点"></p><ol><li>单向请求：只能是客户端发起，服务端处理并响应</li><li>请求/响应模式</li><li>无状态协议</li><li>半双工协议</li></ol><p>半双工数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。HTTP协议这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源。WebSocket就可以解决这些问题。</p><a id="more"></a><h2 id="WebSocket是什么"><a href="#WebSocket是什么" class="headerlink" title="WebSocket是什么"></a>WebSocket是什么</h2><p>WebSocket是HTML5新增的协议，目的是在浏览器和服务器间建立一个不受限的<strong>全双工通信</strong>的通道。这就使得浏览器具备了实时双向通信的能力。</p><p><img src="/gallery/common/websocket-model.png" alt=""></p><p>其特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>）。地址比如<code>ws://example.com:80/some/path</code></p><h2 id="协议概览"><a href="#协议概览" class="headerlink" title="协议概览"></a>协议概览</h2><p>协议分为两部分：“握手” 和 “数据传输”。</p><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>握手部分的设计目的就是兼容现有的基于 HTTP 的服务端组件（web 服务器软件）或者中间件（代理服务器软件）。这样一个端口就可以同时接受普通的 HTTP 请求或则 WebSocket 请求了。为了这个目的，WebSocket 客户端的握手是一个 HTTP 升级版的请求（HTTP Upgrade request）。</p><h4 id="客户端：申请协议升级"><a href="#客户端：申请协议升级" class="headerlink" title="客户端：申请协议升级"></a>客户端：申请协议升级</h4><p>所以，WebSocket连接必须由客户端发起，因为握手协议是一个标准的HTTP Upgrade请求。客户端发出的握手信息类似如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>WebSocket的发起握手内容包括了 HTTP 升级请求和一些必选以及可选的头字段。握手的细节如下：</p><ul><li>握手必须是一个有效的 HTTP 请求</li><li>请求的方法必须是 GET，并且 HTTP 的版本必须至少是 1.1</li><li>请求的 Request-URI 部分可使相对路径或者绝对路径</li><li>请求必须有一个 |Host| 头字段，它的值是 host 主机名称加上 port 端口名称（默认端口不必指明）</li><li>请求必须有一个 |Upgrade| 头字段，它的值必须是 websocket 这个关键字</li><li>请求必须有一个 |Connection| 头字段，它的值必须是 Upgrade 这个标记</li><li>请求必须有一个 |Sec-WebSocket-Key| 头字段，它的值是一个噪音值。每个连接的噪音必须不同且随机。</li><li>如果连接来自浏览器客户端，那么 |Origin| 字段就是必须的。如果连接不是来自于一个浏览器客户端，那么这个值就是可选的。这个值表示的是发起连接的代码在运行时所属的源。关于源是由哪些部分组成的，见 <a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc6454" target="_blank" rel="noopener">RFC6454</a>。</li><li>请求必须有一个 |Sec-WebSocket-Version| 头字段，它的值必须是 13</li><li>请求可以有一个可选的头字段 |Sec-WebSocket-Protocol|。如果包含了这个头字段，它的值表示的是客户端希望使用的子协议，按子协议的名称使用逗号分隔。每个以逗号分隔的元素之间必须相互不重复。</li><li>请求可以有一个可选的头字段 |Sec-WebSocket-Extensions|。如果包含了这个字段，它的值表示的是客户端希望使用的协议级别的扩展。</li><li>请求可以包含其他可选的头字段，比如 cookies，或者认证相关的头字段，比如 |Authorization| 。</li></ul><p>重点请求首部意义如下：</p><ul><li><code>Connection: Upgrade</code>：表示要升级协议</li><li><code>Upgrade: websocket</code>：表示要升级到 websocket 协议。</li><li><code>Sec-WebSocket-Version: 13</code>：表示 websocket 的版本。如果服务端不支持该版本，需要返回一个<code>Sec-WebSocket-Version</code> header，里面包含服务端支持的版本号。</li><li><code>Sec-WebSocket-Key</code>：与后面服务端响应首部的<code>Sec-WebSocket-Accept</code>是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</li><li><code>Sec-WebSocket-Protocol</code>: 它可以指出让服务端选择使用哪些协议。客户端需要验证服务端选择的子协议，是否是其当初的握手请求中的 <code>Sec-WebSocket-Protocol</code>中的一个。</li></ul><p>注意，上面的请求示例省略了部分非重点请求首部。由于是标准的 HTTP 请求，类似 Host、Origin、Cookie 等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p><h4 id="服务端：响应协议升级"><a href="#服务端：响应协议升级" class="headerlink" title="服务端：响应协议升级"></a>服务端：响应协议升级</h4><p>服务端回应的握手信息类似如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。任何其他的非 <code>101</code> 表示 WebSocket 握手还没有结束，客户端需要使用原有的 HTTP 的方式去响应那些状态码。到此完成协议升级，后续的数据交互都按照新的协议来。</p><p>客户端的握手请求由 请求行 (Request-Line) 开始。客户端的回应由 状态行 (Status-Line) 开始。首行之后的部分，都是没有顺序要求的 HTTP Headers。其中的一些 HTTP头 的意思稍后将会介绍，不过也可包括例子中没有提及的头信息，比如 Cookies 信息</p><h4 id="Sec-WebSocket-Key-与-Sec-WebSocket-Accept"><a href="#Sec-WebSocket-Key-与-Sec-WebSocket-Accept" class="headerlink" title="Sec-WebSocket-Key 与 Sec-WebSocket-Accept"></a>Sec-WebSocket-Key 与 Sec-WebSocket-Accept</h4><p>服务端为了告知客户端它已经接收到了客户端的握手请求，服务端需要返回一个包含<code>Sec-WebSocket-Accept</code>的握手响应。这个值的信息来自于客户端的握手请求中的 <code>Sec-WebSocket-Key</code> 头字段：</p><ul><li>客户端握手中的 Sec-WebSocket-Key 头字段的值是采用 base64 编码的16字节随机数。</li><li>服务端需将该值和固定的 GUID 字符串（ 258EAFA5-E914-47DA-95CA-C5AB0DC85B11）拼接后使用 SHA-1 进行哈希，并采用 base64 编码后，作为响应握手的 |Sec-WebSocket-Accept| 值返回。</li><li>客户端也必须按照服务端生成 |Sec-WebSocket-Accept| 的方式生成字符串，与服务端回传的进行对比，如果不同就标记连接为失败。</li></ul><p>也就是说，服务端返回的 Header 字段 <code>Sec-WebSocket-Accept</code> 是根据客户端请求 Header 中的<code>Sec-WebSocket-Key</code>计算出来。 </p><p>计算公式为：</p><ol><li>将<code>Sec-WebSocket-Key</code>跟该固定字符串<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接。</li><li>通过 SHA1 计算出摘要，并转成 base64 字符串。</li></ol><p><code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code>在主要作用在于提供基础的防护，减少恶意连接、意外连接。作用大致归纳如下：</p><ol><li>避免服务端收到非法的 websocket 连接（比如 http 客户端不小心请求连接 websocket 服务，此时服务端可以直接拒绝连接）</li><li>确保服务端理解 websocket 连接。因为 ws 握手阶段采用的是 http 协议，因此可能 ws 连接是被一个 http 服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识 ws 协议。（并非百分百保险，比如总是存在那么些无聊的 http 服务器，光处理 Sec-WebSocket-Key，但并没有实现 ws 协议。。。）</li><li>用浏览器里发起 ajax 请求，设置 header 时，Sec-WebSocket-Key 以及其他相关的 header 是被禁止的。这样可以避免客户端发送 ajax 请求时，意外请求协议升级（websocket upgrade）</li><li>可以防止反向代理（不理解 ws 协议）返回错误的数据。比如反向代理前后收到两次 ws 连接的升级请求，反向代理把第一次请求的返回给 cache 住，然后第二次请求到来时直接把 cache 住的请求给返回（无意义的返回）。</li><li>Sec-WebSocket-Key 主要目的并不是确保数据的安全性，因为 Sec-WebSocket-Key、Sec-WebSocket-Accept 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li></ol><p>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端 / 服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。</p><h3 id="数据帧协议"><a href="#数据帧协议" class="headerlink" title="数据帧协议"></a>数据帧协议</h3><p>握手完成之后，双方传输数据的协议格式如下：</p><p><img src="/gallery/common/websocket-protocol-form.png" alt=""></p><ul><li><p><strong>FIN</strong>:  1 bit</p><p>标记这个帧是不是消息中的最后一帧。第一个帧也可是最后一帧。</p></li><li><p><strong>RSV1, RSV2, RSV3</strong>:  1 bit each</p><p>必须是0，除非有扩展赋予了这些位非0值的意义。</p></li><li><p><strong>Opcode</strong>:  4 bits</p><p>定义了如何解释 “有效负荷数据 Payload data”。如果接收到一个未知的操作码，接收端必须标记 WebSocket 为失败。定义了如下的操作码：</p><ul><li><code>%x0</code>     表示这是一个继续帧（continuation frame）</li><li><code>%x1</code>      表示这是一个文本帧 （text frame）</li><li><code>%x2</code>      表示这是一个二进制帧 （binary frame）</li><li><code>%x3-7</code>    为将来的非控制帧（non-control frame）而保留的</li><li><code>%x8</code>      表示这是一个连接关闭帧 （connection close）</li><li><code>%x9</code>      表示这是一个 ping 帧</li><li><code>%xA</code>      表示这是一个 pong 帧</li><li><code>%xB-F</code>    为将来的控制帧（control frame）而保留的</li></ul></li><li><p><strong>Mask</strong>:  1 bit</p><p>表示是否要对数据载荷进行掩码操作。所有的由客户端发往服务端的帧都必须设置为 1。如果被设置为 1，那么在 Masking-Key 部分将有一个掩码key，服务端需要使用它将 “有效载荷数据” 进行反掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。<br>​<br>如果 Mask 是 1，那么在 Masking-key 中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1。</p></li><li><p><strong>Payload length</strong>:  7 bits, 7+16 bits, or 7+64 bits</p><ul><li>如果是 0-125，那么就直接表示了负荷长度。</li><li>如果是 126，那么接下来的两个字节表示(16位)负荷长度。</li><li>如果是 127，则接下来的 8 个字节表示(64位)负荷长度。</li></ul></li><li><p><strong>Masking-Key</strong>:  1 bit</p><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。</p></li></ul><h4 id="客户端到服务端掩码"><a href="#客户端到服务端掩码" class="headerlink" title="客户端到服务端掩码"></a>客户端到服务端掩码</h4><p>掩码键（Masking-key）是由客户端挑选出来的 32 位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p><p>首先，假设：</p><ul><li><code>original-octet-i</code>：为原始数据的第 i 字节。</li><li><code>transformed-octet-i</code>：为转换后的数据的第 i 字节。</li><li><code>j</code>：为<code>i mod 4</code>的结果。</li><li><code>masking-key-octet-j</code>：为 mask key 第 j 字节。</li></ul><p>则生成方式是通过原始数据的第 i 字节 （original-octet-i）与Masking-Key中的第 j 个字节 （masking-key-octet-j） 进行异或（XOR）操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = i MOD <span class="number">4</span></span><br><span class="line">transformed-octet-i = original-octet-i XOR masking-key-octet-j</span><br></pre></td></tr></table></figure><p>在WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p><p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p><p>答案还是两个字：<strong>安全</strong>。但并不是为了防止数据泄密，而是<strong>为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）</strong>等问题。关于代理缓存污染攻击的原理可以参考<a href="http://www.infoq.com/cn/articles/deep-in-websocket-protocol" target="_blank" rel="noopener">WebSocket协议深入探究</a>。</p><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><p>数据分片的目的就是允许发送那些在发送时不知道其缓冲的长度的消息。如果消息不能被碎片化，那么一端就必须将消息整个地载入内存缓冲，这样在发送消息前才可以计算出消息的字节长度。有了碎片化的机制，服务端或者中间件就可以选取其适用的内存缓冲长度，然后当缓冲满了之后就发送一个消息碎片。</p><p>碎片机制带来的另一个好处就是可以方便实现多路复用。没有多路复用的话，就需要将一整个大的消息放在一个逻辑通道中发送，这样会占用整个输出通道。多路复用需要可以将消息分割成小的碎片，使这些小的碎片可以共享输出通道。（注意多路复用的扩展在这片文档中并没有进行描述）</p><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据<code>FIN</code>的值来判断，是否已经收到消息的最后一个数据帧。</p><p>FIN=1 表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0 则接收方还需要继续监听接收其余的数据帧。</p><p>此外，<code>opcode</code>在数据交换的场景下，表示的是数据的类型。<code>0x01</code>表示文本，<code>0x02</code>表示二进制。而<code>0x00</code>比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。下面的例子演示了碎片化是如何工作的。</p><p><strong>例子：第一条消息</strong></p><blockquote><p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p></blockquote><p><strong>例子：第二条消息</strong></p><blockquote><ol><li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li><li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li><li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li></ol></blockquote><h4 id="连接保持-心跳"><a href="#连接保持-心跳" class="headerlink" title="连接保持 + 心跳"></a>连接保持 + 心跳</h4><p>WebSocket协议为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p><p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用WebSocket数据帧的心跳字段来实现。</p><ul><li>发送方 -&gt; 接收方：ping</li><li>接收方 -&gt; 发送方：pong</li></ul><p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，<code>Opcode</code>分别是<code>0x9</code>、<code>0xA</code>。</p><h2 id="WebSocket与TCP、HTTP的关系"><a href="#WebSocket与TCP、HTTP的关系" class="headerlink" title="WebSocket与TCP、HTTP的关系"></a>WebSocket与TCP、HTTP的关系</h2><p>WebSocket 协议的设计理念就是提供极小的帧结构（帧结构存在的目的就是使得协议是基于帧的，而不是基于流的，同时帧可以区分 Unicode 文本和二进制的数据）。它期望可以在应用层中使得元数据可以被放置到 WebSocket 层上，也就是说，给应用层提供一个将数据直接放在 TCP 层上的机会，再简单的说就可以给浏览器脚本提供一个使用受限的 Raw TCP 的机会。</p><p>从概念上来说，WebSocket 只是一个建立于 TCP 之上的层，它提供了下面的功能：</p><ul><li>给浏览器提供了一个基于源的安全模型（origin-based security model）</li><li>给协议提供了一个选址的机制，使得在同一个端口上可以创立多个服务，并且将多个域名关联到同一个 IP</li><li>在 TCP 层之上提供了一个类似 TCP 中的帧的机制，但是没有长度的限制</li><li>提供了关闭握手的方式，以适应存在中间件的情况</li></ul><p>从概念上将，就只有上述的几个用处。不过 WebSocket 可以很好的和 HTTP 协议一同协作，并且可以充分的利用现有的 web 基础设施，比如代理。WebSocket 的目的就是让简单的事情变得更加的简单。</p><p>协议被设计成可扩展的，将来的版本中将很可能会添加关于多路复用的概念。（也就是说<strong>目前的WebSocket协议还未支持多路复用</strong>）</p><p>WebSocket 是一个独立的基于 TCP 的协议，它与 HTTP 之间的唯一关系就是它的握手请求可以作为一个升级请求（Upgrade request）经由 HTTP 服务器解释（也就是可以使用 Nginx 反向代理一个 WebSocket）。</p><p>默认情况下，WebSocket 协议使用 80 端口作为一般请求的端口，端口 443 作为基于传输加密层连接（TLS）的端口。</p><h2 id="WebSocket协议缺点"><a href="#WebSocket协议缺点" class="headerlink" title="WebSocket协议缺点"></a>WebSocket协议缺点</h2><ol><li>WebSocket协议很容易发生队首阻塞的情况（IM等APP使用UDP协议而不是TCP？）</li><li>WebSocket协议不支持多路复用（但支持扩展）</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">WebSocket协议原文：RFC6455</a></li><li><a href="https://www.jianshu.com/p/867274a5e054" target="_blank" rel="noopener">WebSocket 协议 1~4 节</a></li><li><a href="http://www.infoq.com/cn/articles/deep-in-websocket-protocol" target="_blank" rel="noopener">WebSocket协议深入探究</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程 - 阮一峰</a></li><li><a href="https://github.com/gorilla/websocket" target="_blank" rel="noopener">Golang实现：gorilla/websocket</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP协议的缺点&quot;&gt;&lt;a href=&quot;#HTTP协议的缺点&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议的缺点&quot;&gt;&lt;/a&gt;HTTP协议的缺点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/gallery/common/http-protocol-drawback.jpg&quot; alt=&quot;HTTP协议的缺点&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单向请求：只能是客户端发起，服务端处理并响应&lt;/li&gt;
&lt;li&gt;请求/响应模式&lt;/li&gt;
&lt;li&gt;无状态协议&lt;/li&gt;
&lt;li&gt;半双工协议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;半双工数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。HTTP协议这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源。WebSocket就可以解决这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://itimetraveler.github.io/categories/Web/"/>
    
    
      <category term="WebSocket" scheme="https://itimetraveler.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache与缓存行</title>
    <link href="https://itimetraveler.github.io/2018/09/09/CPU%20Cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C/"/>
    <id>https://itimetraveler.github.io/2018/09/09/CPU Cache与缓存行/</id>
    <published>2018-09-09T14:20:55.000Z</published>
    <updated>2018-09-14T08:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下面这两个循环遍历哪个快？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span> * <span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横向遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span> * <span class="number">1024</span>; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j ++)</span><br><span class="line">        array[i][j] ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纵向遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span> * <span class="number">1024</span>; j ++)</span><br><span class="line">        array[j][i] ++;</span><br></pre></td></tr></table></figure><p>在CPU处理器参数为 2.3 GHz Intel Core i5 的Mac上的结果是：</p><blockquote><p>横向遍历:    80ms<br>纵向遍历:    2139ms</p></blockquote><p>横向遍历的 CPU cache 命中率高，所以它比纵向遍历约快这么多倍！</p><p><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a> 用 7 个源码示例生动的介绍 cache 原理，深入浅出！但是可能因操作系统的差异、编译器是否优化，以及近些年 cache 性能的提升，有些样例在 Mac 的效果与原文相差较大。</p><a id="more"></a><h2 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h2><p>CPU 访问内存时，首先查询 cache 是否已缓存该数据。如果有，则返回数据，无需访问内存；如果不存在，则需把数据从内存中载入 cache，最后返回给理器。在处理器看来，缓存是一个透明部件，旨在提高处理器访问内存的速率，所以从逻辑的角度而言，编程时无需关注它，但是从性能的角度而言，理解其原理和机制有助于写出性能更好的程序。Cache 之所以有效，是因为程序对内存的访问存在一种概率上的局部特征：</p><ul><li>Spatial Locality：对于刚被访问的数据，其相邻的数据在将来被访问的概率高。</li><li>Temporal Locality：对于刚被访问的数据，其本身在将来被访问的概率高。</li></ul><p>比 mac OS 为例，可用 命令 <code>sysctl -a</code> 查询 cache 信息，单位是字节Byte。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a</span><br><span class="line"></span><br><span class="line">hw.cachelinesize: <span class="number">64</span></span><br><span class="line">hw.l1icachesize: <span class="number">32768</span></span><br><span class="line">hw.l1dcachesize: <span class="number">32768</span></span><br><span class="line">hw.l2cachesize: <span class="number">262144</span></span><br><span class="line">hw.l3cachesize: <span class="number">4194304</span></span><br><span class="line">machdep.cpu.cache.L2_associativity: <span class="number">4</span></span><br><span class="line">machdep.cpu.core_count: <span class="number">2</span></span><br><span class="line">machdep.cpu.thread_count: <span class="number">4</span></span><br><span class="line">machdep.cpu.tlb.inst.large: <span class="number">8</span></span><br><span class="line">machdep.cpu.tlb.data.small: <span class="number">64</span></span><br><span class="line">machdep.cpu.tlb.data.small_level1: <span class="number">64</span></span><br></pre></td></tr></table></figure><ul><li>CacheLine size：64 Byte</li><li>L1 Data Cache：32KB</li><li>L1 Instruction Cache：32KB</li><li>L2 Cache：256KB</li><li>L3 Cache：4MB</li></ul><p>Mac下也可以点击坐上角关于本机 -&gt; 概览 -&gt; 系统报告来查看硬件信息：</p><p><img src="/gallery/java-common/mac-hw-info.png" alt=""></p><p>下图是计算机存储的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存。越靠近CPU的缓存，速度越快，容量也越小。L1缓存小但很快，并且紧靠着在使用它的CPU内核。分为指令缓存和数据缓存；L2大一些，也慢一些，并仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。</p><p><img src="/gallery/java-common/mac_cpu_cache_info.png" alt="计算机CPU与缓存示意图"></p><p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以要尽量确保数据在L1缓存中。</p><p>Martin和Mike的 <a href="http://www.infoq.com/presentations/LMAX" target="_blank" rel="noopener">QCon presentation</a> 演讲中给出了一些缓存未命中的消耗数据，也就是从CPU访问不同层级数据的时间概念:</p><table><thead><tr><th>从CPU到</th><th>大约需要的CPU时钟周期</th><th>大约需要的时间</th></tr></thead><tbody><tr><td>主存</td><td></td><td>约60-80ns</td></tr><tr><td>QPI 总线传输(between sockets, not drawn)</td><td></td><td>约20ns</td></tr><tr><td>L3 cache</td><td>约40-45 cycles</td><td>约15ns</td></tr><tr><td>L2 cache</td><td>约10 cycles</td><td>约3ns</td></tr><tr><td>L1 cache</td><td>约3-4 cycles</td><td>约1ns</td></tr><tr><td>寄存器</td><td>1 cycle</td></tr></tbody></table><p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。</p><p>我们在每隔 64 Byte (cache line size) 访问 array 一次，访问固定次数。随着array的增大，看看能不能测试出 L1, L2 和 L3 cache size 的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每隔64Byte访问数组固定次数，看Array大小对耗时的影响</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ARRAY_SIZE = <span class="number">512</span>; ARRAY_SIZE &lt;= <span class="number">128</span> * <span class="number">1024</span> * <span class="number">1024</span>; ARRAY_SIZE &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> steps = <span class="number">640</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Arbitrary number of steps</span></span><br><span class="line">            <span class="keyword">int</span> length_mod = ARRAY_SIZE - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">            marked = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps; i += <span class="number">64</span>) &#123;</span><br><span class="line">                arr[i &amp; length_mod]++; <span class="comment">// (i &amp; length_mod) is equal to (i % length_mod)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> used = (System.currentTimeMillis() - marked);</span><br><span class="line">            System.out.println(formatSize(ARRAY_SIZE) + <span class="string">"\t"</span> + used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把size单位转化为KB, MB, GB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatSize</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        String hrSize = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> b = size;</span><br><span class="line">        <span class="keyword">double</span> k = size/<span class="number">1024.0</span>;</span><br><span class="line">        <span class="keyword">double</span> m = ((size/<span class="number">1024.0</span>)/<span class="number">1024.0</span>);</span><br><span class="line">        <span class="keyword">double</span> g = (((size/<span class="number">1024.0</span>)/<span class="number">1024.0</span>)/<span class="number">1024.0</span>);</span><br><span class="line">        <span class="keyword">double</span> t = ((((size/<span class="number">1024.0</span>)/<span class="number">1024.0</span>)/<span class="number">1024.0</span>)/<span class="number">1024.0</span>);</span><br><span class="line"></span><br><span class="line">        DecimalFormat dec = <span class="keyword">new</span> DecimalFormat(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( t&gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            hrSize = dec.format(t).concat(<span class="string">" TB"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( g&gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            hrSize = dec.format(g).concat(<span class="string">" GB"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( m&gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            hrSize = dec.format(m).concat(<span class="string">" MB"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( k&gt;<span class="number">1</span> ) &#123;</span><br><span class="line">            hrSize = dec.format(k).concat(<span class="string">" KB"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hrSize = dec.format(b).concat(<span class="string">" Bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hrSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果如下：</p><p><img src="/gallery/java-common/array-access-demo.png" alt="每隔64Byte访问数组固定次数，看Array大小对耗时的影响"></p><p>可以看到32KB，256KB，4MB之后耗时均有明显上升。</p><h2 id="缓存行Cache-Line"><a href="#缓存行Cache-Line" class="headerlink" title="缓存行Cache Line"></a>缓存行Cache Line</h2><p>Cache是由很多个 Cache line 组成的。Cache line 是 cache 和 RAM 交换数据的最小单位，通常为 64 Byte。当 CPU 把内存的数据载入 cache 时，会把临近的共 64 Byte 的数据一同放入同一个Cache line，因为空间局部性：临近的数据在将来被访问的可能性大。</p><p>以大小为 32 KB，cache line 的大小为 64 Byte 的L1级缓存为例，对于不同存放规则，其硬件设计也不同，下图简单表示一种设计：</p><p><img src="/gallery/java-common/cpu_cache_direct_mapping.png" alt=""></p><h3 id="伪共享False-Sharing"><a href="#伪共享False-Sharing" class="headerlink" title="伪共享False Sharing"></a>伪共享False Sharing</h3><p>当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p><p><img src="/gallery/java-common/20161111081903485.png" alt=""></p><p>下面我们通过一段代码，看看伪共享对性能的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharingNo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValuePadding[] longs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharingNo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(i + <span class="string">" Threads, duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValuePadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValuePadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharingNo(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分别使用 ValuePadding  和 ValueNoPadding 两种对象，让多线程分别访问数组中相邻的对象，试图构建一个伪共享的场景。在有Padding填充的情况下，看看运行结果：</p><blockquote><p>1 Threads, duration = 398<br>2 Threads, duration = 645<br>3 Threads, duration = 537<br>4 Threads, duration = 638<br>5 Threads, duration = 786<br>6 Threads, duration = 954<br>7 Threads, duration = 1133<br>8 Threads, duration = 1286<br>9 Threads, duration = 1432</p></blockquote><p>把代码中 ValuePadding 都替换为 ValueNoPadding 后的结果：</p><blockquote><p>1 Threads, duration = 404<br>2 Threads, duration = 1250<br>3 Threads, duration = 1283<br>4 Threads, duration = 1179<br>5 Threads, duration = 2510<br>6 Threads, duration = 2733<br>7 Threads, duration = 2451<br>8 Threads, duration = 2652<br>9 Threads, duration = 2189</p></blockquote><h3 id="Cache-Line伪共享解决方案"><a href="#Cache-Line伪共享解决方案" class="headerlink" title="Cache Line伪共享解决方案"></a>Cache Line伪共享解决方案</h3><p>处理伪共享的两种方式：</p><ol><li>字节填充：增大元素的间隔，使得不同线程存取的元素位于不同的cache line上，典型的空间换时间。</li><li>在每个线程中创建对应元素的本地拷贝，结束后再写回全局数组。</li></ol><p>我们这里只看第一种字节填充。保证不同线程的变量存在于不同的 CacheLine 即可，这样就不会出现伪共享问题。在代码层面如何实现图中的字节填充呢？</p><h4 id="Java6-中实现字节填充"><a href="#Java6-中实现字节填充" class="headerlink" title="Java6 中实现字节填充"></a><strong>Java6 中实现字节填充</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;    <span class="comment">// 实际数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PaddingObject 类中需要保存一个 long 类型的 value 值，如果多线程操作同一个 CacheLine 中的 PaddingObject 对象，便无法完全发挥出 CPU Cache 的优势（想象一下你定义了一个 PaddingObject[] 数组，数组元素在内存中连续，却由于伪共享导致无法使用 CPU Cache 带来的沮丧）。</p><p>不知道你注意到没有，实际数据 value + 用于填充的 p1~p6 总共只占据了 7 * 8 = 56 个字节，而 Cache Line 的大小应当是 64 字节，这是有意而为之，在 Java 中，<strong>对象头还占据了 8 个字节</strong>，所以一个 PaddingObject 对象可以恰好占据一个 Cache Line。</p><h4 id="Java7-中实现字节填充"><a href="#Java7-中实现字节填充" class="headerlink" title="Java7 中实现字节填充"></a><strong>Java7 中实现字节填充</strong></h4><p>在 Java7 之后，一个 JVM 的优化给字节填充造成了一些影响，上面的代码片段 <code>public long p1, p2, p3, p4, p5, p6;</code> 会被认为是无效代码被优化掉，有回归到了伪共享的窘境之中。</p><p>为了避免 JVM 的自动优化，需要使用继承的方式来填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;<span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span> <span class="keyword">extends</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;    <span class="comment">// 实际数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:实际上我在本地 mac 下测试过 jdk1.8 下的字节填充，并不会出现无效代码的优化，个人猜测和 jdk 版本有关，不过为了保险起见，还是使用相对稳妥的方式去填充较为合适。</p></blockquote><h4 id="Java8-中实现字节填充"><a href="#Java8-中实现字节填充" class="headerlink" title="Java8 中实现字节填充"></a><strong>Java8 中实现字节填充</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 8中提供的注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The (optional) contention group tag.</span></span><br><span class="line"><span class="comment">     * This tag is only meaningful for field level annotations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> contention group tag.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK 8 里提供了一个新注解<code>@Contended</code>，可以用来减少false sharing的情况。JVM在计算对象布局的时候就会自动把标注的字段拿出来并且插入合适的大小padding。</p><p>因为这个功能暂时还是实验性功能，暂时还没到默认普及给用户代码用的程度。要在用户代码（非bootstrap class loader或extension class loader所加载的类）中使用@Contended注解的话，需要使用 -XX:-RestrictContended 参数。</p><p>比如在JDK 8的 <strong>ConcurrentHashMap</strong> 源码中，使用 <a href="mailto:`@sun.misc.Contended" target="_blank" rel="noopener">`@sun.misc.Contended</a>`对静态内部类 CounterCell 进行了修饰。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread</strong></p><p>Thread 线程类的源码中，使用 @sun.misc.Contended 对成员变量进行修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure><p><strong>RingBuffer</strong></p><p>来源于一款优秀的开源框架 Disruptor 中的一个数据结构 <strong>RingBuffer</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferFields</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">RingBufferPad</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用字节填充和继承的方式来避免伪共享。</p><h3 id="面试题扩展"><a href="#面试题扩展" class="headerlink" title="面试题扩展"></a>面试题扩展</h3><p>问：说说数组和链表这两种数据结构有什么区别？</p><p>问：快速排序和堆排序两种排序算法各自的优缺点是什么？</p><p>了解了 CPU Cache 和 Cache Line 之后想想可不可以有一些特殊的回答技巧呢？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a>：<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a></li><li><a href="http://wsfdl.com/linux/2016/06/11/%E7%90%86%E8%A7%A3CPU%E7%9A%84cache.html" target="_blank" rel="noopener">理解 CPU Cache</a></li><li><a href="https://tech.meituan.com/disruptor.html" target="_blank" rel="noopener">高性能队列——Disruptor</a> — 美团点评技术团队</li><li><a href="https://cloud.tencent.com/developer/article/1164096" target="_blank" rel="noopener">JAVA 拾遗 — CPU Cache 与缓存行</a></li><li><a href="https://www.cnblogs.com/techyc/p/3607085.html" target="_blank" rel="noopener">写Java也得了解CPU–CPU缓存</a></li><li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li><li><a href="https://blog.csdn.net/karamos/article/details/80126704" target="_blank" rel="noopener"> Java专家系列：CPU Cache与高性能编程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;先看下面这两个循环遍历哪个快？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] array = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 横向遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;; i ++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;; j ++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array[i][j] ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 纵向遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;; i ++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;; j ++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array[j][i] ++;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在CPU处理器参数为 2.3 GHz Intel Core i5 的Mac上的结果是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;横向遍历:    80ms&lt;br&gt;纵向遍历:    2139ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;横向遍历的 CPU cache 命中率高，所以它比纵向遍历约快这么多倍！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://igoro.com/archive/gallery-of-processor-cache-effects/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gallery of Processor Cache Effects&lt;/a&gt; 用 7 个源码示例生动的介绍 cache 原理，深入浅出！但是可能因操作系统的差异、编译器是否优化，以及近些年 cache 性能的提升，有些样例在 Mac 的效果与原文相差较大。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】J.U.C并发包 - AQS机制</title>
    <link href="https://itimetraveler.github.io/2018/07/19/%E3%80%90Java%E3%80%91J.U.C%E5%B9%B6%E5%8F%91%E5%8C%85%20-%20AQS%E6%9C%BA%E5%88%B6/"/>
    <id>https://itimetraveler.github.io/2018/07/19/【Java】J.U.C并发包 - AQS机制/</id>
    <published>2018-07-19T14:20:55.000Z</published>
    <updated>2018-08-04T03:59:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java并发包（java.util.concurrent）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrantLock、Semaphore，CountDownLatch，CyclicBarrier，它们的实现都用到了一个共同的基类 - <strong>AbstractQueuedSynchronizer</strong>，简称AQS。AQS提供了一种原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>同步器背后的基本思想非常简单，可以参考AQS作者 Doug Lea 的论文：<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a>。同步器一般包含两种方法，一种是acquire，另一种是release。</p><ul><li>acquire操作阻塞调用的线程，直到同步状态允许其继续执行。</li><li>release操作则是改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</li></ul><p>其中acquire操作伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (synchronization state does not allow acquire) &#123;</span><br><span class="line">enqueue current thread <span class="keyword">if</span> not already queued;</span><br><span class="line">possibly block current thread;</span><br><span class="line">&#125;</span><br><span class="line">dequeue current thread <span class="keyword">if</span> it was queued;</span><br></pre></td></tr></table></figure><p>release操作伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update synchronization state;</span><br><span class="line"><span class="keyword">if</span> (state may permit a blocked thread to acquire)</span><br><span class="line">unblock one or more queued threads;</span><br></pre></td></tr></table></figure><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理；</li><li>线程的阻塞与解除阻塞；</li><li>队列的管理；</li></ul><p>AQS框架借助于两个类：<strong>Unsafe</strong>(提供CAS操作) 和 <strong>LockSupport</strong>(提供park/unpark操作)。</p><h2 id="1-同步状态的原子性管理"><a href="#1-同步状态的原子性管理" class="headerlink" title="1. 同步状态的原子性管理"></a>1. 同步状态的原子性管理</h2><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。该整数可以表现任何状态。比如， <code>Semaphore</code> 用它来表现剩余的许可数，<code>ReentrantLock</code> 用它来表现拥有它的线程已经请求了多少次锁；<code>FutureTask</code> 用它来表现任务的状态(尚未开始、运行、完成和取消)。</p><p>如JDK的文档中所说，使用AQS来实现一个同步器需要覆盖实现如下几个方法，并且使用<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>这几个方法来设置或者获取状态。</p><ul><li><p><code>boolean tryAcquire(int arg)</code> </p></li><li><p><code>boolean tryRelease(int arg)</code> </p></li><li><p><code>int tryAcquireShared(int arg)</code> </p></li><li><p><code>boolean tryReleaseShared(int arg)</code> </p></li><li><code>boolean isHeldExclusively()</code></li></ul><p>以上方法不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，支持独占(排他)获取锁的同步器应该实现<code>tryAcquire</code>、 <code>tryRelease</code>、<code>isHeldExclusively</code>而支持共享获取的同步器应该实现<code>tryAcquireShared</code>、<code>tryReleaseShared</code>、<code>isHeldExclusively</code>。下面以 <code>CountDownLatch</code> 举例说明基于AQS实现同步器, <code>CountDownLatch</code> 用同步状态持有当前计数，<code>countDown</code>方法调用 release从而导致计数器递减；当计数器为0时，解除所有线程的等待；<code>await</code>调用acquire，如果计数器为0，<code>acquire</code> 会立即返回，否则阻塞。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework - AQS框架作者Doug Lea的论文</a></li><li><a href="http://ifeve.com/aqs-2/" target="_blank" rel="noopener">The j.u.c Synchronizer Framework翻译(二)设计与实现</a></li><li><a href="https://blog.csdn.net/vernonzheng/article/details/8288251" target="_blank" rel="noopener">Java多线程（九）之ReentrantLock与Condition</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Java并发包（java.util.concurrent）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrantL
      
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】动态链接库so的加载原理</title>
    <link href="https://itimetraveler.github.io/2018/07/03/%E3%80%90Android%E3%80%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93so%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <id>https://itimetraveler.github.io/2018/07/03/【Android】动态链接库so的加载原理/</id>
    <published>2018-07-03T03:51:55.000Z</published>
    <updated>2018-07-04T06:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开发的组件时常出现了运行时加载so库失败问题，每天都会有<code>java.lang.UnsatisfiedLinkError</code>的错误爆出来，而且线上总是偶然复现，很疑惑。所以本文将从AOSP源码简单跟踪Android中的动态链接库so的加载原理，试图找出一丝线索。</p><h2 id="加载入口"><a href="#加载入口" class="headerlink" title="加载入口"></a>加载入口</h2><p>首先我们知道在Android(Java)中加载一个动态链接库非常简单。就是我们日常调用的 <code>System.load(Sring filename)</code> 或者<code>System.loadLibrary(String libname)</code>开始。 看过<a href="http://47.98.205.211/2017/05/17/jni/" target="_blank" rel="noopener">《理解JNI技术》</a>的应该知道上述代码执行过程中会调用native层的<code>JNI_OnLoad()</code>方法，一般用于动态注册native方法。</p><h2 id="System-loadLibrary"><a href="#System-loadLibrary" class="headerlink" title="# System.loadLibrary"></a># System.loadLibrary</h2><p>[System.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处<code>VMStack.getCallingClassLoader()</code>拿到的是调用者的ClassLoader，一般情况下是<strong>PathClassLoader</strong>。我们进入Runtime类的<code>loadLibrary0()</code>方法看看。</p><p>[Runtime.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(ClassLoader loader, String libname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (libname.indexOf((<span class="keyword">int</span>)File.separatorChar) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Directory separator should not appear in library name: "</span> + libname);</span><br><span class="line">    &#125;</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    <span class="comment">// 1. 如果classloder存在，通过loader.findLibrary()查找到so路径</span></span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">            <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">            <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">            <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                           System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果classloder不存在，通过loader.findLibrary()查找到so路径</span></span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    String lastError = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String directory : getLibPaths()) &#123;<span class="comment">// getLibPaths()代码在最下方</span></span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 都没找到，抛出 UnsatisfiedLinkError 异常</span></span><br><span class="line">    <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里根据ClassLoader是否存在分了两种情况：</p><ul><li>当ClasssLoader存在的时候通过loader的 <code>findLibrary()</code>查看目标库所在路径；</li><li>当ClassLoader不存在的时候通过<code>getLibPaths()</code>查找加载路径。</li><li>最终他们都会调用<code>doLoad()</code>加载动态库。</li></ul><p>我们下面分别看下这三个步骤。</p><h3 id="ClasssLoader存在时"><a href="#ClasssLoader存在时" class="headerlink" title="ClasssLoader存在时"></a>ClasssLoader存在时</h3><p>前面知道了这个ClassLoader其实是PathClassLoader，但是<code>findLibrary</code>位于PathClassLoader的父类<strong>BaseDexClassLoader</strong>中：</p><p>[BaseDexClassLoader.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>pathList</code>的类型为DexPathList，我们看看它的<code>findLibrary()</code>方法：</p><p>[DexPathList.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，就是在<code>nativeLibraryPathElements</code> 变量中遍历查找对应的so文件。那么这个<code>nativeLibraryPathElements</code>变量从何而来呢？可以很快查到是在DexPathList的构造方法中赋值的，它的构造方法如下：</p><p>[DexPathList.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">        String librarySearchPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definingContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"definingContext == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"dexPath == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory doesn't exist: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory not readable/writable: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">    <span class="comment">// save dexPath for BaseDexClassLoader</span></span><br><span class="line">    <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions, definingContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">    <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   1. This class loader's library path for application libraries (librarySearchPath):</span></span><br><span class="line">    <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">    <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">    <span class="comment">//   2. The VM's library path from the system property for system libraries</span></span><br><span class="line">    <span class="comment">//      also known as java.library.path</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">            splitPaths(System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">    List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">    allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里赋值</span></span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>nativeLibraryPathElements</code>收集了apk的so目录，一般位于：<code>/data/app/${package-name}/lib/arm/</code> 还有系统的so目录：System.getProperty(“java.library.path”)，可以打印看一下它的值：<code>/vendor/lib:/system/lib</code>，其实就是前后两个目录，事实上64位系统是<code>/vendor/lib64:/system/lib64</code>。 最终查找so文件的时候就会在这三个路径中查找，优先查找apk目录。</p><p>可以看到，PathClassLoader中传入了apk的so目录，然后我们来看没有ClassLoader的情况。</p><h3 id="ClassLoader不存在"><a href="#ClassLoader不存在" class="headerlink" title="ClassLoader不存在"></a>ClassLoader不存在</h3><p>当ClassLoader不存在时，通过<code>getLibPaths()</code>查找加载路径。</p><p>[Runtime.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回mLibPaths</span></span><br><span class="line"><span class="keyword">private</span> String[] getLibPaths() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLibPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLibPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mLibPaths = initLibPaths();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLibPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是环境变量 java.library.path 中的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] initLibPaths() &#123;</span><br><span class="line">    String javaLibraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">    <span class="keyword">if</span> (javaLibraryPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyArray.STRING;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] paths = javaLibraryPath.split(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">// Add a '/' to the end of each directory so we don't have to do it every time.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!paths[i].endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            paths[i] += <span class="string">"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实很简单，返回的结果就是拆分环境变量 java.library.path 中的路径。</p><p>也就是说，ClassLoader为空时使用系统目录，否则使用ClassLoader提供的目录，ClassLoader提供的目录中包括apk目录和系统目录。在这两步各自得到路径之后，最后我们来看看so文件是如何加载的。</p><h3 id="doLoad"><a href="#doLoad" class="headerlink" title="# doLoad()"></a># doLoad()</h3><p>[Runtime.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH,</span></span><br><span class="line">    <span class="comment">// which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load</span></span><br><span class="line">    <span class="comment">// libraries with no dependencies just fine, but an app that has multiple libraries that</span></span><br><span class="line">    <span class="comment">// depend on each other needed to load them in most-dependent-first order.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We added API to Android's dynamic linker so we can update the library path used for</span></span><br><span class="line">    <span class="comment">// the currently-running process. We pull the desired path out of the ClassLoader here</span></span><br><span class="line">    <span class="comment">// and pass it to nativeLoad so that it can call the private dynamic linker API.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the</span></span><br><span class="line">    <span class="comment">// beginning because multiple apks can run in the same process and third party code can</span></span><br><span class="line">    <span class="comment">// use its own BaseDexClassLoader.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any</span></span><br><span class="line">    <span class="comment">// dlopen(3) calls made from a .so's JNI_OnLoad to work too.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// So, find out what the native library search path is for the ClassLoader in question...</span></span><br><span class="line">    String librarySearchPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        librarySearchPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless</span></span><br><span class="line">    <span class="comment">// of how many ClassLoaders are in the system, but dalvik doesn't support synchronized</span></span><br><span class="line">    <span class="comment">// internal natives.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String librarySearchPath)</span></span>;</span><br></pre></td></tr></table></figure><p>这里最后调用了native方法<code>nativeLoad()</code>的代码：</p><p>[libcore/ojluni/src/main/native/Runtime.c]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,</span><br><span class="line">                   jobject javaLoader, jstring javaLibrarySearchPath)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>JVM_NativeLoad()</code>方法：</p><p>[art/runtime/openjdkjvm/OpenjdkJvm.cc]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jstring <span class="title">JVM_NativeLoad</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaFilename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 jstring javaLibrarySearchPath)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="comment">// 实际加载</span></span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env,</span><br><span class="line">                                         filename.c_str(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         javaLibrarySearchPath,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span></span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  <span class="keyword">return</span> env-&gt;NewStringUTF(error_msg.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过jvm的<code>LoadNativeLibary()</code>执行实际工作。具体实现在<code>java_vm_ext.cc</code>中：</p><p>[art/runtime/java_vm_ext.cc]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JavaVMExt::LoadNativeLibrary(JNIEnv* env,</span><br><span class="line">                                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path,</span><br><span class="line">                                  jobject class_loader,</span><br><span class="line">                                  jstring library_path,</span><br><span class="line">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg) &#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we've already loaded this library.  If we have, and the class loader</span></span><br><span class="line">  <span class="comment">// matches, return successfully without doing anything.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> for better results we should canonicalize the pathname (or even compare</span></span><br><span class="line">  <span class="comment">// inodes). This implementation is fine if everybody is using System.loadLibrary.</span></span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 1. 判断是否已经加载过这个library</span></span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* class_loader_allocator = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="comment">// As the incoming class loader is reachable/alive during the call of this function,</span></span><br><span class="line">    <span class="comment">// it's okay to decode it without worrying about unexpectedly marking it alive.</span></span><br><span class="line">    ObjPtr&lt;mirror::ClassLoader&gt; loader = soa.Decode&lt;mirror::ClassLoader&gt;(class_loader);</span><br><span class="line"></span><br><span class="line">    ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">    <span class="keyword">if</span> (class_linker-&gt;IsBootClassLoader(soa, loader.Ptr())) &#123;</span><br><span class="line">      loader = <span class="literal">nullptr</span>;</span><br><span class="line">      class_loader = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_loader_allocator = class_linker-&gt;GetAllocatorForClassLoader(loader.Ptr());</span><br><span class="line">    CHECK(class_loader_allocator != <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (library != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Use the allocator pointers for class loader equality to avoid unnecessary weak root decode.</span></span><br><span class="line">    <span class="keyword">if</span> (library-&gt;GetClassLoaderAllocator() != class_loader_allocator) &#123;</span><br><span class="line">      <span class="comment">// The library will be associated with class_loader. The JNI</span></span><br><span class="line">      <span class="comment">// spec says we can't load the same library into more than one</span></span><br><span class="line">      <span class="comment">// class loader.</span></span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Shared library \"%s\" already opened by "</span></span><br><span class="line">          <span class="string">"ClassLoader %p; can't open in ClassLoader %p"</span>,</span><br><span class="line">          path.c_str(), library-&gt;GetClassLoader(), class_loader);</span><br><span class="line">      LOG(WARNING) &lt;&lt; error_msg;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" already loaded in "</span></span><br><span class="line">              &lt;&lt; <span class="string">" ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!library-&gt;CheckOnLoadResult()) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_OnLoad failed on a previous attempt "</span></span><br><span class="line">          <span class="string">"to load \"%s\""</span>, path.c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the shared library.  Because we're using a full path, the system</span></span><br><span class="line">  <span class="comment">// doesn't have to search through LD_LIBRARY_PATH.  (It may do so to</span></span><br><span class="line">  <span class="comment">// resolve this library's dependencies though.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Failures here are expected when java.library.path has several entries</span></span><br><span class="line">  <span class="comment">// and we have to hunt for the lib.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Below we dlopen but there is no paired dlclose, this would be necessary if we supported</span></span><br><span class="line">  <span class="comment">// class unloading. Libraries will only be unloaded when the reference count (incremented by</span></span><br><span class="line">  <span class="comment">// dlopen) becomes zero from dlclose.</span></span><br><span class="line"></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* path_str = path.empty() ? <span class="literal">nullptr</span> : path.c_str();</span><br><span class="line">  <span class="keyword">bool</span> needs_native_bridge = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 2. 加载so</span></span><br><span class="line">  <span class="keyword">void</span>* handle = android::OpenNativeLibrary(env,</span><br><span class="line">                                            runtime_-&gt;GetTargetSdkVersion(),</span><br><span class="line">                                            path_str,</span><br><span class="line">                                            class_loader,</span><br><span class="line">                                            library_path,</span><br><span class="line">                                            &amp;needs_native_bridge,</span><br><span class="line">                                            error_msg);</span><br><span class="line"></span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Call to dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) returned "</span> &lt;&lt; handle &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 如果handle为空指针，说明上面OpenNativeLibrary失败了。</span></span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) failed: "</span> &lt;&lt; *error_msg;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Unexpected exception:"</span>;</span><br><span class="line">    env-&gt;ExceptionDescribe();</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new entry.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">  <span class="keyword">bool</span> created_library = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SharedLibrary&gt; new_library(</span><br><span class="line">        <span class="keyword">new</span> SharedLibrary(env,</span><br><span class="line">                          self,</span><br><span class="line">                          path,</span><br><span class="line">                          handle,</span><br><span class="line">                          needs_native_bridge,</span><br><span class="line">                          class_loader,</span><br><span class="line">                          class_loader_allocator));</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    <span class="keyword">if</span> (library == <span class="literal">nullptr</span>) &#123;  <span class="comment">// We won race to get libraries_lock.</span></span><br><span class="line">      library = new_library.release();</span><br><span class="line">      <span class="comment">// 4. 加载成功的library需要记录下来</span></span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!created_library) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"WOW: we lost a race to add shared library: "</span></span><br><span class="line">        &lt;&lt; <span class="string">"\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" ClassLoader="</span> &lt;&lt; class_loader;</span><br><span class="line">    <span class="keyword">return</span> library-&gt;CheckOnLoadResult();</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Added shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" for ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找并调用执行 JNI_OnLoad 方法回调</span></span><br><span class="line">  <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">void</span>* sym = library-&gt;FindSymbol(<span class="string">"JNI_OnLoad"</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[No JNI_OnLoad found in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    was_successful = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Call JNI_OnLoad.  We have to override the current class</span></span><br><span class="line">    <span class="comment">// loader, which will always be "null" since the stuff at the</span></span><br><span class="line">    <span class="comment">// top of the stack is around Runtime.loadLibrary().  (See</span></span><br><span class="line">    <span class="comment">// the comments in the JNI FindClass function.)</span></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Calling JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*JNI_OnLoadFn)</span><span class="params">(JavaVM*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">    JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runtime_-&gt;GetTargetSdkVersion() != <span class="number">0</span> &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">      <span class="comment">// Make sure that sigchain owns SIGSEGV.</span></span><br><span class="line">      EnsureFrontOfChain(SIGSEGV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version == JNI_ERR) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_ERR returned from JNI_OnLoad in \"%s\""</span>, path.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JavaVMExt::IsBadJniVersion(version)) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Bad JNI version returned from JNI_OnLoad in \"%s\": %d"</span>,</span><br><span class="line">                    path.c_str(), version);</span><br><span class="line">      <span class="comment">// It's unwise to call dlclose() here, but we can mark it</span></span><br><span class="line">      <span class="comment">// as bad and ensure that future load attempts will fail.</span></span><br><span class="line">      <span class="comment">// We don't know how far JNI_OnLoad got, so there could</span></span><br><span class="line">      <span class="comment">// be some partially-initialized stuff accessible through</span></span><br><span class="line">      <span class="comment">// newly-registered native method calls.  We could try to</span></span><br><span class="line">      <span class="comment">// unregister them, but that doesn't seem worthwhile.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      was_successful = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Returned "</span> &lt;&lt; (was_successful ? <span class="string">"successfully"</span> : <span class="string">"failure"</span>)</span><br><span class="line">              &lt;&lt; <span class="string">" from JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  <span class="keyword">return</span> was_successful;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadNativeLibrary方法开始的时候会去缓存查看是否已经加载过动态库，如果已经加载过会判断上次加载的ClassLoader和这次加载的ClassLoader是否一致，如果不一致则加载失败，如果一致则返回上次加载的结果，换句话说就是<strong>不允许不同的ClassLoader加载同一个动态库</strong>。为什么这么做我们这里不进行分析。 上面的整体操作步骤如下：</p><ol><li>判断缓存中是否已经加载过这个library，如果加载过就检查下ClassLoader，直接返回；</li><li>调用<code>android::OpenNativeLibrary()</code>方法加载library；</li><li>如果上一步的加载动作的返回值handle为空指针，说明上面OpenNativeLibrary失败了，返回；</li><li>记录加载成功的library，然后查找并调用library中的<code>JNI_OnLoad</code>回调方法。</li></ol><p>总之这个LoadNativeLibrary方法目的就是利用的是OpenNativeLibrary这个函数去加载动态链接库，然后执行其中的<code>JNI_OnLoad</code>接口（这个函数是jni库的首选入口，可以利用它完成一些初始化工作，或者动态注册JNI方法）。</p><p>[system/core/libnativeloader/native_loader.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* OpenNativeLibrary(JNIEnv* env,</span><br><span class="line">                        int32_t target_sdk_version,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>* path,</span><br><span class="line">                        jobject class_loader,</span><br><span class="line">                        jstring library_path,</span><br><span class="line">                        bool* needs_native_bridge,</span><br><span class="line">                        std::string* error_msg) &#123;</span><br><span class="line">#if defined(__ANDROID__)</span><br><span class="line">  UNUSED(target_sdk_version);</span><br><span class="line">  <span class="keyword">if</span> (class_loader == nullptr) &#123;</span><br><span class="line">    *needs_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dlopen(path, RTLD_NOW);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; guard(g_namespaces_mutex);</span><br><span class="line">  NativeLoaderNamespace ns;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_namespaces-&gt;FindNamespaceByClassLoader(env, class_loader, &amp;ns)) &#123;</span><br><span class="line">    <span class="comment">// This is the case where the classloader was not created by ApplicationLoaders</span></span><br><span class="line">    <span class="comment">// In this case we create an isolated not-shared namespace for it.</span></span><br><span class="line">    <span class="keyword">if</span> (!g_namespaces-&gt;Create(env,</span><br><span class="line">                              target_sdk_version,</span><br><span class="line">                              class_loader,</span><br><span class="line">                              <span class="keyword">false</span> <span class="comment">/* is_shared */</span>,</span><br><span class="line">                              <span class="keyword">false</span> <span class="comment">/* is_for_vendor */</span>,</span><br><span class="line">                              library_path,</span><br><span class="line">                              nullptr,</span><br><span class="line">                              &amp;ns,</span><br><span class="line">                              error_msg)) &#123;</span><br><span class="line">      <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ns.is_android_namespace()) &#123;</span><br><span class="line">    android_dlextinfo extinfo;</span><br><span class="line">    extinfo.flags = ANDROID_DLEXT_USE_NAMESPACE;</span><br><span class="line">    extinfo.library_namespace = ns.get_android_ns();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* handle = android_dlopen_ext(path, RTLD_NOW, &amp;extinfo);</span><br><span class="line">    <span class="keyword">if</span> (handle == nullptr) &#123;</span><br><span class="line">      *error_msg = dlerror();</span><br><span class="line">    &#125;</span><br><span class="line">    *needs_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = NativeBridgeLoadLibraryExt(path, RTLD_NOW, ns.get_native_bridge_ns());</span><br><span class="line">    <span class="keyword">if</span> (handle == nullptr) &#123;</span><br><span class="line">      *error_msg = NativeBridgeGetError();</span><br><span class="line">    &#125;</span><br><span class="line">    *needs_native_bridge = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">#else</span><br><span class="line">  UNUSED(env, target_sdk_version, class_loader, library_path);</span><br><span class="line">  *needs_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">void</span>* handle = dlopen(path, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (handle == nullptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NativeBridgeIsSupported(path)) &#123;</span><br><span class="line">      *needs_native_bridge = <span class="keyword">true</span>;</span><br><span class="line">      handle = NativeBridgeLoadLibrary(path, RTLD_NOW);</span><br><span class="line">      <span class="keyword">if</span> (handle == nullptr) &#123;</span><br><span class="line">        *error_msg = NativeBridgeGetError();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *needs_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">      *error_msg = dlerror();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先利用<code>FindNamespaceByClassLoader</code>查找当前的ClassLoader是否有相关的Namespace，如果没有直接跳转到<code>android_dlopen_ext</code>；如果有调用其Create方法创建一个Namespace。</p><p><code>android_dlopen_ext</code>跟<code>dlopen</code>类似，第一个参数是要打开的动态库的名称，第二个参数RTLD_NOW，表示动态库中所有未定义的符号在<code>dlopen</code>返回前都会被解析。</p><p>接下来的实现，是调用find_libary来查找动态库，找到后，调用dlsym来查找加载的动态库中是否包含JNI_OnLoader入口函数。</p><h2 id="Linux-加载动态库的系统调用"><a href="#Linux-加载动态库的系统调用" class="headerlink" title="Linux 加载动态库的系统调用"></a>Linux 加载动态库的系统调用</h2><p>Android是基于Linux系统的，那么在Linux系统下是如何加载动态链接库的呢？Linux环境下加载动态库主要包括如下函数，位于头文件#include &lt;dlfcn.h&gt;中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;  <span class="comment">//打开动态链接库</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//获取错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;  <span class="comment">//获取方法指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>; <span class="comment">//关闭动态链接库</span></span><br></pre></td></tr></table></figure><p>大家感兴趣的可以进一步Google，这里就不再深入到系统调用了。</p><p>看完这篇文章我们明确了几点：</p><ol><li>System.loadLibrary会优先查找apk中的so目录，再查找系统目录，系统目录包括：/vendor/lib(64)，/system/lib(64)</li><li>不能使用不同的ClassLoader加载同一个动态库</li><li>System.loadLibrary加载过程中会调用目标库的<code>JNI_OnLoad</code>方法，我们可以在动态库中加一个<code>JNI_OnLoad</code>方法用于动态注册</li><li>如果加了<code>JNI_OnLoad</code>方法，其的返回值为JNI_VERSION_1_2 ，JNI_VERSION_1_4， JNI_VERSION_1_6其一。我们一般使用JNI_VERSION_1_4即可</li><li>Android动态库的加载与Linux一致使用dlopen系列函数，通过动态库的句柄和函数名称来调用动态库的函数</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1071447" target="_blank" rel="noopener">Android 动态链接库加载原理及 HotFix 方案介绍</a></li><li><a href="https://pqpo.me/2017/05/31/system-loadlibrary/" target="_blank" rel="noopener">深入理解 System.loadLibrary</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近开发的组件时常出现了运行时加载so库失败问题，每天都会有&lt;code&gt;java.lang.UnsatisfiedLinkError&lt;/code&gt;的错误爆出来，而且线上总是偶然复现，很疑惑。所以本文将从AOSP源码简单跟踪Android中的动态链接库so的加载原理，试图找出一丝线索。&lt;/p&gt;
&lt;h2 id=&quot;加载入口&quot;&gt;&lt;a href=&quot;#加载入口&quot; class=&quot;headerlink&quot; title=&quot;加载入口&quot;&gt;&lt;/a&gt;加载入口&lt;/h2&gt;&lt;p&gt;首先我们知道在Android(Java)中加载一个动态链接库非常简单。就是我们日常调用的 &lt;code&gt;System.load(Sring filename)&lt;/code&gt; 或者&lt;code&gt;System.loadLibrary(String libname)&lt;/code&gt;开始。 看过&lt;a href=&quot;http://47.98.205.211/2017/05/17/jni/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《理解JNI技术》&lt;/a&gt;的应该知道上述代码执行过程中会调用native层的&lt;code&gt;JNI_OnLoad()&lt;/code&gt;方法，一般用于动态注册native方法。&lt;/p&gt;
&lt;h2 id=&quot;System-loadLibrary&quot;&gt;&lt;a href=&quot;#System-loadLibrary&quot; class=&quot;headerlink&quot; title=&quot;# System.loadLibrary&quot;&gt;&lt;/a&gt;# System.loadLibrary&lt;/h2&gt;&lt;p&gt;[System.java]&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String libname)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此处&lt;code&gt;VMStack.getCallingClassLoader()&lt;/code&gt;拿到的是调用者的ClassLoader，一般情况下是&lt;strong&gt;PathClassLoader&lt;/strong&gt;。我们进入Runtime类的&lt;code&gt;loadLibrary0()&lt;/code&gt;方法看看。&lt;/p&gt;
&lt;p&gt;[Runtime.java]&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadLibrary0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ClassLoader loader, String libname)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (libname.indexOf((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)File.separatorChar) != -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(&lt;span class=&quot;string&quot;&gt;&quot;Directory separator should not appear in library name: &quot;&lt;/span&gt; + libname);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String libraryName = libname;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1. 如果classloder存在，通过loader.findLibrary()查找到so路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String filename = loader.findLibrary(libraryName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (filename == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// It&#39;s not necessarily true that the ClassLoader used&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// System.mapLibraryName, but the default setup does, and it&#39;s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// misleading to say we didn&#39;t find &quot;libMyLibrary.so&quot; when we&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// actually searched for &quot;liblibMyLibrary.so.so&quot;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(loader + &lt;span class=&quot;string&quot;&gt;&quot; couldn&#39;t find \&quot;&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                           System.mapLibraryName(libraryName) + &lt;span class=&quot;string&quot;&gt;&quot;\&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String error = doLoad(filename, loader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2. 如果classloder不存在，通过loader.findLibrary()查找到so路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String filename = System.mapLibraryName(libraryName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; candidates = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String lastError = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String directory : getLibPaths()) &amp;#123;	&lt;span class=&quot;comment&quot;&gt;// getLibPaths()代码在最下方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String candidate = directory + filename;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        candidates.add(candidate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (IoUtils.canOpenReadOnly(candidate)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String error = doLoad(candidate, loader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// We successfully loaded the library. Job done.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lastError = error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3. 都没找到，抛出 UnsatisfiedLinkError 异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lastError != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(lastError);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(&lt;span class=&quot;string&quot;&gt;&quot;Library &quot;&lt;/span&gt; + libraryName + &lt;span class=&quot;string&quot;&gt;&quot; not found; tried &quot;&lt;/span&gt; + candidates);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Java】使用Atomic变量实现锁</title>
    <link href="https://itimetraveler.github.io/2018/05/22/%E3%80%90Java%E3%80%91%E4%BD%BF%E7%94%A8Atomic%E5%AE%9E%E7%8E%B0%E9%94%81/"/>
    <id>https://itimetraveler.github.io/2018/05/22/【Java】使用Atomic实现锁/</id>
    <published>2018-05-22T14:20:55.000Z</published>
    <updated>2018-05-23T02:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Atomic原子操作"><a href="#Atomic原子操作" class="headerlink" title="Atomic原子操作"></a>Atomic原子操作</h2><p>Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。</p><p>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类。</p><ul><li>原子更新基本类型类： AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li><li>原子更新数组类：AtomicIntegerArray，AtomicLongArray</li><li>原子更新引用类型：AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray</li><li>原子更新字段类：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li></ul><p>详细介绍可以参考：<a href="http://ifeve.com/java-atomic/" target="_blank" rel="noopener">Java中的Atomic包使用指南</a></p><h2 id="Atomic的原理"><a href="#Atomic的原理" class="headerlink" title="Atomic的原理"></a>Atomic的原理</h2><p>下面通过<code>AtomicInteger</code>的源码来看一下是怎么在没有锁的情况下保证数据正确性。首先看一下<code>incrementAndGet()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们继续看，<code>unsafe.getAndAddInt()</code> 的实现是什么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value of a field</span></span><br><span class="line"><span class="comment"> * or array element within the given object &lt;code&gt;o&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * at the given &lt;code&gt;offset&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o object/array to update the field/element in</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset field/element offset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个循环，offset是变量v在内存中相对于对象o起始位置的偏移，传给JNI层用来计算这个value的内存绝对地址。</p><p>然后找到JNI的实现代码，来看 native层的<code>compareAndSwapInt()</code>方法的实现。这个方法的实现是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);    <span class="comment">//计算变量的内存绝对地址</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>这个函数其实很简单，就是去看一下obj 的 offset 上的那个位置上的值是多少，如果是 e，那就把它更新为 x，返回true，如果不是 e，那就什么也不做，并且返回false。里面的核心方法是<code>Atomic::compxchg()</code>，这个方法所属的类文件是在os_cpu目录下面，由此可以看出这个类是和CPU操作有关，进入代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面都是汇编指令，看到<code>LOCK_IF_MP</code>也有锁指令实现的原子操作，其实CAS也算是有锁操作，只不过是由CPU来触发，比synchronized性能好的多。</p><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a><strong>什么是CAS</strong></h3><p>​       CAS，Compare and Swap即比较并交换。 java.util.concurrent包借助CAS实现了区别于synchronized同步锁的一种乐观锁。乐观锁就是每次去取数据的时候都乐观的认为数据不会被修改，所以不会上锁，但是在更新的时候会判断一下在此期间数据有没有更新。<strong>CAS有3个操作数：内存值V，旧的预期值A，要修改的新值B</strong>。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS的关键点在于，系统在硬件层面保证了比较并交换操作的原子性，处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><h3 id="CAS的优缺点"><a href="#CAS的优缺点" class="headerlink" title="CAS的优缺点"></a><strong>CAS的优缺点</strong></h3><ul><li>CAS由于是在硬件层面保证的原子性，不会锁住当前线程，它的效率是很高的。 </li><li>CAS虽然很高效的实现了原子操作，但是它依然存在三个问题。</li></ul><p>1、ABA问题。CAS在操作值的时候检查值是否已经变化，没有变化的情况下才会进行更新。但是如果一个值原来是A，变成B，又变成A，那么CAS进行检查时会认为这个值没有变化，但是实际上却变化了。ABA问题的解决方法是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就变成1A-2B－3A。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p><p>2、并发越高，失败的次数会越多，CAS如果长时间不成功，会极大的增加CPU的开销。因此CAS不适合竞争十分频繁的场景。</p><p>3、只能保证一个共享变量的原子操作。当对多个共享变量操作时，CAS就无法保证操作的原子性，这时就可以用锁，或者把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="实现自旋锁"><a href="#实现自旋锁" class="headerlink" title="实现自旋锁"></a>实现自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用AtomicInteger实现自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋等待直到获得许可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line"><span class="comment">//CAS指令要锁总线，效率很差。所以我们通过一个if判断避免了多次使用CAS指令。</span></span><br><span class="line"><span class="keyword">if</span> (state.get() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">state.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，就是一直CAS抢锁，如果抢不到，就一直死循环，直到抢到了才退出这个循环。</p><p>自旋锁实现起来非常简单，如果关键区的执行时间很短，往往自旋等待会是一种比较高效的做法，它可以避免线程的频繁切换和调度。但如果关键区的执行时间很长，那这种做法就会大量地浪费CPU资源。</p><p>针对关键区执行时间长的情况，该怎么办呢？</p><h2 id="实现可等待的锁"><a href="#实现可等待的锁" class="headerlink" title="实现可等待的锁"></a>实现可等待的锁</h2><p>如果关键区的执行时间很长，自旋的锁会大量地浪费CPU资源，我们可以这样改进：<strong>当一个线程拿不到锁的时候，就让这个线程先休眠等待。</strong>这样，CPU就不会白白地空转了。大致步骤如下：</p><ol><li>需要一个容器，如果线程抢不到锁，就把线程挂起来，并记录到这个容器里。</li><li>当一个线程放弃了锁，得从容器里找出一个挂起的线程，把它恢复了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用AtomicInteger实现可等待锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AtomicInteger state = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放到等待队列</span></span><br><span class="line">        waiters.add(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    waiters.remove(Thread.currentThread());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LockSupport.park();     <span class="comment">//挂起线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.set(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//唤醒等待队列的第一个线程</span></span><br><span class="line">        Thread waiterHead = waiters.peek();</span><br><span class="line">        <span class="keyword">if</span>(waiterHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            LockSupport.unpark(waiterHead);     <span class="comment">//唤醒线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们引入了一个 waitList，用于存储抢不到锁的线程，让它挂起。这里我们先借用一下JDK里的<code>ConcurrentLinkedQueue</code>，因为这个Queue也是使用CAS操作实现的无锁队列，所以并不会引入JDK里的其他锁机制。如果大家去看<code>AbstractQueuedSynchronizer</code>的实现，就会发现，它的<code>acquire()</code>方法的逻辑与上面的实现是一样的。</p><p>不过上面的代码是不是没问题了呢？如果一个线程在还未调用park挂起之前，是不是有可能被其他线程先调用一遍unpark？这就是唤醒发生在休眠之前。发生这样的情况会不会带来问题呢？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-atomic/" target="_blank" rel="noopener">Java中的Atomic包使用指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/33076650" target="_blank" rel="noopener">用Atomic实现锁</a></li><li><a href="https://zhuanlan.zhihu.com/p/33127453" target="_blank" rel="noopener">用Atomic实现可以等待的锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Atomic原子操作&quot;&gt;&lt;a href=&quot;#Atomic原子操作&quot; class=&quot;headerlink&quot; title=&quot;Atomic原子操作&quot;&gt;&lt;/a&gt;Atomic原子操作&lt;/h2&gt;&lt;p&gt;Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。&lt;/p&gt;
&lt;p&gt;在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子更新基本类型类： AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference&lt;/li&gt;
&lt;li&gt;原子更新数组类：AtomicIntegerArray，AtomicLongArray&lt;/li&gt;
&lt;li&gt;原子更新引用类型：AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray&lt;/li&gt;
&lt;li&gt;原子更新字段类：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细介绍可以参考：&lt;a href=&quot;http://ifeve.com/java-atomic/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java中的Atomic包使用指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Atomic的原理&quot;&gt;&lt;a href=&quot;#Atomic的原理&quot; class=&quot;headerlink&quot; title=&quot;Atomic的原理&quot;&gt;&lt;/a&gt;Atomic的原理&lt;/h2&gt;&lt;p&gt;下面通过&lt;code&gt;AtomicInteger&lt;/code&gt;的源码来看一下是怎么在没有锁的情况下保证数据正确性。首先看一下&lt;code&gt;incrementAndGet()&lt;/code&gt;方法的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Atomically increments by one the current value.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the updated value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;incrementAndGet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, valueOffset, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】NIO的原理与浅析</title>
    <link href="https://itimetraveler.github.io/2018/05/15/%E3%80%90Java%E3%80%91NIO%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://itimetraveler.github.io/2018/05/15/【Java】NIO的理解/</id>
    <published>2018-05-15T14:20:55.000Z</published>
    <updated>2018-05-18T11:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p>在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。</p><h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><a id="more"></a><h2 id="IO-同步、异步、阻塞、非阻塞"><a href="#IO-同步、异步、阻塞、非阻塞" class="headerlink" title="IO - 同步、异步、阻塞、非阻塞"></a>IO - 同步、异步、阻塞、非阻塞</h2><p>本文讨论的背景是Linux环境下的network IO。同步（Synchronous） IO和异步（Asynchronous） IO，阻塞（Blocking） IO和非阻塞（Non-Blocking）IO分别是什么，到底有什么区别？ 我们可以参考下这篇文章：<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></p><p>本文最重要的参考文献是Richard Stevens的“<strong>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking</strong> ”，6.2节“<strong>I/O Models</strong> ”，Stevens在这节中详细说明了各种IO的特点和区别。</p><p>Stevens在文章中一共比较了五种IO Model：</p><ul><li>[1] blocking IO - 阻塞IO</li><li>[2] nonblocking IO - 非阻塞IO</li><li>[3] IO multiplexing - IO多路复用</li><li>[4] signal driven IO - 信号驱动IO</li><li>[5] asynchronous IO - 异步IO</li></ul><p>其中前面4种IO都可以归类为synchronous IO - 同步IO。由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><p>下面以network IO中的read读操作为切入点，来讲述同步（synchronous） IO和异步（asynchronous） IO、阻塞（blocking） IO和非阻塞（non-blocking）IO的异同。一般情况下，一次网络IO读操作会涉及两个系统对象：(1) 用户进程(线程)Process；(2)内核对象kernel，两个处理阶段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] Waiting <span class="keyword">for</span> the data to be ready - 等待数据准备好</span><br><span class="line">[<span class="number">2</span>] Copying the data <span class="keyword">from</span> the kernel to the process - 将数据从内核空间的buffer拷贝到用户空间进程的buffer</span><br></pre></td></tr></table></figure><p>IO模型的异同点就是区分在这两个系统对象、两个处理阶段的不同上。</p><h3 id="1-同步IO-之-Blocking-IO"><a href="#1-同步IO-之-Blocking-IO" class="headerlink" title="1. 同步IO 之 Blocking IO"></a>1. 同步IO 之 Blocking IO</h3><p><img src="/gallery/java-common/blocking-io.png" alt=""></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="2-同步IO-之-NonBlocking-IO"><a href="#2-同步IO-之-NonBlocking-IO" class="headerlink" title="2. 同步IO 之 NonBlocking IO"></a>2. 同步IO 之 NonBlocking IO</h3><p><img src="/gallery/java-common/nonblocking-io.png" alt=""></p><p>从图中可以看出，process在NonBlocking IO读recvfrom操作的第一个阶段是不会block等待的，如果kernel数据还没准备好，那么recvfrom会立刻返回一个EWOULDBLOCK错误。当kernel准备好数据后，进入处理的第二阶段的时候，process会等待kernel将数据copy到自己的buffer，在kernel完成数据的copy后process才会从recvfrom系统调用中返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h3 id="3-同步IO-之-IO-multiplexing"><a href="#3-同步IO-之-IO-multiplexing" class="headerlink" title="3. 同步IO 之 IO multiplexing"></a>3. 同步IO 之 IO multiplexing</h3><p>IO多路复用，就是我们熟知的select、poll、epoll模型。从下图可见，在IO多路复用的时候，process在两个处理阶段都是block住等待的。初看好像IO多路复用没什么用，其实select、poll、epoll的优势在于可以以较少的代价来同时监听处理多个IO。在于使用单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程</p><p><img src="/gallery/java-common/io-multiplexing.png" alt=""></p><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。。</p><blockquote><p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></blockquote><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (<strong>select</strong> 和 <strong>recvfrom</strong>)，而blocking IO只调用了一个system call (<strong>recvfrom</strong>)。但是，用select的优势在于它可以同时处理多个connection。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h3 id="4-异步IO"><a href="#4-异步IO" class="headerlink" title="4. 异步IO"></a>4. 异步IO</h3><p><img src="/gallery/java-common/asynchronus-io.png" alt=""></p><p>从上图看出，异步IO要求用户进程在<strong>aio_read</strong>操作的两个处理阶段上都不能等待，也就是用户进程调用aio_read后立刻返回，kernel自行去准备好数据并将数据从kernel的buffer中copy到用户进程的buffer在通知用户进程读操作完成了，然后会发送一个signal通知用户进程去继续处理。遗憾的是，linux的网络IO中是不存在异步IO的，linux的网络IO处理的第二阶段总是阻塞等待数据copy完成的。真正意义上的网络异步IO是Windows下的IOCP（IO完成端口）模型。</p><blockquote><p>所以，asynchronous IO的特点就是在IO执行的两个阶段都<strong>不会被block</strong>。</p></blockquote><p>各个IO Model的比较如图所示：</p><p><img src="/gallery/java-common/compare.png" alt=""></p><p>很多时候，我们比较容易混淆non-blocking IO和asynchronous IO，认为是一样的。但是通过上图，几种IO模型的比较，会发现non-blocking IO和asynchronous IO的区别还是很明显的，non-blocking IO仅仅要求处理的第一阶段不block即可，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO要求两个阶段都不能block住。用户进程将整个IO操作交给了kernel系统调用去完成，然后kernel做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h2 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a>I/O 多路复用之select、poll、epoll详解</h2><p>select，poll，epoll三个都是Linux的IO多路复用的机制，可以监视多个描述符的读/写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。但本质上，<code>select</code>、<code>poll</code>、<code>epoll</code>本质上都是同步I/O。因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。参考文章：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<strong>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024</strong>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>select的本质是采用32个整数的32位，即32*32=1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改<code>FD_SETSIZE</code>的大小。这个时候就可以标识32*max值范围的fd。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">true</span> &#123;</span><br><span class="line">    select(streams[])</span><br><span class="line">    <span class="keyword">for</span> i in streams[] &#123;</span><br><span class="line">        <span class="keyword">if</span> i has data</span><br><span class="line">        read until unavailable</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。这里我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><p>poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><h4 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h4><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的fd句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>1. int epoll_create(int size);</strong></p><p>创建一个epoll的fd文件描述符句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<strong>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</strong>。因为在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是<code>epoll_create(int size)</code>有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是<code>epoll_create(int size)</code>的参数size实际上已经没有意义了。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看<code>/proc/进程id/fd/</code>，是能够看到这个fd的，所以在使用完epoll后，必须调用<code>close()</code>关闭，否则可能导致fd被耗尽。</p><p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong></p><p>函数是对指定描述符fd执行op操作。<br>- epfd：是epoll_create()的返回值。<br>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>- fd：是需要监听的fd（文件描述符）<br>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p><p>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告知内核最多返回的events要几个，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">true</span> &#123;</span><br><span class="line">    active_stream[] = epoll_wait(epollfd)</span><br><span class="line">    <span class="keyword">for</span> i in active_stream[] &#123;</span><br><span class="line">        read or write till</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)或者O(k)）</p><p>epoll是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create / epoll_ctl / epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。</p><h2 id="NIO的概念"><a href="#NIO的概念" class="headerlink" title="NIO的概念"></a>NIO的概念</h2><p>我们平常说的普通的Java IO就是阻塞I/O模式，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</p><p>自从JDK 1.4版本以来，JDK发布了全新的I/O类库，简称NIO（New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p><p><img src="/gallery/java-common/200901051231133411250.jpg" alt=""></p><p>NIO的包中主要包含了这样几种抽象数据类型： </p><ul><li><strong>Buffer</strong>：包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的I/O操作。</li><li><strong>Charset</strong>：它提供Unicode字符串影射到字节序列以及逆映射的操作。</li><li><strong>Channels</strong>：包含socket，file和pipe三种管道，都是全双工的通道。</li><li><strong>Selector</strong>：多个异步I/O操作集中到一个或多个线程中（可以被看成是Unix中select()函数的面向对象版本）。</li></ul><p><img src="/gallery/java-common/Nio_Selector.png" alt=""></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="简单了解Channel和Buffer"><a href="#简单了解Channel和Buffer" class="headerlink" title="简单了解Channel和Buffer"></a>简单了解Channel和Buffer</h3><p><img src="/gallery/java-common/nio-buffer.png" alt=""></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote><p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.</p></blockquote><p>NIO把它支持的I/O对象抽象为Channel，Channel又称“通道”，类似于原I/O中的流（Stream），但有所区别：<br>1、流是单向的，通道是双向的，可读可写。<br>2、流读写是阻塞的，通道可以异步读写。<br>3、流中的数据可以选择性的先读到缓存中，通道的数据总是要先读到一个缓存中，或从缓存中写入，如下所示：</p><p><img src="/gallery/java-common/2184951-bd19826b2e3f7c26.png" alt=""></p><p>目前已知Channel的实现类有：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="深入理解Selector"><a href="#深入理解Selector" class="headerlink" title="深入理解Selector"></a>深入理解Selector</h3><p>之前进行socket编程时，accept方法会一直阻塞，直到有客户端请求的到来，并返回socket进行相应的处理。整个过程是流水线的，处理完一个请求，才能去获取并处理后面的请求，当然也可以把获取socket和处理socket的过程分开，一个线程负责accept，一个线程池负责处理请求。</p><p>但NIO提供了更好的解决方案，采用选择器（Selector）返回已经准备好的socket，并按顺序处理，基于通道（Channel）和缓冲区（Buffer）来进行数据的传输。</p><p>在这里，这个人就相当Selector，每个鸡笼相当于一个SocketChannel，每个线程通过一个Selector可以管理多个SocketChannel。</p><p><img src="/gallery/java-common/java-nio-selector.png" alt=""></p><p>为了实现Selector管理多个SocketChannel，必须将具体的SocketChannel对象注册到Selector，并声明需要监听的事件（这样Selector才知道需要记录什么数据），一共有4种事件：</p><p>1、<strong>connect</strong>：客户端连接服务端事件，对应值为SelectionKey.OP_CONNECT(8)<br>2、<strong>accept</strong>：服务端接收客户端连接事件，对应值为SelectionKey.OP_ACCEPT(16)<br>3、<strong>read</strong>：读事件，对应值为SelectionKey.OP_READ(1)<br>4、<strong>write</strong>：写事件，对应值为SelectionKey.OP_WRITE(4)</p><p>这个很好理解，每次请求到达服务器，都是从connect开始，connect成功后，服务端开始准备accept，准备就绪，开始读数据，并处理，最后写回数据返回。</p><p>所以，当SocketChannel有对应的事件发生时，Selector都可以观察到，并进行相应的处理。</p><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><p>为了更好的理解，先看一段服务端的示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//Channel设置为非阻塞</span></span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//Channel注册到Selector中</span></span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = selector.select();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    Iterator ite = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">        SelectionKey key = (SelectionKey)ite.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">            SocketChannel clntChan = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">            clntChan.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将选择器注册到连接到的客户端信道，</span></span><br><span class="line">            <span class="comment">//并指定该信道key值的属性为OP_READ，</span></span><br><span class="line">            <span class="comment">//同时为该信道指定关联的附件</span></span><br><span class="line">            clntChan.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufSize));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">            handleRead(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.isWritable() &amp;&amp; key.isValid())&#123;</span><br><span class="line">            handleWrite(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.isConnectable())&#123;</span><br><span class="line">            System.out.println(<span class="string">"isConnectable = true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      ite.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端操作过程如下：</p><ol><li>创建ServerSocketChannel实例，并绑定指定端口；</li><li>创建Selector实例；</li><li>将serverSocketChannel注册到selector，并指定事件OP_ACCEPT，最底层的socket通过channel和selector建立关联；</li><li>如果没有准备好的socket，select方法会被阻塞一段时间并返回0；</li><li>如果底层有socket已经准备好，selector的select方法会返回socket的个数，而且selectedKeys方法会返回socket对应的事件（connect、accept、read or write）；</li><li>根据事件类型，进行不同的处理逻辑；</li></ol><h4 id="Selector实现原理"><a href="#Selector实现原理" class="headerlink" title="Selector实现原理"></a>Selector实现原理</h4><p>SocketChannel、ServerSocketChannel和Selector的实例初始化都通过SelectorProvider类实现，其中Selector是整个NIO Socket的核心实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelectorProvider在windows和linux下有不同的实现，provider方法会返回对应的实现。其中<code>provider = sun.nio.ch.DefaultSelectorProvider.create();</code>会根据操作系统来返回不同的实现类，windows平台就返回WindowsSelectorProvider；</p><p><img src="/gallery/java-common/WX20180517-182153@2xjietu.png" alt=""></p><h4 id="Selector-wakeup"><a href="#Selector-wakeup" class="headerlink" title="Selector.wakeup()"></a>Selector.wakeup()</h4><h5 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h5><p>解除阻塞在Selector.select()/select(long)上的线程，立即返回。</p><p>两次成功的select之间多次调用wakeup等价于一次调用。</p><p>如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。</p><p>为什么要唤醒？</p><p>注册了新的channel或者事件。</p><p>channel关闭，取消注册。</p><p>优先级更高的事件触发（如定时器事件），希望及时处理。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Linux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。</p><p>wakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。</p><h2 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO, NIO, AIO"></a>BIO, NIO, AIO</h2><p>BIO同步阻塞IO，适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><p>NIO同步非阻塞IO，适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><p>AIO异步非阻塞IO，AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>NIO主要使用了Channel和Selector来实现，Java的Selector类似Winsock的Select模式，是一种基于事件驱动的，整个处理方法使用了轮训的状态机，好处就是单线程更节省系统开销，NIO的好处可以很好的处理并发，对于Android网游开发来说比较关键，对于多点Socket连接而言使用NIO可以大大减少线程使用，降低了线程死锁的概率。</p><p>NIO作为一种中高负载的I/O模型，相对于传统的BIO (Blocking I/O)来说有了很大的提高，处理并发不用太多的线程，省去了创建销毁的时间，如果线程过多调度是问题，同时很多线程可能处于空闲状态，大大浪费了CPU时间，同时过多的线程可能是性能大幅下降，一般的解决方案中可能使用线程池来管理调度但这种方法治标不治本。使用NIO可以使并发的效率大大提高。当然NIO和JDK 7中的AIO还存在一些区别，AIO作为一种更新的当然这是对于Java而言，如果你开发过Winsock服务器，那么IOCP这样的I/O完成端口可以解决更高级的负载</p><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><blockquote><ol start="2"><li><a href="https://www.zhihu.com/question/59975081" target="_blank" rel="noopener">IO多路复用（比如epoll）到底是不是异步的？</a></li></ol></blockquote><p>Java NIO是同步非阻塞io。简单来说同步和异步需要说明针对哪一个通信层次来讨论，异步编程框架是说框架内的业务代码与框架的接口是异步的，而框架与操作系统的接口是同步非阻塞。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 - 美团点评技术团队</a></li><li><a href="https://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="noopener">深入浅出NIO之Selector实现原理 - 占小狼</a></li><li><a href="http://goon.iteye.com/blog/1775421" target="_blank" rel="noopener">Java NIO——Selector机制解析三（源码分析）</a></li><li><a href="https://blog.csdn.net/haoel/article/details/2224055" target="_blank" rel="noopener">Java NIO类库Selector机制解析（上）—— 陈皓</a></li><li><a href="https://yq.aliyun.com/articles/466889" target="_blank" rel="noopener">Java NIO类库Selector机制解析（下）—— 陈皓</a></li><li><a href="http://www.cnblogs.com/melons/p/5791788.html" target="_blank" rel="noopener">Linux下I/O多路转接之epoll(绝对经典)</a></li><li><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">epoll 或者 kqueue 的原理是什么？- 知乎</a></li><li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="noopener">大话 Select、Poll、Epoll</a></li><li><a href="https://blog.csdn.net/wangpeihuixyz/article/details/41732127" target="_blank" rel="noopener">linux内核epoll实现分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h2&gt;&lt;h3 id=&quot;用户空间与内核空间&quot;&gt;&lt;a href=&quot;#用户空间与内核空间&quot; class=&quot;headerlink&quot; title=&quot;用户空间与内核空间&quot;&gt;&lt;/a&gt;用户空间与内核空间&lt;/h3&gt;&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。&lt;/p&gt;
&lt;p&gt;在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。&lt;/p&gt;
&lt;h3 id=&quot;文件描述符fd&quot;&gt;&lt;a href=&quot;#文件描述符fd&quot; class=&quot;headerlink&quot; title=&quot;文件描述符fd&quot;&gt;&lt;/a&gt;文件描述符fd&lt;/h3&gt;&lt;p&gt;文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。&lt;/p&gt;
&lt;p&gt;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Thread类中的join()方法原理</title>
    <link href="https://itimetraveler.github.io/2018/05/04/%E3%80%90Java%E3%80%91Thread%E7%B1%BB%E4%B8%AD%E7%9A%84join()%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>https://itimetraveler.github.io/2018/05/04/【Java】Thread类中的join()方法原理/</id>
    <published>2018-05-04T14:20:55.000Z</published>
    <updated>2018-05-09T10:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>join()</code>是Thread类的一个方法。根据jdk文档的定义：</p><blockquote><p>public final void join()throws InterruptedException:  <strong>Waits for this thread to die</strong>.</p></blockquote><p><code>join()</code>方法的作用，是等待这个线程结束；但显然，这样的定义并不清晰。个人认为”Java 7 Concurrency Cookbook”的定义较为清晰：</p><blockquote><p><strong>join() method suspends the execution of the calling thread until the object called finishes its execution.</strong></p></blockquote><p>也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。我们来看看下面的例子。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们对比一下下面这两个例子，看看使用<code>join()</code>方法的作用是什么？</p><ol><li>不使用<code>join()</code>方法的情况：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MainThread run start."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动一个子线程</span></span><br><span class="line">    Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"threadA run start."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"threadA run finished."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadA.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"MainThread join before"</span>);</span><br><span class="line">    System.out.println(<span class="string">"MainThread run finished."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>MainThread run start.<br>threadA run start.<br>MainThread join before<br>MainThread run finished.<br>threadA run finished.</p></blockquote><p>因为上述子线程执行时间相对较长，所以是在主线程执行完毕之后才结束。</p><ol start="2"><li>使用了<code>join()</code>方法的情况：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MainThread run start."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动一个子线程</span></span><br><span class="line">    Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"threadA run start."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"threadA run finished."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadA.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"MainThread join before"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadA.join();    <span class="comment">//调用join()</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"MainThread run finished."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>MainThread run start.<br>threadA run start.<br>MainThread join before<br>threadA run finished.<br>MainThread run finished.</p></blockquote><p>对子线程threadA使用了<code>join()</code>方法之后，我们发现主线程会等待子线程执行完成之后才往后执行。</p><h2 id="join-的原理和作用"><a href="#join-的原理和作用" class="headerlink" title="join()的原理和作用"></a><code>join()</code>的原理和作用</h2><p>java层次的状态转换图</p><p><img src="/gallery/java-common/20170531150958304.jpeg" alt=""></p><p>我们来深入源码了解一下join()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();  <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;    <span class="comment">//这个分支是无限期等待直到b线程结束</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//这个分支是等待固定时间，如果b没结束，那么就不等待了。</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注一下这两句，无限期等待的情况：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);<span class="comment">//wait操作，那必然有synchronized与之对应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个<code>wait()</code>方法是Object类中的方法，再来看sychronized的是谁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>成员方法加了synchronized说明是<code>synchronized(this)</code>，this是谁啊？this就是threadA子线程对象本身。也就是说，主线程持有了threadA这个对象的锁。</p><p>大家都知道，有了<code>wait()</code>，必然有<code>notify()</code>，什么时候才会notify呢？在jvm源码里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于/hotspot/src/share/vm/runtime/thread.cpp中</span></span><br><span class="line"><span class="keyword">void</span> JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Notify waiters on thread object. This has to be done after exit() is called</span></span><br><span class="line">    <span class="comment">// on the thread (if the thread is the last thread in a daemon ThreadGroup the</span></span><br><span class="line">    <span class="comment">// group should have the destroyed bit set before waiters are notified).</span></span><br><span class="line">    <span class="comment">// 有一个贼不起眼的一行代码，就是这行</span></span><br><span class="line">    ensure_join(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">    <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">    <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">"java thread object must exist"</span>);</span><br><span class="line">    <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line">    <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">    java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">    <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">    <span class="comment">// to complete once we've done the notify_all below</span></span><br><span class="line">    java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同志们看到了没，别的不用看，就看这一句</span></span><br><span class="line">    <span class="comment">// thread就是当前线程，是啥？就是刚才例子中说的threadA线程啊。</span></span><br><span class="line">    lock.notify_all(thread);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子线程threadA执行完毕的时候，jvm会自动唤醒阻塞在threadA对象上的线程，在我们的例子中也就是主线程。至此，threadA线程对象被notifyall了，那么主线程也就能继续跑下去了。</p><p><strong>可以看出，<code>join()</code>方法实现是通过<code>wait()</code>（小提示：Object 提供的方法）。 当main线程调用threadA.join时候，main线程会获得线程对象threadA的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程 （也就是子线程threadA执行完毕退出的时候）</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先<code>join()</code> 是一个synchronized方法， 里面调用了<code>wait()</code>，这个过程的目的是让持有这个同步锁的线程进入等待，那么谁持有了这个同步锁呢？答案是主线程，因为主线程调用了<code>threadA.join()</code>方法，相当于在<code>threadA.join()</code>代码这块写了一个同步代码块，谁去执行了这段代码呢，是主线程，所以主线程被wait()了。然后在子线程threadA执行完毕之后，JVM会调用<code>lock.notify_all(thread);</code>唤醒持有threadA这个对象锁的线程，也就是主线程，会继续执行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/44621343" target="_blank" rel="noopener">Java中Thread类的join方法到底是如何实现等待的？</a></li><li><a href="http://www.cnblogs.com/techyc/p/3286678.html" target="_blank" rel="noopener">简谈Java的join()方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;join()&lt;/code&gt;是Thread类的一个方法。根据jdk文档的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public final void join()throws InterruptedException:  &lt;strong&gt;Waits for this thread to die&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;join()&lt;/code&gt;方法的作用，是等待这个线程结束；但显然，这样的定义并不清晰。个人认为”Java 7 Concurrency Cookbook”的定义较为清晰：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;join() method suspends the execution of the calling thread until the object called finishes its execution.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。我们来看看下面的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Retrofit源码分析</title>
    <link href="https://itimetraveler.github.io/2018/04/10/%E3%80%90Android%E3%80%91Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://itimetraveler.github.io/2018/04/10/【Android】Retrofit源码分析/</id>
    <published>2018-04-10T14:20:55.000Z</published>
    <updated>2018-04-13T10:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p><code>retrofit</code> n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型</p><p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener"><strong>Retrofit</strong></a> 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 <code>Retrofit</code> 来完成的。<code>Retrofit</code> 2.0 开始内置 <a href="http://square.github.io/okhttp/" target="_blank" rel="noopener"><code>OkHttp</code></a>，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大量的设计模式 封装了 <code>OkHttp</code> ，使得简洁易用。</p><p><img src="/gallery/android_common/4182937778-57515297dacff_articlex.png" alt=""></p><p>我们的应用程序通过 <code>Retrofit</code> 请求网络，实际上是使用 <code>Retrofit</code> 接口层封装请求参数、Header、Url 等信息，之后由 <code>OkHttp</code>完成后续的请求操作，在服务端返回数据之后，<code>OkHttp</code> 将原始的结果交给 <code>Retrofit</code>，后者根据用户的需求对结果进行解析的过程。Retrofit的大概原理过程如下：</p><ol><li><code>Retrofit</code> 将 <code>Http</code>请求 抽象 成 <code>Java</code>接口</li><li>在接口里用 注解 描述和配置 网络请求参数</li><li>用动态代理 的方式，动态将网络请求接口的注解 解析 成<code>HTTP</code>请求</li><li>最后执行<code>HTTP</code>请求</li></ol><p>这篇文章我将从Retrofit的基本用法出发，按照其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。</p><p>Retrofit Github: <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>使用 <code>Retrofit</code> 非常简单，首先需要在 build.gradle 中添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.4.0'</span></span><br></pre></td></tr></table></figure><p>如果需要使用Gson解析器，也需要在build.gradle中添加依赖（后文会详细讲到Retrofit的Converter）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.0.2'</span></span><br></pre></td></tr></table></figure><h4 id="1-定义Interface"><a href="#1-定义Interface" class="headerlink" title="1. 定义Interface"></a>1. 定义Interface</h4><p>Retrofit使用java interface和注解描述了HTTP请求的API参数，比如Github的一个API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中Repo类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Repo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建Retrofit实例"><a href="#2-创建Retrofit实例" class="headerlink" title="2. 创建Retrofit实例"></a>2. 创建Retrofit实例</h4><p>这样调用Retrofit就会为上面这个interface自动生成一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())<span class="comment">//添加Gson解析器</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><h4 id="3-发起请求"><a href="#3-发起请求" class="headerlink" title="3. 发起请求"></a>3. 发起请求</h4><p>然后调用interface的具体方法时（这里是<code>listRepos()</code>）就构造好了一个<code>Call</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure><p>返回的 <code>call</code> 其实并不是真正的数据结果，只是封装成了一个随时可以执行的请求，需要在合适的时机去执行它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步调用</span></span><br><span class="line">List&lt;Repo&gt; data = repos.execute(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步调用</span></span><br><span class="line">repos.enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">                List&lt;Repo&gt; data = response.body();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>怎么样，有没有突然觉得请求接口就好像访问自家的方法一样简单？下面我们转入源码分析，按照使用步骤来探索Retrofit的实现原理。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们先来看看Retrofit的实例化步骤。先看看Retrofit这个类的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;<span class="comment">// 生产网络请求器（Call）的工厂，默认使用OkHttp</span></span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;<span class="comment">// url地址</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;<span class="comment">// 数据转换器（converter）工厂</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;<span class="comment">// 生产网络请求适配器（CallAdapter）的工厂List</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;<span class="comment">// 回调方法执行器</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;<span class="comment">// 是否提前对业务接口中的注解进行验证转换的标志位</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retrofit的构造函数是package包可见的，并不是public的，所以外部并不能直接new，而是要通过<code>Retrofit.Builder</code>来实例化。</p><h4 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder"></a>Retrofit.Builder</h4><p><code>Retrofit.Builder</code> 是 Retrofit 类中的一个子类，负责用来创建 Retrofit 实例对象，使用『Builder模式』的好处是清晰明了可定制化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Retrofit支持Android Java8 默认Platform 三种平台，此处确认当前是在哪个平台环境运行</span></span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Retrofit.Builder</code> 中的成员变量跟Retrofit中基本上是一一对应的，就不过多解释了。这里可以看到Builder的构造函数中默认判断了一下当前的运行平台。</p><p>最后，在创建 <code>Retrofit.Builder</code> 对象并进行自定义配置后，我们就要调用 <code>build()</code> 方法来构造出 <code>Retrofit</code> 对象了。那么，我们来看下 <code>build()</code> 方法里干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须要配置baseUrl</span></span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android 平台下默认为 MainThreadExecutor</span></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    <span class="comment">// 添加默认的 ExecutorCallAdapterFactory</span></span><br><span class="line">    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">    <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">    <span class="comment">// 首先添加默认的 BuiltInConverters</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>build()</code> 中，做的事情有：检查配置、设置默认配置、创建 <code>Retrofit</code> 对象。并且在执行 <code>.build()</code> 方法前，只有 <code>.baseUrl()</code> 是必须调用来设置访问地址的，其余方法则是可选的。同时我们可以看到设置了很多默认成员，但这里我们重点关注四个成员：<code>callFactory</code>，<code>callAdapter</code>，<code>responseConverter</code>和 <code>parameterHandlers</code>。</p><ol><li><code>callFactory</code> 负责创建 HTTP 请求，HTTP 请求被抽象为了 <code>okhttp3.Call</code> 类，它表示一个已经准备好，可以随时执行的 HTTP 请求；</li><li><code>callAdapter</code> 负责把 <code>retrofit2.Call&lt;?&gt;</code> 里的<code>Call</code>转换为 另一种类型<code>T</code>（注意和 <code>okhttp3.Call</code> 区分开来，<code>retrofit2.Call&lt;?&gt;</code> 表示的是对一个 Retrofit 方法的调用），这个过程会发送一个 HTTP 请求，拿到服务器返回的数据（通过 <code>okhttp3.Call</code> 实现），并把数据转换为声明的 <code>T</code> 类型对象（通过 <code>Converter&lt;F, T&gt;</code> 实现）；</li><li><code>responseConverter</code> 是 <code>Converter&lt;ResponseBody, T&gt;</code> 类型，负责把服务器返回的数据（JSON、XML、PB、二进制或者其他格式，由 <code>ResponseBody</code> 封装）转化为 <code>T</code> 类型的对象；</li><li><code>parameterHandlers</code> 则负责解析 API 定义时每个方法的参数，并在构造 HTTP 请求时设置参数；</li></ol><h4 id="CallAdapter和Converter到底是干什么的？"><a href="#CallAdapter和Converter到底是干什么的？" class="headerlink" title="CallAdapter和Converter到底是干什么的？"></a>CallAdapter和Converter到底是干什么的？</h4><p>这里多插两句，给大家解释一下这个<code>CallAdapter</code>和<code>Converter</code>到底是干什么的？我们知道，最简单的Retrofit接口一般定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">listRepos</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给Retrofit不添加任何<code>CallAdapterFactory</code>的情况下，接口方法的返回类型必须是<code>Call&lt;?&gt;</code>，不能是其他类型。因而Retrofit提供了对这个Call进行转换为其他类型的功能，那就是<code>CallAdapter</code>。比如添加一个<strong>RxJava</strong>的CallAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.example.com"</span>)</span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<span class="comment">// RxJava转换器</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>然后我们就可以这样定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function">Observable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果添加了一个<strong>Java8</strong>的CallAdapter，就可以这样定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function">CompletableFuture&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Retrofit提供的CallAdapter："><a href="#Retrofit提供的CallAdapter：" class="headerlink" title="Retrofit提供的CallAdapter："></a>Retrofit提供的CallAdapter：</h5><table><thead><tr><th>CallAdapter</th><th>Gradle依赖</th></tr></thead><tbody><tr><td>guava</td><td>com.squareup.retrofit2:adapter-guava:latest.version</td></tr><tr><td>Java8</td><td>com.squareup.retrofit2:adapter-java8:latest.version</td></tr><tr><td>rxjava</td><td>com.squareup.retrofit2:adapter-rxjava:latest.version</td></tr><tr><td>rxjava2</td><td>com.squareup.retrofit2:adapter-rxjava2:latest.version</td></tr><tr><td>scala</td><td>com.squareup.retrofit2:adapter-scala:latest.version</td></tr></tbody></table><p>同样地，如果在不给Retrofit添加任何<code>ConverterFactory</code>的情况下，接口方法返回类型<code>Call&lt;T&gt;</code>里的泛型<code>T</code>必须是<code>ResponseBody</code>，而不能是其他类型（比如<code>List&lt;User&gt;</code>），这就是<code>Converter</code>的作用，直白点也就是数据解析器，负责把<code>ResponseBody</code>解析成<code>List&lt;User&gt;</code>。</p><p>另外，在我们构造 HTTP 请求时，我们传递的参数都是使用的注解类型（诸如 <code>Path</code>，<code>Query</code>，<code>Field</code> 等），那 Retrofit 是如何把我们传递的各种参数都转化为 String 的呢？还是由 <code>Retrofit</code> 类提供<code>Converter</code>！</p><p><code>Converter.Factory</code> 除了提供responseBodyConverter，还提供 requestBodyConverter 和 stringConverter，API 方法中除了 <code>@Body</code> 和 <code>@Part</code> 类型的参数，都利用 stringConverter 进行转换，而 <code>@Body</code> 和 <code>@Part</code> 类型的参数则利用 requestBodyConverter 进行转换。</p><h5 id="Retrofit提供的Converter"><a href="#Retrofit提供的Converter" class="headerlink" title="Retrofit提供的Converter"></a>Retrofit提供的Converter</h5><table><thead><tr><th>Converter</th><th>Gradle依赖</th></tr></thead><tbody><tr><td>Gson</td><td>com.squareup.retrofit2:converter-gson:latest.version</td></tr><tr><td>Guava</td><td>com.squareup.retrofit2:converter-guava:latest.version</td></tr><tr><td>Jackson</td><td>com.squareup.retrofit2:converter-jackson:latest.version</td></tr><tr><td>Java8</td><td>com.squareup.retrofit2:converter-java8:latest.version</td></tr><tr><td>Jaxb</td><td>com.squareup.retrofit2:converter-jaxb:latest.version</td></tr><tr><td>Moshi</td><td>com.squareup.retrofit2:converter-moshi:latest.version</td></tr><tr><td>Protobuf</td><td>com.squareup.retrofit2:converter-protobuf:latest.version</td></tr><tr><td>Scalars</td><td>com.squareup.retrofit2:converter-scalars:latest.version</td></tr><tr><td>Wire</td><td>com.squareup.retrofit2:converter-wire:latest.version</td></tr><tr><td>Simple XML</td><td>com.squareup.retrofit2:converter-simplexml:latest.version</td></tr></tbody></table><h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><p>这里我们再来个小插曲，来看下 Retrofit 是如何确定当前运行的是哪个平台环境的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);<span class="comment">//通过反射判断平台</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认Platform的callbackExecutor</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DefaultCallAdapterFactory.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(Method method, Class&lt;?&gt; declaringClass, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @Nullable Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，是通过反射判断有没有该类来实现的。比较巧妙，大家可以的学习一下。</p><p>而此处的<code>Android</code>和<code>Java8</code>均是Platform的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Android平台的默认callbackExecutor，实际上就是抛到UI线程去执行回调</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Android平台的默认CallAdapterFactory</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Only classloaded and used on Java 8.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断被调用的method是否Java8的默认方法</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.isDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用默认方法</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(Method method, Class&lt;?&gt; declaringClass, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         @Nullable Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// Because the service interface might not be public, we need to use a MethodHandle lookup</span></span><br><span class="line">        <span class="comment">// that ignores the visibility of the declaringClass.</span></span><br><span class="line">        Constructor&lt;Lookup&gt; constructor = Lookup.class.getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(declaringClass, -<span class="number">1</span> <span class="comment">/* trusted */</span>)</span><br><span class="line">                .unreflectSpecial(method, declaringClass)</span><br><span class="line">                .bindTo(object)</span><br><span class="line">                .invokeWithArguments(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 的interface引入了新的语言特性——默认方法（Default Methods）。大家可以参考这篇文章：<a href="https://blog.csdn.net/u010003835/article/details/76850242" target="_blank" rel="noopener">Java8 默认方法 default method</a></p><blockquote><p>默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。</p></blockquote><p>所以如果在Java8的平台上使用Retrofit的话，Retrofit需要排除我们定义的interface中的这些Default Methods。</p><p>在使用<code>Retrofit.Builder</code>实例化得到 <code>Retrofit</code> 对象后就是调用 <code>Retrofit#create()</code> 方法来创建我们 API 接口的实例。</p><h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><p>所以我们需要跟进Retrofit类中的 <code>create(final Class&lt;T&gt; service)</code> 方法来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验是否为接口，且不能继承其他接口</span></span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="comment">// 是否需要提前解析接口方法</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 动态代理模式, 返回一个 service 接口的代理对象</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，最关键的就是『动态代理』，返回了一个 Proxy 代理类，调用接口中的任何方法都会调用 proxy 里的 invoke 方法。实际上，进行网络操作的都是通过代理类来完成的。<strong>简单的说，在我们前面的示例代码中调用 <code>GitHubService.listRepos</code> 时，实际上调用的是这里的 <code>InvocationHandler.invoke</code> 方法。</strong></p><p> <code>InvocationHandler.invoke</code>这个方法的意思是：如果调用的是 <code>Object</code> 的方法，例如 <code>equals</code>，<code>toString</code>，那就直接调用。如果是 default 方法（Java 8 引入的新语法），就调用 default 方法。这些我们都先不管，因为我们在Android平台调用 <code>listRepos</code>，肯定不是这两种情况，那这次调用真正干活的就是这三行代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><p><strong>这三句代码，下面我们着重来看。</strong></p><p>在代理中，会根据参数中传入的具体接口方法来构造出对应的 <code>serviceMethod</code> 。<code>ServiceMethod</code> 类的作用就是把接口的方法适配为对应的 HTTP call 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">// 先从缓存中取，若没有就去创建对应的 ServiceMethod</span></span><br><span class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有缓存就创建，之后再放入缓存中</span></span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在内部还维护了一个 <code>serviceMethodCache</code> 来缓存 <code>ServiceMethod</code> ，同一个 API 的同一个方法，只会创建一次。由于我们每次获取 API 实例都是传入的 <code>class</code> 对象（比如示例中的GitHubService.class），而 <code>class</code> 对象是进程内单例的，所以获取到它的同一个方法 <code>Method</code> 实例也是单例的，所以这里的缓存是有效的。我们就直接来看 <code>ServiceMethod</code> 是如何被创建的吧。</p><h4 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h4><p><code>ServiceMethod&lt;R, T&gt;</code> 类的作用正如其 JavaDoc 所言：</p><blockquote><p>Adapts an invocation of an interface method into an HTTP call. 把对接口方法的调用转为一次 HTTP 调用。</p></blockquote><p>一个 <code>ServiceMethod</code> 对象对应于一个 API interface 的一个方法，上面的<code>loadServiceMethod(method)</code>方法负责加载了 <code>ServiceMethod</code>。我们发现 <code>ServiceMethod</code> 也是通过建造者模式（<code>ServiceMethod.Builder</code>）来创建对象的。那就进入对应构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于ServiceMethod类中</span></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">      <span class="comment">// 接口方法的注解</span></span><br><span class="line">      <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">      <span class="comment">// 接口方法的参数类型</span></span><br><span class="line">      <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      <span class="comment">// 接口方法参数的注解</span></span><br><span class="line">      <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中没有什么特别的地方，我们单刀直入 <code>build()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据接口方法的注解和返回类型创建 callAdapter</span></span><br><span class="line">      <span class="comment">// 如果没有添加 CallAdapter 那么默认会用 ExecutorCallAdapterFactory</span></span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      <span class="comment">// calladapter 的响应类型中的泛型，比如 Call&lt;User&gt; 中的 User</span></span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">                  + Utils.getRawType(responseType).getName()</span><br><span class="line">                  + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 根据之前泛型中的类型以及接口方法的注解创建 ResponseConverter</span></span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据接口方法的注解构造请求方法，比如 @GET @POST @DELETE 等</span></span><br><span class="line">      <span class="comment">// 另外还有添加请求头，检查url中有无带?，转化 path 中的参数</span></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">          parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若无 body 则不能有 Multipart 和 FormEncoded 的注解</span></span><br><span class="line">      <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">              <span class="keyword">throw</span> methodError(</span><br><span class="line">                      <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">              <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">                      + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析接口方法参数中的注解，比如 @Path @Query @QueryMap @Field 等等</span></span><br><span class="line">      <span class="comment">// 相应的，每个方法的参数都创建了一个 ParameterHandler&lt;?&gt; 对象</span></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">          Type parameterType = parameterTypes[p];</span><br><span class="line">          <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">                      parameterType);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">          <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查构造出的请求有没有不对的地方</span></span><br><span class="line">      <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 <code>build()</code> 中代码挺长的，总结起来就一句话：就是将 API 接口中的方法进行解析，构造成 <code>ServiceMethod</code>，交给下面的 <code>OkHttpCall</code> 使用。</p><p>基本上做的事情就是：</p><ol><li>创建 CallAdapter ；</li><li>创建 ResponseConverter；</li><li>根据 API 接口方法的注解构造网络请求方法；</li><li>根据 API 接口方法参数中的注解构造网络请求的参数；</li><li>检查有无异常；</li></ol><p>下面我们看看第二句重要的代码<code>OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</code></p><h4 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h4><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code>，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue(Callback&lt;T&gt; callback)</code> 接口。前者用于同步执行 HTTP 请求，后者用于异步执行。我们先看 <code>execute()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 根据 serviceMethod 中的众多数据创建出 Okhttp 中的 Request 对象</span></span><br><span class="line">            <span class="comment">// 注意的一点，会调用上面的 ParameterHandler.apply 方法来填充网络请求参数</span></span><br><span class="line">            <span class="comment">// 然后再根据 OkhttpClient 创建出 Okhttp 中的 Call</span></span><br><span class="line">            <span class="comment">// 这一步也说明了在 Retrofit 中的 OkHttpCall 内部请求最后会转换为 OkHttp 的 Call</span></span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">                throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">                creationFailure = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行 call 并转换成响应的 response</span></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>execute()</code> 做的就是将 Retrofit 中的 call 转化为 OkHttp 中的 Call 。最后让 OkHttp 的 Call 去执行。</p><p>主要包括三步：</p><ol><li>调用<code>createRawCall()</code>创建了 <code>okhttp3.Call</code>，包括构造参数；</li><li>使用<code>call.execute()</code>执行网络请求；</li><li>解析网络请求返回的数据；</li></ol><p>我们分别来看看<code>createRawCall()</code>和<code>parseResponse()</code>这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall类中</span></span><br><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call = serviceMethod.toCall(args);</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createRawCall()</code> 函数中，我们调用了 <code>serviceMethod.toCall(args)</code> 来创建 <code>okhttp3.Call</code>，而在后者中，我们之前准备好的 <code>parameterHandlers</code> 就派上了用场。</p><p>然后我们再调用 <code>serviceMethod.callFactory.newCall(request)</code> 来创建 <code>okhttp3.Call</code>，这里之前准备好的 <code>callFactory</code> 同样也派上了用场，由于工厂在构造 <code>Retrofit</code> 对象时可以指定，所以我们也可以指定其他的工厂（例如使用过时的 <code>HttpURLConnection</code> 的工厂），来使用其它的底层 HttpClient 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">            .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回的响应码不是成功的话，返回错误 Response</span></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rawBody.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回的响应码是204或者205，返回没有 body 的成功 Response</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 body 转换为对应的泛型，然后返回成功 Response</span></span><br><span class="line">        T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">        <span class="comment">// a runtime exception.</span></span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用 <code>okhttp3.Call#execute()</code> 来执行网络请求，这个方法是阻塞的，执行完毕之后将返回收到的响应数据。收到响应数据之后，我们进行了状态码的检查，通过检查之后我们调用了 <code>serviceMethod.toResponse(catchingBody)</code> 来把响应数据转化为了我们需要的数据类型对象T。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod类中</span></span><br><span class="line"><span class="function">R <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>serviceMethod</code> 的<code>toResponse</code> 函数中，我们之前准备好的 <code>responseConverter</code> 也派上了用场。我们分别看下：</p><ol><li><code>responseConverter</code>这个实例哪里来？</li><li><code>ResponseConverter</code>的<code>convert()</code>方法干了什么？</li></ol><h4 id="默认的Converter"><a href="#默认的Converter" class="headerlink" title="默认的Converter"></a>默认的Converter</h4><h5 id="1-responseConverter这个实例哪里来？"><a href="#1-responseConverter这个实例哪里来？" class="headerlink" title="#1. responseConverter这个实例哪里来？"></a>#1. <code>responseConverter</code>这个实例哪里来？</h5><p>在<code>ServiceMethod.Builder</code>类中，我们找到了它的赋值的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ServiceMethod.Builder类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建默认的CallAdapter</span></span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">            + Utils.getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 创建默认的ResponseConverter</span></span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，在<code>build()</code>方法中同时创建了默认的CallAdapter和ResponseConverter。我们先继续前往<code>createResponseConverter</code>关注ResponseConverter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是根据我们定义的接口方法的返回类型和注解，交给了Retrofit的<code>responseBodyConverter(Type type, Annotation[] annotations)</code>去找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据接口方法的返回类型、注解等信息找到对应的ResponseConverter</span></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到任何ResponseConverter的话，就抛异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">            .append(type)</span><br><span class="line">            .append(<span class="string">".\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Retrofit</code> 类内部，将遍历一个 <code>converterFactories</code> 列表，让工厂们提供，如果最终没有工厂能（根据 <code>returnType</code> 和 <code>annotations</code>）提供需要的 <code>ResponseConverter</code>，那将抛出异常。而这个工厂列表我们可以在构造 <code>Retrofit</code> 对象时进行添加。</p><p>还记得我们在使用<code>Retrofit.Builder</code>构造Retrofit对象的时候，默认添加的<code>converterFactory</code>吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());<span class="comment">// 默认的Converter</span></span><br><span class="line">      converterFactories.addAll(<span class="keyword">this</span>.converterFactories);   <span class="comment">// 我们自定义的Converter</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-ResponseConverter的convert-方法干了什么？"><a href="#2-ResponseConverter的convert-方法干了什么？" class="headerlink" title="#2. ResponseConverter的convert()方法干了什么？"></a>#2. <code>ResponseConverter</code>的<code>convert()</code>方法干了什么？</h5><p>我们看看这个内置转换器（<code>BuildInConverters</code>）是什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 内置的BuiltInConverters直接返回ResponseBody或者Void类型</span></span><br><span class="line">        <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">                    ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">                    : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) &#123;</span><br><span class="line">            <span class="keyword">return</span> RequestBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接返回，不进行任何处理</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的<code>BuiltInConverters</code>会直接返回<code>ResponseBody</code>或者<code>Void</code>类型，不做其他任何的转换操作，所以如果我们不添加任何ConverterFactory的默认情况下，我们定义的接口方法返回类型只能接受<code>ResponseBody</code>或者<code>Void</code>这两种类型。</p><h4 id="默认的CallAdapter"><a href="#默认的CallAdapter" class="headerlink" title="默认的CallAdapter"></a>默认的CallAdapter</h4><p>下面，我们来看下那三句重要代码中的最后一句<code>return serviceMethod.adapt(okHttpCall);</code>。ServiceMethod类中的<code>adapt()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod类中</span></span><br><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们分别看下：</p><ol><li>这个<code>callAdapter</code>实例哪里来的？</li><li><code>CallAdapter</code>类的<code>adapt()</code>方法干了什么？</li></ol><h5 id="1-这个callAdapter实例哪里来的？"><a href="#1-这个callAdapter实例哪里来的？" class="headerlink" title="#1. 这个callAdapter实例哪里来的？"></a>#1. 这个<code>callAdapter</code>实例哪里来的？</h5><p>这个<code>callAdapter</code>实例是在哪里赋值的呢，我们找到了<code>ServiceMethod.Builder</code>的<code>build()</code>方法，可以回到上面看看这个方法的源码，可以看到它是调用了<code>createCallAdapter</code>这个方法创建的，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod.Builder类中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">                <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口方法返回的类型不能是void</span></span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>callAdapter</code> 还是由 <code>Retrofit</code> 类提供的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                         Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据接口方法的返回类型、注解等信息找到对应的CallAdapter</span></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到任何CallAdapter，抛异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">            .append(returnType)</span><br><span class="line">            .append(<span class="string">".\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n   * "</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n   * "</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Retrofit</code> 类内部，将遍历一个 <code>CallAdapter.Factory</code> 列表，让工厂们提供，如果最终没有工厂能（根据 <code>returnType</code> 和 <code>annotations</code>）提供需要的 <code>CallAdapter</code>，那将抛出异常。而这个工厂列表我们可以在构造 <code>Retrofit</code> 对象时进行添加。</p><p>还记得我们在使用<code>Retrofit.Builder</code>构造Retrofit对象的时候，默认添加的<code>CallAdapterFactory</code>吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.Builder类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">      <span class="comment">// 添加默认的CallAdapterFactory</span></span><br><span class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而此时的Platform是<code>Android</code>，回顾一下Android的默认CallAdapterFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了默认的CallAdapterFactory</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到默认的是<code>ExecutorCallAdapterFactory</code>这个工厂类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注一下这个get()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>ExecutorCallAdapterFactory</code>这个工厂类通过<code>get()</code>方法new了一个<code>CallAdapter</code>。然后来看看第二个问题。</p><h5 id="2-CallAdapter类的adapt-方法干了什么？"><a href="#2-CallAdapter类的adapt-方法干了什么？" class="headerlink" title="#2. CallAdapter类的adapt()方法干了什么？"></a>#2. <code>CallAdapter</code>类的<code>adapt()</code>方法干了什么？</h5><p>好了，搞清楚了<code>callAdapter</code>的来历，我们看看它的<code>adapt()</code>方法。从上面的分析我们知道，这个<code>CallAdapter</code>类的<code>adapt()</code>方法返回了一个<code>ExecutorCallbackCall</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;  <span class="comment">// delegate 就是构造器中传进来的 OkHttpCall</span></span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">        checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">        delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看见这个默认的<code>ExecutorCallbackCall</code>仅仅是把结果回调CallBack放到了对应的<code>CallbackExecutor</code>去执行，并没有对结果进行任何加工。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>一般客户端向服务器请求API，总共分三步：</p><ol><li>build request(API参数配置)</li><li>executor(这里可以有很多变体，比如有无队列，进出顺序，线程管理)</li><li>parse callback(解析数据，返回T给上层)</li></ol><p>如今的retrofit也是换汤不换药的。也是这三步：</p><ol><li>通过定义interface和使用注解来配置API参数</li><li><code>CallAdapter</code>(你可以把它理解成executor)</li><li><code>Converter</code>(解析数据并转换成T)</li></ol><p><img src="/gallery/android_common/625299-29a632638d9f518f.png" alt=""></p><p>Retrofit采用了<strong>外观模式</strong>统一调用创建网络请求接口实例和网络请求参数配置的方法，具体细节是：</p><ul><li>动态创建网络请求接口的实例<strong>（代理模式 - 动态代理）</strong></li><li>创建 <code>serviceMethod</code> 对象<strong>（建造者模式 &amp; 单例模式（缓存机制））</strong></li><li>对 <code>serviceMethod</code> 对象进行网络请求参数配置：通过解析网络请求接口方法的参数、返回值和注解类型，从Retrofit对象中获取对应的网络请求的url地址、网络请求执行器、网络请求适配器 &amp; 数据转换器。<strong>（策略模式）</strong></li><li>对 <code>serviceMethod</code> 对象加入线程切换的操作，便于接收数据后通过Handler从子线程切换到主线程从而对返回数据结果进行处理<strong>（装饰模式）</strong></li><li>最终创建并返回一个<code>OkHttpCall</code>类型的网络请求对象</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://gist.github.com/hachy/82d0f7f1a93d80b12fd8" target="_blank" rel="noopener">Retrofit - Sample</a></li><li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="noopener">拆轮子系列：拆 Retrofit</a></li><li><a href="http://wensibo.top/2017/09/05/retrofit/" target="_blank" rel="noopener">Retrofit2.0源码解析</a></li><li><a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></li><li><a href="https://zhuanlan.zhihu.com/p/21662195" target="_blank" rel="noopener">「Android技术汇」Retrofit2 源码解析和案例说明</a></li><li><a href="https://segmentfault.com/a/1190000005638577" target="_blank" rel="noopener">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？</a></li><li><a href="https://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="noopener">你真的会用Retrofit2吗?Retrofit2完全教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Retrofit简介&quot;&gt;&lt;a href=&quot;#Retrofit简介&quot; class=&quot;headerlink&quot; title=&quot;Retrofit简介&quot;&gt;&lt;/a&gt;Retrofit简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;retrofit&lt;/code&gt; n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Retrofit&lt;/strong&gt;&lt;/a&gt; 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 &lt;code&gt;Retrofit&lt;/code&gt; 来完成的。&lt;code&gt;Retrofit&lt;/code&gt; 2.0 开始内置 &lt;a href=&quot;http://square.github.io/okhttp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;OkHttp&lt;/code&gt;&lt;/a&gt;，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大量的设计模式 封装了 &lt;code&gt;OkHttp&lt;/code&gt; ，使得简洁易用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/android_common/4182937778-57515297dacff_articlex.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的应用程序通过 &lt;code&gt;Retrofit&lt;/code&gt; 请求网络，实际上是使用 &lt;code&gt;Retrofit&lt;/code&gt; 接口层封装请求参数、Header、Url 等信息，之后由 &lt;code&gt;OkHttp&lt;/code&gt;完成后续的请求操作，在服务端返回数据之后，&lt;code&gt;OkHttp&lt;/code&gt; 将原始的结果交给 &lt;code&gt;Retrofit&lt;/code&gt;，后者根据用户的需求对结果进行解析的过程。Retrofit的大概原理过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Retrofit&lt;/code&gt; 将 &lt;code&gt;Http&lt;/code&gt;请求 抽象 成 &lt;code&gt;Java&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;在接口里用 注解 描述和配置 网络请求参数&lt;/li&gt;
&lt;li&gt;用动态代理 的方式，动态将网络请求接口的注解 解析 成&lt;code&gt;HTTP&lt;/code&gt;请求&lt;/li&gt;
&lt;li&gt;最后执行&lt;code&gt;HTTP&lt;/code&gt;请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这篇文章我将从Retrofit的基本用法出发，按照其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。&lt;/p&gt;
&lt;p&gt;Retrofit Github: &lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/square/retrofit&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;Retrofit&lt;/code&gt; 非常简单，首先需要在 build.gradle 中添加依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation &lt;span class=&quot;string&quot;&gt;&#39;com.squareup.retrofit2:retrofit:2.4.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果需要使用Gson解析器，也需要在build.gradle中添加依赖（后文会详细讲到Retrofit的Converter）：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation &lt;span class=&quot;string&quot;&gt;&#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-定义Interface&quot;&gt;&lt;a href=&quot;#1-定义Interface&quot; class=&quot;headerlink&quot; title=&quot;1. 定义Interface&quot;&gt;&lt;/a&gt;1. 定义Interface&lt;/h4&gt;&lt;p&gt;Retrofit使用java interface和注解描述了HTTP请求的API参数，比如Github的一个API：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GitHubService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@GET&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;users/&amp;#123;user&amp;#125;/repos&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Call&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; listRepos(&lt;span class=&quot;meta&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;) String user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】App应用前后台切换的一种监听方法</title>
    <link href="https://itimetraveler.github.io/2018/04/06/%E3%80%90Android%E3%80%91App%E5%BA%94%E7%94%A8%E5%89%8D%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95/"/>
    <id>https://itimetraveler.github.io/2018/04/06/【Android】App应用前后台切换的一种监听方法/</id>
    <published>2018-04-06T04:20:55.000Z</published>
    <updated>2018-04-06T11:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android本身并没有提供监听App的前后台切换操作的方法。最近看到一种简单巧妙的方法来监听前后台，这里分享记录一下。</p><h3 id="一、Activity生命周期"><a href="#一、Activity生命周期" class="headerlink" title="一、Activity生命周期"></a>一、Activity生命周期</h3><p>我们知道在Android中，两个Activity，分别为A和B。假设此时A在前台，当A启动B时，他们俩之间的生命周期关系如下，可以参考之前的这篇文章<a href="https://blog.csdn.net/u010983881/article/details/50036647" target="_blank" rel="noopener">【Android】Activity与Fragment的生命周期的关系</a>：</p><blockquote><p>A.onPause()  -&gt;  B.onCreate()  -&gt;  <strong>B.onStart()</strong>  -&gt;  B.onResume()  -&gt;  <strong>A.onStop()</strong></p></blockquote><p>也就是说B的onStart()方法是在A的onStop()方法之前执行的，我们可以根据这点来做文章。<strong>在所有Activity的onStart()和onStop()方法中进行计数，计数变量为count，在onStart中将变量加1，onStop中减1。</strong></p><p>那么这个count在整个App的生命周期里的值就会像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count</span><br><span class="line">2|          _     _     _     _</span><br><span class="line">1|     ____| |___| |___| |___| |____</span><br><span class="line">0| ___|                             |___</span><br><span class="line"> ===========================================&gt; 时间</span><br><span class="line">      a     b     c                 d</span><br></pre></td></tr></table></figure><p>横轴表示时间，纵轴表示count的值。那么a、b、c、d四个时间点发生的事情如下：</p><ol><li>a点就是启动了应用；</li><li>b点是<strong>Activity_A</strong>启动了另一个<strong>Activity_B</strong>；</li><li>c点是<strong>Activity_B</strong>启动了另一个<strong>Activity_C</strong>，后面以此类推；</li><li>d点是应用切换到了后台；</li></ol><p>从上面的情况看出，可以通过对count计数为0，来判断应用被从前台切到了后台。同样的，从后台切到前台也是类似的道理。具体实现看后面的代码。</p><a id="more"></a><p>具体的实现中，我们可以实现一个BaseActivity，然后让其他所有Activity都继承自它，然后在生命周期函数中做相应的检测。还有更简单的方法，Android在API 14之后，在Application类中，提供了一个应用生命周期回调的注册方法，用来对应用的生命周期进行集中管理，这个接口叫<code>registerActivityLifecycleCallbacks()</code>，可以通过它注册自己的<strong>ActivityLifeCycleCallback</strong>，每一个Activity的生命周期都会回调到这里的对应方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位于Application类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个注册方法的本质和我们实现BaseActivity是一样的，只是将生命周期的管理移到了Activity本身的实现中。</p><h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFinalCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        registerActivityLifecycleCallbacks(<span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                mFinalCount++;</span><br><span class="line">                <span class="comment">//如果mFinalCount ==1，说明是从后台到前台</span></span><br><span class="line">                <span class="keyword">if</span> (mFinalCount == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//说明从后台回到了前台</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                mFinalCount--;</span><br><span class="line">                <span class="comment">//如果mFinalCount == 0，说明是前台到后台</span></span><br><span class="line">                <span class="keyword">if</span> (mFinalCount == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//说明从前台回到了后台</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/trap1314/article/details/70739076" target="_blank" rel="noopener">判断Android程序前后台切换的几种方法</a></li><li><a href="https://blog.csdn.net/goodlixueyong/article/details/50543627" target="_blank" rel="noopener">Android应用前后台切换的判断</a></li><li><a href="https://blog.csdn.net/u010072711/article/details/77090313" target="_blank" rel="noopener">优雅的使用ActivityLifecycleCallbacks管理Activity和区分App前后台</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android本身并没有提供监听App的前后台切换操作的方法。最近看到一种简单巧妙的方法来监听前后台，这里分享记录一下。&lt;/p&gt;
&lt;h3 id=&quot;一、Activity生命周期&quot;&gt;&lt;a href=&quot;#一、Activity生命周期&quot; class=&quot;headerlink&quot; title=&quot;一、Activity生命周期&quot;&gt;&lt;/a&gt;一、Activity生命周期&lt;/h3&gt;&lt;p&gt;我们知道在Android中，两个Activity，分别为A和B。假设此时A在前台，当A启动B时，他们俩之间的生命周期关系如下，可以参考之前的这篇文章&lt;a href=&quot;https://blog.csdn.net/u010983881/article/details/50036647&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Android】Activity与Fragment的生命周期的关系&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A.onPause()  -&amp;gt;  B.onCreate()  -&amp;gt;  &lt;strong&gt;B.onStart()&lt;/strong&gt;  -&amp;gt;  B.onResume()  -&amp;gt;  &lt;strong&gt;A.onStop()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说B的onStart()方法是在A的onStop()方法之前执行的，我们可以根据这点来做文章。&lt;strong&gt;在所有Activity的onStart()和onStop()方法中进行计数，计数变量为count，在onStart中将变量加1，onStop中减1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么这个count在整个App的生命周期里的值就会像下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2|          _     _     _     _&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1|     ____| |___| |___| |___| |____&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0| ___|                             |___&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ===========================================&amp;gt; 时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      a     b     c                 d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;横轴表示时间，纵轴表示count的值。那么a、b、c、d四个时间点发生的事情如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a点就是启动了应用；&lt;/li&gt;
&lt;li&gt;b点是&lt;strong&gt;Activity_A&lt;/strong&gt;启动了另一个&lt;strong&gt;Activity_B&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;c点是&lt;strong&gt;Activity_B&lt;/strong&gt;启动了另一个&lt;strong&gt;Activity_C&lt;/strong&gt;，后面以此类推；&lt;/li&gt;
&lt;li&gt;d点是应用切换到了后台；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面的情况看出，可以通过对count计数为0，来判断应用被从前台切到了后台。同样的，从后台切到前台也是类似的道理。具体实现看后面的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Java】线程池ThreadPoolExecutor实现原理</title>
    <link href="https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://itimetraveler.github.io/2018/02/13/【Java】线程池ThreadPoolExecutor实现原理/</id>
    <published>2018-02-13T14:20:55.000Z</published>
    <updated>2018-03-14T08:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>线程池：可以理解为缓冲区，由于频繁的创建销毁线程会带来一定的成本，可以预先创建但不立即销毁，以共享方式为别人提供服务，一来可以提供效率，再者可以控制线程无线扩张。合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><p>但是要做到合理的利用线程池，必须对其原理了如指掌。</p><h2 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a><strong>线程的几种状态</strong></h2><p>线程在一定条件下，状态会发生变化。根据<a href="https://my.oschina.net/cctester/blog/991744" target="_blank" rel="noopener">线程的几种状态</a>这篇文章，线程一共有以下几种状态：</p><p><strong>1、新建状态(New)</strong>：新创建了一个线程对象。<br><strong>2、就绪状态(Runnable)</strong>：线程对象创建后，其他线程调用了该对象的<code>start()</code>方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，即<strong>在就绪状态的线程除CPU之外，其它的运行所需资源都已全部获得。</strong><br><strong>3、运行状态(Running)</strong>：就绪状态的线程获取了CPU，执行程序代码。<br><strong>4、阻塞状态(Blocked)</strong>：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><ul><li>①. 等待阻塞：运行的线程执行<code>wait()</code>方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的必须依靠其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法才能被唤醒。</li><li>②. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</li><li>③. 其他阻塞：运行的线程执行<code>sleep()</code>或<code>join()</code>方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当<code>sleep()</code>状态超时、<code>join()</code>等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。</li></ul><p><strong>5、死亡状态(Dead)</strong>：线程执行完了或者因异常退出了<code>run()</code>方法，该线程结束生命周期。</p><a id="more"></a><p>线程变化的状态转换图如下：</p><p><img src="/gallery/java-common/149974_1450349079825_4697A22AC611680A692472687DEC1CFD.png" alt="线程状态转换图"></p><blockquote><p>拿到对象的锁标记，即为获得了对该对象(临界区)的使用权限。即该线程获得了运行所需的资源，进入“就绪状态”，只需获得CPU，就可以运行。</p><p>因为当调用wait()后，线程会释放掉它所占有的“锁标志”，所以线程只有在此获取资源才能进入就绪状态。</p></blockquote><p>下面作下解释： </p><ul><li>线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口，但不管怎样，  当我们new了这个对象后，线程就进入了初始状态； </li><li>当该对象调用了start()方法，就进入就绪状态； </li><li>进入就绪后，当该对象被操作系统选中，获得CPU时间片就会进入运行状态； </li><li>进入运行状态后情况就比较复杂；<ol><li><code>run()</code>方法或<code>start()</code>方法结束后，线程就进入终止状态； </li><li>当线程调用了自身的<code>sleep()</code>方法或其他线程的<code>join()</code>方法，进程让出CPU，然后就会进入阻塞状态（该状态既停止当前线程，但并不释放所占有的资源，即调用<code>sleep()</code>函数后，线程不会释放它的“锁标志”。）。当<code>sleep()</code>结束或<code>join()</code>结束后，该线程进入可运行状态，继续等待OS分配CPU时间片；典型地，<code>sleep()</code>被用在等待某个资源就绪的情形；测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li><li>线程调用了<code>yield()</code>方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态，OS有可能会接着又让这个进程进入运行状态；调用<code>yield()</code> 的效果等价于调度程序认为该线程已执行了足够的时间片从而需要转到另一个线程。<code>yield()</code>只是使当前线程重新回到可执行状态，所以执行<code>yield()</code>的线程有可能在进入到可执行状态后马上又被执行。</li><li>当线程刚进入可运行状态（注意，还没运行），发现将要调用的资源被synchronized（同步），获取不到锁标记，将会立即进入锁池状态，等待获取锁标记（这时的锁池里也许已经有了其他线程在等待获取锁标记，这时它们处于队列状态，既先到先得），一旦线程获得锁标记后，就转入就绪状态，等待OS分配CPU时间片。</li><li><code>suspend()</code>和 <code>resume()</code>方法：两个方法配套使用，<code>suspend()</code>使得线程进入阻塞状态，并且不会自动恢复，必须其对应的<code>resume()</code>被调用，才能使得线程重新进入可执行状态。典型地，<code>suspend()</code>和 <code>resume()</code>被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用<code>resume()</code>使其恢复。 </li><li><code>wait()</code>和<code>notify()</code>方法：当线程调用<code>wait()</code>方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法才能被唤醒（由于<code>notify()</code>只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒， 因此在实际使用时，一般都用<code>notifyAll()</code>方法，唤醒有所线程），线程被唤醒后会进入锁池，等待获取锁标记。 <strong>wait() 使得线程进入阻塞状态，它有两种形式：</strong>一种允许指定以ms为单位的时间作为参数，另一种没有参数。前者当对应的<code>notify()</code>被调用或超出指定时间时线程重新进入可执行状态即就绪状态，后者则必须对应的<code>notify()</code>被调用。 当调用<code>wait()</code>后，线程会释放掉它所占有的“锁标志”，从而使线程所在对象中的其它synchronized数据可被别的线程使用。<code>wait()</code>和<code>notify()</code>因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。 如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生<strong>IllegalMonitorStateException</strong>的异常。</li></ol></li></ul><p><img src="/gallery/java-common/java-thread-state.png" alt=""></p><h2 id="线程池ThreadPoolExecutor实现原理"><a href="#线程池ThreadPoolExecutor实现原理" class="headerlink" title="线程池ThreadPoolExecutor实现原理"></a>线程池ThreadPoolExecutor实现原理</h2><p>我们先看下ThreadPoolExecutor的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/java-common/1506308400666NssJxY.png" alt="ThreadPoolExecutor的继承关系"></p><p>再看看ThreadPoolExecutor的构造方法了解一下这个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造参数比较多，一个一个说下：</p><ul><li><strong>corePoolSize</strong>：线程池中的核心线程数；</li><li><strong>maximumPoolSize</strong>：线程池最大线程数，它表示在线程池中最多能创建多少个线程；</li><li><strong>keepAliveTime</strong>：线程池中<strong>非核心线程闲置超时时长</strong>（准确来说应该是没有任务执行时的回收时间，后面会分析）；<ul><li>一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉</li><li>如果设置<code>allowCoreThreadTimeOut(boolean value)</code>，则会作用于核心线程</li></ul></li><li><strong>TimeUnit</strong>：时间单位。可选的单位有分钟（MINUTES），秒（SECONDS），毫秒(MILLISECONDS) 等；</li><li><strong>workQueue</strong>：任务的阻塞队列，缓存将要执行的Runnable任务，由各线程轮询该任务队列获取任务执行。可以选择以下几个阻塞队列。<ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul></li><li><strong>ThreadFactory</strong>：线程创建的工厂。可以进行一些属性设置，比如线程名，优先级等等，有默认实现。</li><li><strong>RejectedExecutionHandler</strong>：任务拒绝策略，当运行线程数已达到maximumPoolSize，队列也已经装满时会调用该参数拒绝任务，默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。<ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li><li>当然也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略。如记录日志或持久化不能处理的任务。</li></ul></li></ul><h3 id="ThreadPoolExecutor的状态变量"><a href="#ThreadPoolExecutor的状态变量" class="headerlink" title="ThreadPoolExecutor的状态变量"></a>ThreadPoolExecutor的状态变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中ctl是ThreadPoolExecutor的同步状态变量。</p><p><code>workerCountOf()</code>方法取得当前线程池的线程数量，算法是将ctl的值取低29位。</p><p><code>runStateOf()</code>方法取得线程池的状态，算法是将ctl的值取高3位:</p><ol><li>RUNNING 111   表示正在运行</li><li>SHUTDOWN 000   表示拒绝接收新的任务</li><li>STOP 001   表示拒绝接收新的任务并且不再处理任务队列中剩余的任务，并且中断正在执行的任务。</li><li>TIDYING 010   表示所有线程已停止，准备执行terminated()方法。</li><li>TERMINATED 011   表示已执行完terminated()方法。</li></ol><p>当我们向线程池提交任务时，通常使用<code>execute()</code>方法，接下来就先从该方法开始分析。</p><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><p>在分析execute代码之前，需要先说明下，我们都知道线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，<strong>线程池维护的这批线程被封装成了Worker</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//情况1</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况2</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况3</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对应了三种情况:</p><ol><li>线程池的线程数量小于corePoolSize核心线程数量，开启核心线程执行任务。</li><li>线程池的线程数量不小于corePoolSize核心线程数量，或者开启核心线程失败，尝试将任务以非阻塞的方式添加到任务队列。</li><li>任务队列已满导致添加任务失败，开启新的非核心线程执行任务。</li></ol><p><img src="/gallery/java-common/30502602-file_1494052172147_1313c.png" alt="线程池主要流程"></p><p>回顾<strong>FixedThreadPool</strong>，因为它配置的corePoolSize与maximumPoolSize相等，所以不会执行到情况3，并且因为workQueue为默认的LinkedBlockingQueue，其长度为<code>Integer.MAX_VALUE</code>，几乎不可能出现任务无法被添加到workQueue的情况，所以FixedThreadPool的所有任务执行在核心线程中。</p><p>而<strong>CachedThreadPool</strong>的corePoolSize为0，表示它不会执行到情况1，因为它的maximumPoolSize为<code>Integer.MAX_VALUE</code>，所以几乎没有线程数量上限，因为它的workQueue为SynchronousQueue，所以当线程池里没有闲置的线程SynchronousQueue就会添加任务失败，因此会执行到情况3添加新的线程执行任务。</p><p>从上面<code>execute()</code>的源码可以看出<code>addWorker()</code>方法是重中之重，马上来看下它的实现。</p><h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker()方法"></a>addWorker()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//使用CAS机制轮询线程池的状态，如果线程池处于SHUTDOWN及大于它的状态则拒绝执行任务</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CAS机制尝试将当前线程数+1</span></span><br><span class="line">        <span class="comment">//如果是核心线程当前线程数必须小于corePoolSize </span></span><br><span class="line">        <span class="comment">//如果是非核心线程则当前线程数必须小于maximumPoolSize</span></span><br><span class="line">        <span class="comment">//如果当前线程数小于线程池支持的最大线程数CAPACITY 也会返回失败</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里已经成功执行了CAS操作将线程池数量+1，下面创建线程</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">//Worker内部有一个Thread，并且执行Worker的run方法，因为Worker实现了Runnable</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里必须同步在状态为运行的情况下将Worker添加到workers中</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);  <span class="comment">//把新建的woker线程放入集合保存，这里使用的是HashSet</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果添加成功则运行线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等等</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWorker</code>这个方法先尝试在线程池运行状态为<code>RUNNING</code>并且线程数量未达上限的情况下通过CAS操作将线程池数量+1，接着在ReentrantLock同步锁的同步保证下判断线程池为运行状态，然后把Worker添加到HashSet workers中。如果添加成功则执行Worker的内部线程。</p><h3 id="Worker是什么"><a href="#Worker是什么" class="headerlink" title="Worker是什么"></a>Worker是什么</h3><p>Worker是ThreadPoolExecutor的内部类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker构造方法指定了第一个要执行的任务firstTask，并通过线程池的线程工厂创建线程。可以发现这个线程的参数为this，即Worker对象，因为Worker实现了Runnable因此可以被当成任务执行，执行的即Worker实现的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker()方法"></a>runWorker()方法</h4><p>因为Worker为ThreadPoolExecutor的内部类，因此runWorker方法实际是ThreadPoolExecutor定义的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 因为Worker的构造函数中setState(-1)禁止了中断，这里的unclock用于恢复中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//该方法是个空的实现，如果有需要用户可以自己继承该类进行实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//真正的任务执行逻辑</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//该方法是个空的实现，如果有需要用户可以自己继承该类进行实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//这里设为null，也就是循环体再执行的时候会调用getTask方法</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作</span></span><br><span class="line">        <span class="comment">//比如在corePoolSize跟maximumPoolSize之间的woker会进行回收</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是线程池复用线程的核心代码，注意Worker继承了<code>AbstractQueuedSynchronizer</code>，在执行每个任务前通过lock方法加锁，执行完后通过unlock方法解锁，这种机制用来防止运行中的任务被中断。在执行任务时先尝试获取firstTask，即构造方法传入的Runnable对象，然后尝试从<code>getTask</code>方法中获取任务队列中的任务。在任务执行前还要再次判断线程池是否已经处于STOP状态或者线程被中断。</p><p>在runWorker中，每一个Worker在<code>getTask()</code>成功之后都要获取Worker的锁之后运行，也就是说运行中的Worker不会中断。因为核心线程一般在空闲的时候会一直阻塞在获取Task上，也只有中断才可能导致其退出。这些阻塞着的Worker就是空闲的线程（当然，非核心线程阻塞之后也是空闲线程）。如果设置了keepAliveTime&gt;0，那非核心线程会在空闲状态下等待keepAliveTime之后销毁，直到最终的线程数量等于corePoolSize</p><p>woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑调用<code>processWorkerExit()</code>方法。<br><strong>注：这里只会回收corePoolSize与maximumPoolSize直接的那部分woker</strong></p><h3 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask()方法"></a>getTask()方法</h3><p>这里<code>getTask()</code>方法是要重点说明的，它的实现跟我们构造参数keepAliveTime存活时间有关。我们都知道keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。</p><p><code>getTask()</code>方法就是去阻塞队列中取任务，用户设置的存活时间，就是从这个阻塞队列中取任务等待的最大时间，如果getTask返回null，意思就是woker等待了指定时间仍然没有取到任务，此时就会跳过循环体，进入woker线程的销毁逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据超时配置有两种方法取出任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>getTask()</code>方法通过一个循环不断轮询任务队列有没有任务到来，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：</p><ol><li>BlockingQueue.poll 阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。</li><li>BlockingQueue.take 这种方法会在取到任务前一直阻塞。</li></ol><p>FixedThreadPool使用的是take方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是poll方法，也就是说CachedThreadPool中的线程如果在60秒内未获取到队列中的任务就会被终止。</p><p>到此ThreadPoolExecutor是怎么执行Runnable任务的分析结束。</p><h2 id="常用的几个线程池工厂方法"><a href="#常用的几个线程池工厂方法" class="headerlink" title="常用的几个线程池工厂方法"></a>常用的几个线程池工厂方法</h2><p><code>Executors</code>是java.util.concurrent包下的一个线程池工厂，负责创建常用的线程池，主要有如下几种:</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p> 一个固定线程数量的线程池:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//corePoolSize跟maximumPoolSize值一样，同时传入一个无界阻塞队列</span></span><br><span class="line">    <span class="comment">//根据上面分析的woker回收逻辑，该线程池的线程会维持在指定线程数，不会进行回收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定长线程池：</p><ol><li>可控制线程最大并发数（同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ol><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>不固定线程数量，且支持最大为<code>Integer.MAX_VALUE</code>的线程数量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个线程池corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">//意思也就是说来一个任务就创建一个woker，回收时间是60s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可缓存线程池：</p><ol><li>线程数无限制</li><li>有空闲线程则复用空闲线程，若无空闲线程则新建线程</li><li>一定程序减少频繁创建/销毁线程，减少系统开销</li></ol><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>可以理解为线程数量为1的FixedThreadPool:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池中只有一个线程进行任务执行，其他的都放入阻塞队列</span></span><br><span class="line">    <span class="comment">//外面包装的FinalizableDelegatedExecutorService类实现了finalize方法，在JVM垃圾回收的时候会关闭线程池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程化的线程池：</p><ol><li>有且仅有一个工作线程执行任务</li><li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li></ol><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>支持定时以指定周期循环执行任务:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中前三种线程池是ThreadPoolExecutor不同配置的实例，最后一种是ScheduledThreadPoolExecutor的实例。</p><p>最后再说说初始化线程池时线程数的选择：</p><ul><li>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</li><li>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</li></ul><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p><h2 id="线程池技术适用范围"><a href="#线程池技术适用范围" class="headerlink" title="线程池技术适用范围"></a>线程池技术适用范围</h2><p>线程池的应用范围：</p><ol><li>需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。</li><li>对性能要求苛刻的应用，比如要求服务器迅速相应客户请求。</li><li>接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，并出现”OutOfMemory”的错误。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此无论是主动提交任务给新建线程执行，还是已有的线程自己到阻塞队列取任务执行，都应该清楚了然了。<br>从数据结构的角度来看，线程池主要使用了阻塞队列（BlockingQueue）和HashSet集合构成。<br>从任务提交的流程角度来看，对于使用线程池的外部来说，线程池的机制是这样的：</p><ol><li>如果正在运行的线程数 &lt; coreSize，马上创建线程执行该task，不排队等待；</li><li>如果正在运行的线程数 &gt;= coreSize，把该task放入阻塞队列；</li><li>如果队列已满 &amp;&amp; 正在运行的线程数 &lt; maximumPoolSize，创建新的线程执行该task；</li><li>如果队列已满 &amp;&amp; 正在运行的线程数 &gt;= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。</li></ol><p>从worker线程自己的角度来看，当worker的task执行结束之后，循环从阻塞队列中取出任务执行。</p><p><img src="/gallery/java-common/10523759-file_1494053473005_d83a.png" alt="ThreadPoolExecutor执行的流程图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/" target="_blank" rel="noopener">线程池，这一篇或许就够了</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/l-threadPool/" target="_blank" rel="noopener">线程池的介绍及简单实现</a></li><li><a href="https://www.jianshu.com/p/87bff5cc8d8c" target="_blank" rel="noopener">深入分析java线程池的实现原理</a></li><li><a href="http://blog.csdn.net/fuyuwei2015/article/details/72758179" target="_blank" rel="noopener">Java线程池(ThreadPoolExecutor)原理分析与使用</a></li><li><a href="https://www.jianshu.com/p/9d03bf5ed5cd" target="_blank" rel="noopener">Java线程池原理分析ThreadPoolExecutor篇</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-concurrency/executor.html" target="_blank" rel="noopener">并发新特性—Executor 框架与线程池</a></li><li><a href="http://www.importnew.com/19011.html" target="_blank" rel="noopener">深入理解Java之线程池</a></li><li><a href="https://www.zhihu.com/question/38128980" target="_blank" rel="noopener">java线程池大小为何会大多被设置成CPU核心数+1？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;线程池：可以理解为缓冲区，由于频繁的创建销毁线程会带来一定的成本，可以预先创建但不立即销毁，以共享方式为别人提供服务，一来可以提供效率，再者可以控制线程无线扩张。合理利用线程池能够带来三个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是要做到合理的利用线程池，必须对其原理了如指掌。&lt;/p&gt;
&lt;h2 id=&quot;线程的几种状态&quot;&gt;&lt;a href=&quot;#线程的几种状态&quot; class=&quot;headerlink&quot; title=&quot;线程的几种状态&quot;&gt;&lt;/a&gt;&lt;strong&gt;线程的几种状态&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;线程在一定条件下，状态会发生变化。根据&lt;a href=&quot;https://my.oschina.net/cctester/blog/991744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线程的几种状态&lt;/a&gt;这篇文章，线程一共有以下几种状态：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、新建状态(New)&lt;/strong&gt;：新创建了一个线程对象。&lt;br&gt;&lt;strong&gt;2、就绪状态(Runnable)&lt;/strong&gt;：线程对象创建后，其他线程调用了该对象的&lt;code&gt;start()&lt;/code&gt;方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，即&lt;strong&gt;在就绪状态的线程除CPU之外，其它的运行所需资源都已全部获得。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3、运行状态(Running)&lt;/strong&gt;：就绪状态的线程获取了CPU，执行程序代码。&lt;br&gt;&lt;strong&gt;4、阻塞状态(Blocked)&lt;/strong&gt;：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①. 等待阻塞：运行的线程执行&lt;code&gt;wait()&lt;/code&gt;方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的必须依靠其他线程调用&lt;code&gt;notify()&lt;/code&gt;或&lt;code&gt;notifyAll()&lt;/code&gt;方法才能被唤醒。&lt;/li&gt;
&lt;li&gt;②. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。&lt;/li&gt;
&lt;li&gt;③. 其他阻塞：运行的线程执行&lt;code&gt;sleep()&lt;/code&gt;或&lt;code&gt;join()&lt;/code&gt;方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当&lt;code&gt;sleep()&lt;/code&gt;状态超时、&lt;code&gt;join()&lt;/code&gt;等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5、死亡状态(Dead)&lt;/strong&gt;：线程执行完了或者因异常退出了&lt;code&gt;run()&lt;/code&gt;方法，该线程结束生命周期。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【Android】OkHttp源码分析</title>
    <link href="https://itimetraveler.github.io/2018/01/25/%E3%80%90Android%E3%80%91OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://itimetraveler.github.io/2018/01/25/【Android】OkHttp源码分析/</id>
    <published>2018-01-25T14:20:55.000Z</published>
    <updated>2018-03-14T08:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android为我们提供了两种HTTP交互的方式：<a href="https://developer.android.com/reference/java/net/HttpURLConnection.html" target="_blank" rel="noopener">HttpURLConnection</a> 和 Apache HttpClient，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP 可以让您的应用运行更快、更节省流量。而<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>库就是为此而生。在开始分析OkHttp之前我们先了解一下 HttpURLConnection 和 HttpClient 两者之间关系，以及它们和 OkHttp 之间的关系。</p><h2 id="HttpClient-vs-HttpURLConnection"><a href="#HttpClient-vs-HttpURLConnection" class="headerlink" title="HttpClient vs HttpURLConnection"></a>HttpClient vs HttpURLConnection</h2><p>在Android API Level 9（Android 2.2）之前只能使用<code>HttpClient</code>类发送http请求。<code>HttpClient</code>是Apache用于发送http请求的客户端，其提供了强大的API支持，而且基本没有什么bug，但是由于其太过复杂，Android团队在保持向后兼容的情况下，很难对<code>DefaultHttpClient</code>进行增强。为此，Android团队从Android API Level 9开始自己实现了一个发送http请求的客户端类 —— <code>HttpURLConnection</code>。</p><p>相比于<code>DefaultHttpClient</code>，<code>HttpURLConnection</code>比较轻量级，虽然功能没有<code>DefaultHttpClient</code>那么强大，但是能够满足大部分的需求，所以Android推荐使用<code>HttpURLConnection</code>代替<code>DefaultHttpClient</code>，并不强制使用<code>HttpURLConnection</code>。</p><p><strong>但从Android API Level 23（Android 6.0）开始，不能再在Android中使用<code>HttpClient</code></strong>，强制使用<code>HttpURLConnection</code>。参考官网：<a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="noopener">Android 6.0 Changes - Google Developer</a></p><blockquote><p>Android 6.0 版移除了对 Apache HTTP client的支持。如果您的应用使用该客户端，并以 Android 2.3（API level 9）或更高版本为目标平台，请改用 <code>HttpURLConnection</code> 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 <code>build.gradle</code> 文件中声明以下编译时依赖项：</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li><p><strong>HttpURLConnection</strong> </p><p>在Android2.2之前：HttpURLConnection 有个重大 Bug：调用 close() 函数会影响连接池,导致连接复用失效；所以<strong>Android2.2之前不建议使用HttpURLConnection</strong>。在Android2.2之后：HttpURLConnection默认开启了 gzip 压缩&amp;提高了HTTPS 的性能</p></li><li><p><strong>HttpClient</strong> </p><p>优点：相比于HttpURLConnection，更加高效简洁<br>缺点：结构过于复杂；维护成本高</p><blockquote><p>在5.0版本后被Android官方弃用</p></blockquote></li></ul><p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。OkHttp是一个相对成熟的解决方案，我们跟踪这篇文章：<a href="http://blog.csdn.net/charon_chui/article/details/46895773" target="_blank" rel="noopener">Android HttpURLConnection源码分析</a>。就会发现Android4.4之后的HttpURLConnection其实是基于<code>OkHttp</code>实现的。所以我们更有理由相信OkHttp的强大。</p><h3 id="二者与网络请求库之间的关系"><a href="#二者与网络请求库之间的关系" class="headerlink" title="二者与网络请求库之间的关系"></a>二者与网络请求库之间的关系</h3><p>网络请求框架本质上是一个将网络请求的相关方法（ HttpClient或HttpURLConnection）封装好的类库，并实现另开线程进行请求和处理数据，从而实现整个网络请求模块的功能。具体的关系可看下图: </p><p><img src="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/20160810152440105.jpg" alt=""></p><p>而<code>OkHttp</code>是基于http协议封装的一套请求客户端，虽然它也可以开线程，但根本上它更偏向真正的请求，跟<code>HttpClient</code>，<code>HttpUrlConnection</code>的职责是一样的。</p><h2 id="OkHttp简介"><a href="#OkHttp简介" class="headerlink" title="OkHttp简介"></a>OkHttp简介</h2><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a> 库的设计和实现的首要目标是高效。这也是选择 OkHttp 的重要理由之一。OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持，这使得对同一个主机发出的所有请求都可以共享相同的Socket连接。如果 HTTP/2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提高效率。OkHttp 提供了对 GZIP 的默认支持来降低传输内容的大小。OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求。当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址。</p><p>OkHttp是一个高效的HTTP库：</p><blockquote><ul><li>支持 HTTP/2和SPDY ，共享同一个Socket来处理同一个服务器的所有请求</li><li>如果 HTTP/2和SPDY 不可用，则通过连接池来减少请求延时</li><li>无缝的支持GZIP来减少数据流量</li><li>缓存响应数据来减少重复的网络请求</li></ul></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>OkHttp的使用是比较简单的，整体步骤是：</p><ol><li>初始化 OkHttpClient</li><li>初始化一个 Request</li><li>由 OkHttpClient 和 Request 生成一个 Call</li><li>Call 调用 enqueue （异步）或者 execute 方法（同步）</li></ol><h3 id="同步Get请求"><a href="#同步Get请求" class="headerlink" title="同步Get请求"></a>同步Get请求</h3><p>这是OkHttp 最基本的 HTTP 请求，注意别放到UI线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 初始化OkHttpClient</span></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 初始化一个Request</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">                .header(<span class="string">"User-Agent"</span>, <span class="string">"My super agent"</span>)</span><br><span class="line">                .addHeader(<span class="string">"Accept"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 由OkHttpClient和Request生成一个Call</span></span><br><span class="line">        <span class="comment">//4. call调用enqueue或者execute</span></span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"服务器端错误: "</span> + response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Headers responseHeaders = response.headers();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步Get请求"><a href="#异步Get请求" class="headerlink" title="异步Get请求"></a>异步Get请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Call 调用 enqueue 方法</span></span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"服务器端错误: "</span> + response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p>HTTP POST 和 PUT 请求可以包含要提交的内容。只需要在创建 <code>Request</code> 对象时，通过 <code>post()</code> 和 <code>put()</code> 方法来指定要提交的内容即可。下面的代码通过 <code>RequestBody</code> 的 <code>create()</code> 方法来创建媒体类型为<strong>application/ json</strong> 的内容并提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">//post请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .post(body)</span><br><span class="line">            .build();</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的使用方法可以参考IBM的这篇文章：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-okhttp/" target="_blank" rel="noopener">OkHttp：Java平台上的新一代HTTP客户端</a> ，下面我们转入源码的分析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们从创建 <code>OkHttpClient</code> 对象开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></figure><h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>看看其构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是方便我们使用，提供了一个“快捷操作”，全部使用了默认的配置。<code>OkHttpClient.Builder</code> 类成员很多，后面我们再慢慢分析，这里先暂时略过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient.java类中</span></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher; <span class="comment">// 分发器</span></span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy; <span class="comment">// 代理</span></span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols; <span class="comment">// 协议</span></span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors); <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors); <span class="comment">// 网络拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector; <span class="comment">// 代理选择</span></span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar; <span class="comment">// cookie</span></span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache; <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">    isTLS = isTLS || spec.isTls();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    X509TrustManager trustManager = systemDefaultTrustManager();</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool; <span class="comment">// 连接复用池</span></span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout; <span class="comment">// 连接超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout; <span class="comment">// 读取超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout; <span class="comment">// 写入超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，如果你还不明白的话，也没关系，在<code>OkHttp</code>中只是设置用的的各个东西。</p><p>真正的流程要从里面的<code>newCall()</code>方法中说起，因为我们使用OkHttp发起 HTTP 请求的方式一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起同步请求</span></span><br><span class="line">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure><p>当通过<strong>建造者模式</strong>创建了<code>Request</code>之后（这个没什么好说），紧接着就通过<code>client.newCall(request).execute()</code>来获得<code>Response</code>。这句代码就开启了整个GET请求的流程：</p><p>那我们现在就来看看它是如何通过<code>newCall()</code>创建 Call 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>在这里再多说一下关于Call这个类的作用，<strong>OkHttp 使用调用（Call）来对发送 HTTP 请求和获取响应的过程进行抽象。</strong>在Call中持有一个HttpEngine。每一个不同的Call都有自己独立的HttpEngine。在HttpEngine中主要是各种链路和地址的选择，还有一个Transport比较重要。<code>Call</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OkHttpClient</code> 实现了 <code>Call.Factory</code>，负责根据请求创建新的 <code>Call</code>。</p><blockquote><p><code>CallFactory</code> 负责创建 HTTP 请求，HTTP 请求被抽象为了 <code>okhttp3.Call</code> 类，它表示一个已经准备好，可以随时执行的 HTTP 请求</p></blockquote><h3 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h3><p>RealCall是<code>Call</code>接口的实现，我们继续接着上面看RealCall的<code>newRealCall()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line"><span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.client = client;</span><br><span class="line"><span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line"><span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line"><span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是通过构造函数new了一个<code>RealCall</code>对象，构造函数如下，不用看很细，略过。我们<strong>重点看看 <code>RealCall#execute</code></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall类中</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//1. 每个Call只能被执行一次。如果该 call 已经被执行过了，就设置 executed 为 true</span></span><br><span class="line"><span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">executed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">captureCallStackTrace();</span><br><span class="line">eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//2. 加入 runningSyncCalls 队列中</span></span><br><span class="line">client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//3. 得到响应 result</span></span><br><span class="line">Response result = getResponseWithInterceptorChain();</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//4. 从 runningSyncCalls 队列中移除</span></span><br><span class="line">client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们做了 4 件事：</p><ol><li>检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 <code>call#clone</code> 方法进行克隆。</li><li>利用 <code>client.dispatcher().executed(this)</code> 来进行实际执行，<code>dispatcher</code> 是刚才看到的 <code>OkHttpClient.Builder</code> 的成员之一，它的文档说自己是异步 HTTP 请求的执行策略，现在看来，同步请求它也有掺和。</li><li>调用 <code>getResponseWithInterceptorChain()</code> 函数获取 HTTP 返回结果，从函数名可以看出，这一步还会进行一系列“拦截”操作。</li><li>最后还要通知 <code>dispatcher</code> 自己已经执行完毕。</li></ol><p><code>dispatcher</code> 这里我们不过度关注，在同步执行的流程中，涉及到 dispatcher 的内容只不过是告知它我们的执行状态，比如开始执行了（调用 <code>executed</code>），比如执行完毕了（调用 <code>finished</code>），在异步执行流程中它会有更多的参与。</p><p>真正发出网络请求，解析返回结果的，还是 <code>getResponseWithInterceptorChain</code>。我们可以看到这方法是直接返回 <code>Response</code> 对象的，所以，在这个方法中一定做了很多很多的事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall类中</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());    <span class="comment">// 加入用户自定义的拦截器</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);   <span class="comment">// 重试和重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));  <span class="comment">// 加入转化请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));  <span class="comment">// 加入缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));  <span class="comment">// 加入连接拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());   <span class="comment">// 加入用户自定义的网络拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));   <span class="comment">// 加入发出请求和读取响应的拦截器</span></span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://publicobject.com/2016/07/03/the-last-httpurlconnection/" target="_blank" rel="noopener">OkHttp 开发者之一介绍 OkHttp 的文章</a>里面，作者讲到：</p><blockquote><p>the whole thing is just a stack of built-in interceptors.</p></blockquote><p>可见 <code>Interceptor</code> 是 OkHttp 最核心的一个东西，不要误以为它只负责拦截请求进行一些额外的处理（例如 cookie），<strong>实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来</strong>，每一个功能都只是一个 <code>Interceptor</code>，它们再连接成一个 <code>Interceptor.Chain</code>，环环相扣，最终圆满完成一次网络请求。</p><p>从 <code>getResponseWithInterceptorChain</code> 函数我们可以看到，<code>Interceptor.Chain</code> 的分布依次是：</p><p><img src="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/okhttp_interceptors-details.png" alt=""></p><ol><li><code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；</li><li><strong>RetryAndFollowUpInterceptor</strong> ：是用来重试和重定向的拦截器，在下面我们会讲到；</li><li><strong>BridgeInterceptor</strong>：是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；</li><li><strong>CacheInterceptor</strong>：是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；</li><li><strong>ConnectInterceptor</strong>：用来建立连接的拦截器；</li><li><code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ;</li><li><strong>CallServerInterceptor</strong>：是真正向服务器发出请求且得到响应的拦截器；</li></ol><p>在这里，位置决定了功能，最后一个 Interceptor 一定是负责和服务器实际通讯的，重定向、缓存等一定是在实际通讯之前的。</p><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">责任链模式</a>在这个 <code>Interceptor</code> 链条中得到了很好的实践。</p><blockquote><p><strong>责任链模式</strong>在<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener">面向对象程式设计</a>里是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">软件设计模式</a>，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</p></blockquote><p>另外参考文章：<a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/tree/master/chain-of-responsibility/AigeStudio#android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">Android设计模式之责任链模式</a>中相关的分析：</p><blockquote><p>Android中关于责任链模式比较明显的体现就是在事件分发过程中对事件的投递，其实严格来说，事件投递的模式并不是严格的责任链模式，但是其是责任链模式的一种变种体现。</p></blockquote><p>对于把 <code>Request</code> 变成 <code>Response</code> 这件事来说，每个 <code>Interceptor</code> 都可能完成这件事，所以我们循着链条让每个 <code>Interceptor</code> 自行决定能否完成任务以及怎么完成任务（自力更生或者交给下一个 <code>Interceptor</code>）。这样一来，完成网络请求这件事就彻底从 <code>RealCall</code> 类中剥离了出来，简化了各自的责任和逻辑。</p><p>最后在聚合了这些拦截器之后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器。</p><h3 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h3><p><code>RealInterceptorChain</code> 可以说是真正把这些拦截器串起来的一个角色。一个个拦截器就像一颗颗珠子，而 <code>RealInterceptorChain</code>就是把这些珠子串连起来的那根绳子。</p><p>进入 <code>RealInterceptorChain</code> ，主要是 <code>proceed()</code> 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">  RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">calls++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">      + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">      + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到下一次对应的 RealInterceptorChain</span></span><br><span class="line"><span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">    connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">    writeTimeout);</span><br><span class="line"><span class="comment">// 当前的 interceptor</span></span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line"><span class="comment">// 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法</span></span><br><span class="line">Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line"><span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">      + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line"><span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中是一次次链式调用拦截器，</p><ol><li>下一个拦截器对应的<code>RealIterceptorChain</code>对象，这个对象会传递给当前的拦截器</li><li>得到当前的拦截器：interceptors是存放拦截器的ArryList</li><li>调用当前拦截器的<code>intercept()</code>方法，并将下一个拦截器的<code>RealIterceptorChain</code>对象传递下去</li></ol><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/20170722185657.png" alt=""></p><p>下面根据上面的责任链我们逐个分析一下对应的拦截器<code>Interceptor</code>。</p><h3 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h3><p>拦截器是 OkHttp 提供的对 HTTP 请求和响应进行统一处理的强大机制。拦截器在实现和使用上类似于 Servlet 规范中的过滤器。多个拦截器可以链接起来，形成一个链条。拦截器会按照在链条上的顺序依次执行。 拦截器在执行时，可以先对请求的 <code>Request</code> 对象进行修改；再得到响应的 <code>Response</code> 对象之后，可以进行修改之后再返回。</p><p>拦截器<code>Interceptor</code>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line"><span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the connection the request will be executed on. This is only available in the chains</span></span><br><span class="line"><span class="comment"> * of network interceptors; for application interceptors this is always null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了在client中自定义设置的interceptor,第一个调用的就是<code>RetryAndFollowUpInterceptor</code></strong>。</p><h4 id="RetryAndFollowUpInterceptor（重试和重定向拦截器）"><a href="#RetryAndFollowUpInterceptor（重试和重定向拦截器）" class="headerlink" title="RetryAndFollowUpInterceptor（重试和重定向拦截器）"></a>RetryAndFollowUpInterceptor（重试和重定向拦截器）</h4><p>我们着重看看它的<code>intercept()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()),</span><br><span class="line">        call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果取消，就释放资源</span></span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">        response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="comment">// 路由连接失败，请求将不会被发送</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="comment">// 服务器连接失败，请求可能已被发送</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">        <span class="comment">// 抛出未检查的异常，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(<span class="keyword">null</span>)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不需要重定向，那么 followUp 为空，会根据响应码判断</span></span><br><span class="line">      Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 释放资源，返回 response</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭 response 的 body</span></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 比较response 和 followUp 是否为同一个连接</span></span><br><span class="line">      <span class="comment">// 若为重定向就销毁旧连接，创建新连接</span></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">            createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将重定向操作得到的新请求设置给 request</span></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p><h4 id="BridgeInterceptor（请求构造拦截器）"><a href="#BridgeInterceptor（请求构造拦截器）" class="headerlink" title="BridgeInterceptor（请求构造拦截器）"></a>BridgeInterceptor（请求构造拦截器）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户友好的 request 构造为发送给服务器的 request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">// 若有请求体，则构造</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="comment">// 使用 gzip 压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UA: User-Agent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    <span class="comment">// 保存 networkResponse 的 cookie</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    <span class="comment">// 将 networkResponse 转换为对用户友好的 response</span></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>BridgeInterceptor</code> 这一步，</p><ul><li>先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</li><li>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</li><li>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</li></ul><h4 id="CacheInterceptor（缓存拦截器）"><a href="#CacheInterceptor（缓存拦截器）" class="headerlink" title="CacheInterceptor（缓存拦截器）"></a>CacheInterceptor（缓存拦截器）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从缓存中查找 request 对应的 response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间，会和之前缓存的时间进行比较</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪缓存，其实就是计数</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存未命中，关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 禁止网络并且没有缓存的话，返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 命中缓存。且不需要网络请求更新，返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 交给下一个拦截器，返回 networkResponse</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 如果我们同时有缓存和 networkResponse ，根据情况使用</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新原来的缓存至最新</span></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前从未进行缓存，保存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p><h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 创建 httpCodec （抽象类），分别对应着 http1.1 和 http 2</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交给下一个拦截器，得到返回的 Response</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上建立连接就是调用了 <code>streamAllocation.newStream</code> 创建了一个 <code>HttpCodec</code> 对象，它将在后面的步骤中被使用，那它又是何方神圣呢？它是对 HTTP 协议操作的抽象，有两个实现：<code>Http1Codec</code> 和 <code>Http2Codec</code>，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。</p><p>在 <code>Http1Codec</code> 中，它利用 <a href="https://github.com/square/okio/" target="_blank" rel="noopener">Okio</a> 对 <code>Socket</code> 的读写操作进行封装，Okio 以后有机会再进行分析，现在让我们对它们保持一个简单地认识：它对 <code>java.io</code> 和 <code>java.nio</code> 进行了封装，让我们更便捷高效的进行 IO 操作。</p><p>而创建 <code>HttpCodec</code> 对象的过程涉及到 <code>StreamAllocation</code>、<code>RealConnection</code>，代码较长，这里就不展开，这个过程概括来说，就是找到一个可用的 <code>RealConnection</code>，再利用 <code>RealConnection</code> 的输入输出（<code>BufferedSource</code> 和 <code>BufferedSink</code>）创建 <code>HttpCodec</code> 对象，供后续步骤使用。</p><p>我们来看下 <code>streamAllocation.newStream()</code> 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于StreamAllocation类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在连接池中找到一个可用的连接，然后创建出 HttpCodec 对象</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        codec = resultCodec;</span><br><span class="line">        <span class="keyword">return</span> resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>findHealthyConnection()</code>：先在连接池中找到可用的连接 <code>resultConnection</code> 。<br>  这一步会使用<code>Platform.get().connectSocket()</code>创建TCP连接，完成三次握手。</li><li><p><code>resultConnection.newCodec()</code>：再结合 <code>sink</code> 和 <code>source</code> 创建出 <code>HttpCodec</code> 的对象。</p><p><code>HttpCodec</code> 负责对HTTP请求和响应进行编解码。注释如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Encodes HTTP requests and decodes HTTP responses. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpCodec</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">    <span class="comment">// 整理请求头并写入</span></span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 检查是否为有 body 的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">      <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">      <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">        httpCodec.flushRequest();</span><br><span class="line">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">        <span class="comment">// 写入请求体 request body</span></span><br><span class="line">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">        <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">        CountingSink requestBodyOut =</span><br><span class="line">            <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">        realChain.eventListener()</span><br><span class="line">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">        <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">        <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">        <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 得到响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    realChain.eventListener()</span><br><span class="line">        .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">// 如果为 web socket 且状态码是 101 ，那么 body 为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取 body</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(httpCodec.openResponseBody(response))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中有 close 那么断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p><p>上面的流程我们抓住主干部分：</p><ol><li>向服务器发送 request header；</li><li>如果有 request body，就向服务器发送；</li><li>读取 response header，先构造一个 <code>Response</code> 对象；</li><li>如果有 response body，就在 3 的基础上加上 body 构造一个新的 <code>Response</code> 对象；</li></ol><p>这里我们可以看到，核心工作都由 <code>HttpCodec</code> 对象完成，而 <code>HttpCodec</code> 实际上利用的是 Okio，而 Okio 实际上还是用的 <code>Socket</code>，所以没什么神秘的，只不过一层套一层，层数有点多。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>其实 <code>Interceptor</code> 的设计也是一种分层的思想，每个 <code>Interceptor</code> 就是一层。为什么要套这么多层呢？分层的思想在 TCP/IP 协议中就体现得淋漓尽致，分层简化了每一层的逻辑，每层只需要关注自己的责任（单一原则思想也在此体现），而各层之间通过约定的接口/协议进行合作（面向接口编程思想），共同完成复杂的任务。</p><p>到这里，我们也完全明白了 OkHttp 中的分层思想，每一个 interceptor 只处理自己的事，而剩余的就交给其他的 interceptor 。这种思想可以简化一些繁琐复杂的流程，从而达到逻辑清晰、互不干扰的效果。</p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>与同步请求直接调用<strong>RealCall</strong>的 <code>execute()</code> 方法不同的是，异步请求是调用了 <code>enqueue(Callback responseCallback)</code> 这个方法。那么我们对异步请求探究的入口就是 <code>enqueue(Callback responseCallback)</code> 了。</p><h3 id="RealCall-1"><a href="#RealCall-1" class="headerlink" title="RealCall"></a>RealCall</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 加入到 dispatcher 中，这里包装成了 AsyncCall</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的方法就是调用了 <code>Dispatcher</code> 的 <code>enqueue(AsyncCall call)</code> 方法。这里需要注意的是，传入的是 <code>AsyncCall</code> 对象，而不是同步中的 <code>RealCall</code> 。</p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>我们跟进到 <code>Dispatcher</code> 的源码，至于 <code>AsyncCall</code> 我们会在下面详细讲到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前正在运行的异步 call 数 &lt; 64 &amp;&amp; 队列中请求同一个 host 的异步 call 数 &lt; 5</span></span><br><span class="line">    <span class="comment">// maxRequests = 64，maxRequestsPerHost = 5</span></span><br><span class="line"><span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      <span class="comment">// 加入正在运行异步队列</span></span><br><span class="line">  runningAsyncCalls.add(call);</span><br><span class="line">      <span class="comment">// 加入到线程池中</span></span><br><span class="line">  executorService().execute(call);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 加入预备等待的异步队列</span></span><br><span class="line">  readyAsyncCalls.add(call);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>enqueue(AsyncCall call)</code> 中可以知道，OkHttp 在运行中的异步请求数最多为 63 ，而同一个 host 的异步请求数最多为 4 。否则会加入到 <code>readyAsyncCalls</code> 中。</p><p>在加入到 <code>runningAsyncCalls</code> 后，就会进入线程池中被执行。到了这里，我们就要到 <code>AsyncCall</code> 中一探究竟了。</p><h3 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h3><p><code>AsyncCall</code>是<strong>RealCall</strong>类中的内部类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">        <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用一连串的拦截器，得到响应</span></span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调结果</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 runningAsyncCalls 中移除，并推进其他 call 的工作</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p><p>在得到 <code>Response</code> 后，进行结果的回调。最后，调用了 <code>Dispatcher</code> 的 <code>finished</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall.AsyncCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除该 call</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="comment">// 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中</span></span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OkHttp 作为一个简洁高效的 HTTP 客户端，可以在 Java 和 Android 程序中使用。相对于 Apache HttpClient 来说，OkHttp 的性能更好，其 API 设计也更加简单实用。</p><p>在文章最后我们再来回顾一下完整的流程图：</p><p><img src="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/okhttp_full_process.png" alt=""></p><ul><li><code>OkHttpClient</code> 实现 <code>Call.Factory</code>，负责为 <code>Request</code> 创建 <code>Call</code>；</li><li><code>RealCall</code> 为具体的 <code>Call</code> 实现，其 <code>enqueue()</code> 异步接口通过 <code>Dispatcher</code> 利用 <code>ExecutorService</code> 实现，而最终进行网络请求时和同步 <code>execute()</code> 接口一致，都是通过 <code>getResponseWithInterceptorChain()</code> 函数实现；</li><li><code>getResponseWithInterceptorChain()</code> 中利用 <code>Interceptor</code> 链条，分层实现重试重定向、缓存、透明压缩、网络 IO 等功能；</li></ul><h2 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h2><p>虽然在使用 OkHttp 发送 HTTP 请求时只需要提供 URL 即可，OkHttp 在实现中需要综合考虑 3 种不同的要素来确定与 HTTP 服务器之间实际建立的 HTTP 连接。这样做的目的是为了达到最佳的性能。</p><p>首先第一个考虑的要素是 URL 本身。URL 给出了要访问的资源的路径。比如 URL <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 所对应的是百度首页的 HTTP 文档。在 URL 中比较重要的部分是访问时使用的模式，即 HTTP 还是 HTTPS。这会确定 OkHttp 所建立的是明文的 HTTP 连接，还是加密的 HTTPS 连接。</p><p>第二个要素是 HTTP 服务器的地址，如 baidu.com。每个地址都有对应的配置，包括端口号，HTTPS 连接设置和网络传输协议。同一个地址上的 URL 可以共享同一个底层 TCP 套接字连接。通过共享连接可以有显著的性能提升。OkHttp 提供了一个连接池来复用连接。</p><p>第三个要素是连接 HTTP 服务器时使用的路由。路由包括具体连接的 IP 地址（通过 DNS 查询来发现）和所使用的代理服务器。对于 HTTPS 连接还包括通讯协商时使用的 TLS 版本。对于同一个地址，可能有多个不同的路由。OkHttp 在遇到访问错误时会自动尝试备选路由。</p><p>当通过 OkHttp 来请求某个 URL 时，OkHttp 首先从 URL 中得到地址信息，再从连接池中根据地址来获取连接。如果在连接池中没有找到连接，则选择一个路由来尝试连接。尝试连接需要通过 DNS 查询来得到服务器的 IP 地址，也会用到代理服务器和 TLS 版本等信息。当实际的连接建立之后，OkHttp 发送 HTTP 请求并获取响应。当连接出现问题时，OkHttp 会自动选择另外的路由进行尝试。这使得 OkHttp 可以自动处理可能出现的网络问题。当成功获取到 HTTP 请求的响应之后，当前的连接会被放回到连接池中，提供给后续的请求来复用。连接池会定期把闲置的连接关闭以释放资源。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://blog.csdn.net/a109340/article/details/73887753" target="_blank" rel="noopener">OkHttp的初始化</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html" target="_blank" rel="noopener">OKHttp源码解析</a></li><li><a href="https://juejin.im/entry/597800116fb9a06baf2eeb63" target="_blank" rel="noopener">OkHttp源码解析</a> - <a href="https://link.juejin.im/?target=http%3A%2F%2Fyuqirong.me%2F2017%2F07%2F25%2FOkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F" target="_blank" rel="noopener">yuqirong.me</a></li><li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">拆轮子系列：拆OkHttp</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-okhttp/" target="_blank" rel="noopener">OkHttp：Java 平台上的新一代 HTTP 客户端 - IBM DeveloperWorks</a></li><li><a href="http://blog.csdn.net/carson_ho/article/details/52171976" target="_blank" rel="noopener">Android主流网络请求开源库的对比（Android-Async-Http、Volley、OkHttp、Retrofit）</a></li><li><a href="https://www.jianshu.com/p/77d418e7b5d6" target="_blank" rel="noopener">OkHttp, Retrofit, Volley应该选择哪一个？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android为我们提供了两种HTTP交互的方式：&lt;a href=&quot;https://developer.android.com/reference/java/net/HttpURLConnection.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HttpURLConnection&lt;/a&gt; 和 Apache HttpClient，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP 可以让您的应用运行更快、更节省流量。而&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OkHttp&lt;/a&gt;库就是为此而生。在开始分析OkHttp之前我们先了解一下 HttpURLConnection 和 HttpClient 两者之间关系，以及它们和 OkHttp 之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;HttpClient-vs-HttpURLConnection&quot;&gt;&lt;a href=&quot;#HttpClient-vs-HttpURLConnection&quot; class=&quot;headerlink&quot; title=&quot;HttpClient vs HttpURLConnection&quot;&gt;&lt;/a&gt;HttpClient vs HttpURLConnection&lt;/h2&gt;&lt;p&gt;在Android API Level 9（Android 2.2）之前只能使用&lt;code&gt;HttpClient&lt;/code&gt;类发送http请求。&lt;code&gt;HttpClient&lt;/code&gt;是Apache用于发送http请求的客户端，其提供了强大的API支持，而且基本没有什么bug，但是由于其太过复杂，Android团队在保持向后兼容的情况下，很难对&lt;code&gt;DefaultHttpClient&lt;/code&gt;进行增强。为此，Android团队从Android API Level 9开始自己实现了一个发送http请求的客户端类 —— &lt;code&gt;HttpURLConnection&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相比于&lt;code&gt;DefaultHttpClient&lt;/code&gt;，&lt;code&gt;HttpURLConnection&lt;/code&gt;比较轻量级，虽然功能没有&lt;code&gt;DefaultHttpClient&lt;/code&gt;那么强大，但是能够满足大部分的需求，所以Android推荐使用&lt;code&gt;HttpURLConnection&lt;/code&gt;代替&lt;code&gt;DefaultHttpClient&lt;/code&gt;，并不强制使用&lt;code&gt;HttpURLConnection&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但从Android API Level 23（Android 6.0）开始，不能再在Android中使用&lt;code&gt;HttpClient&lt;/code&gt;&lt;/strong&gt;，强制使用&lt;code&gt;HttpURLConnection&lt;/code&gt;。参考官网：&lt;a href=&quot;https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 6.0 Changes - Google Developer&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Android 6.0 版移除了对 Apache HTTP client的支持。如果您的应用使用该客户端，并以 Android 2.3（API level 9）或更高版本为目标平台，请改用 &lt;code&gt;HttpURLConnection&lt;/code&gt; 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 &lt;code&gt;build.gradle&lt;/code&gt; 文件中声明以下编译时依赖项：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    useLibrary &lt;span class=&quot;string&quot;&gt;&#39;org.apache.http.legacy&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://itimetraveler.github.io/categories/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://itimetraveler.github.io/tags/Android/"/>
    
      <category term="源码分析" scheme="https://itimetraveler.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>用Java实现断点续传 (HTTP)</title>
    <link href="https://itimetraveler.github.io/2018/01/22/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%20(HTTP)/"/>
    <id>https://itimetraveler.github.io/2018/01/22/用Java实现断点续传 (HTTP)/</id>
    <published>2018-01-22T04:30:55.000Z</published>
    <updated>2018-03-14T08:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="断点续传的原理"><a href="#断点续传的原理" class="headerlink" title="断点续传的原理"></a>断点续传的原理</h3><p>其实断点续传的原理很简单，就是在 Http 的请求上和一般的下载有所不同而已。<br>打个比方，浏览器请求服务器上的一个文时，所发出的请求如下：<br>假设服务器域名为 <a href="www.sjtu.edu.cn">www.sjtu.edu.cn</a>，文件名为 down.zip。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /down.zip HTTP/1.1 </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms- </span><br><span class="line">excel, application/msword, application/vnd.ms-powerpoint, */* </span><br><span class="line">Accept-Language: zh-cn </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0) </span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>服务器收到请求后，按要求寻找请求的文件，提取文件的信息，然后返回给浏览器，返回信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 </span><br><span class="line">Content-Length=106786028 </span><br><span class="line">Accept-Ranges=bytes </span><br><span class="line">Date=Mon, 30 Apr 2001 12:56:11 GMT </span><br><span class="line">ETag=W/&quot;02ca57e173c11:95b&quot; </span><br><span class="line">Content-Type=application/octet-stream </span><br><span class="line">Server=Microsoft-IIS/5.0 </span><br><span class="line">Last-Modified=Mon, 30 Apr 2001 12:56:11 GMT</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给 Web 服务器的时候要多加一条信息 – 从哪里开始。<br>下面是用自己编的一个”浏览器”来传递请求信息给 Web 服务器，要求从 2000070 字节开始。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /down.zip HTTP/1.0 </span><br><span class="line">User-Agent: NetFox </span><br><span class="line">RANGE: bytes=2000070- </span><br><span class="line">Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2</span><br></pre></td></tr></table></figure><p>仔细看一下就会发现多了一行 <code>RANGE: bytes=2000070-</code><br>这一行的意思就是告诉服务器 down.zip 这个文件从 2000070 字节开始传，前面的字节不用传了。<br>服务器收到这个请求以后，返回的信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">206 </span><br><span class="line">Content-Length=106786028 </span><br><span class="line">Content-Range=bytes 2000070-106786027/106786028 </span><br><span class="line">Date=Mon, 30 Apr 2001 12:55:20 GMT </span><br><span class="line">ETag=W/&quot;02ca57e173c11:95b&quot; </span><br><span class="line">Content-Type=application/octet-stream </span><br><span class="line">Server=Microsoft-IIS/5.0 </span><br><span class="line">Last-Modified=Mon, 30 Apr 2001 12:55:20 GMT</span><br></pre></td></tr></table></figure></p><p>和前面服务器返回的信息比较一下，就会发现增加了一行： <code>Content-Range=bytes 2000070-106786027/106786028</code>，返回的代码也改为 206 了，而不再是 200 了。</p><p>知道了以上原理，就可以进行断点续传的编程了。</p><h3 id="Java-实现断点续传的关键几点"><a href="#Java-实现断点续传的关键几点" class="headerlink" title="Java 实现断点续传的关键几点"></a>Java 实现断点续传的关键几点</h3><ol><li><p><strong>用什么方法实现提交<code>RANGE: bytes=2000070-</code></strong></p><p>当然用最原始的 Socket 是肯定能完成的，不过那样太费事了，其实 Java 的 net 包中提供了这种功能。代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.sjtu.edu.cn/down.zip"</span>);</span><br><span class="line"></span><br><span class="line">HttpURLConnection httpConnection = (HttpURLConnection)url.openConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 User-Agent</span></span><br><span class="line">httpConnection.setRequestProperty(<span class="string">"User-Agent"</span>,<span class="string">"NetFox"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置断点续传的开始位置</span></span><br><span class="line">httpConnection.setRequestProperty(<span class="string">"RANGE"</span>,<span class="string">"bytes=2000070"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得输入流</span></span><br><span class="line">InputStream input = httpConnection.getInputStream();</span><br></pre></td></tr></table></figure><p>从输入流中取出的字节流就是 down.zip 文件从 2000070 开始的字节流。 大家看，其实断点续传用 Java 实现起来还是很简单的吧。 接下来要做的事就是怎么保存获得的流到文件中去了。</p><ol start="2"><li><strong>保存文件采用的方法</strong>。<br>我采用的是 IO 包中的 RandAccessFile 类。<br>操作相当简单，假设从 2000070 处开始保存文件，代码如下： </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RandomAccess oSavedFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"down.zip"</span>,<span class="string">"rw"</span>); </span><br><span class="line"><span class="keyword">long</span> nPos = <span class="number">2000070</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位文件指针到 nPos 位置 </span></span><br><span class="line">oSavedFile.seek(nPos); </span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; </span><br><span class="line"><span class="keyword">int</span> nRead; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入流中读入字节流，然后写到文件中 </span></span><br><span class="line"><span class="keyword">while</span>((nRead=input.read(b,<span class="number">0</span>,<span class="number">1024</span>)) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    oSavedFile.write(b,<span class="number">0</span>,nRead); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样，也很简单吧。 接下来要做的就是整合成一个完整的程序了。包括一系列的线程控制等等。</p><h3 id="断点续传内核的实现"><a href="#断点续传内核的实现" class="headerlink" title="断点续传内核的实现"></a>断点续传内核的实现</h3><p>主要用了 6 个类，包括一个测试类。 </p><ul><li><p>SiteFileFetch.java 负责整个文件的抓取，控制内部线程 (FileSplitterFetch 类 )。 </p></li><li><p>FileSplitterFetch.java 负责部分文件的抓取。 </p></li><li><p>FileAccess.java 负责文件的存储。 </p></li><li><p>SiteInfoBean.java 要抓取的文件的信息，如文件保存的目录，名字，抓取文件的 URL 等。 </p></li><li><p>Utility.java 工具类，放一些简单的方法。 </p></li><li><p>TestMethod.java 测试类。</p></li></ul><p>我们来分别看看代码：</p><ol><li>SiteFileFetch.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SiteFileFetch.java </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteFileFetch</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">SiteInfoBean siteInfoBean = <span class="keyword">null</span>; <span class="comment">// 文件信息 Bean </span></span><br><span class="line"><span class="keyword">long</span>[] nStartPos; <span class="comment">// 开始位置</span></span><br><span class="line"><span class="keyword">long</span>[] nEndPos; <span class="comment">// 结束位置</span></span><br><span class="line">FileSplitterFetch[] fileSplitterFetch; <span class="comment">// 子线程对象</span></span><br><span class="line"><span class="keyword">long</span> nFileLength; <span class="comment">// 文件长度</span></span><br><span class="line"><span class="keyword">boolean</span> bFirst = <span class="keyword">true</span>; <span class="comment">// 是否第一次取文件</span></span><br><span class="line"><span class="keyword">boolean</span> bStop = <span class="keyword">false</span>; <span class="comment">// 停止标志</span></span><br><span class="line">File tmpFile; <span class="comment">// 文件下载的临时信息</span></span><br><span class="line">DataOutputStream output; <span class="comment">// 输出到文件的输出流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SiteFileFetch</span><span class="params">(SiteInfoBean bean)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">siteInfoBean = bean;</span><br><span class="line"><span class="comment">//tmpFile = File.createTempFile ("zhong","1111",new File(bean.getSFilePath())); </span></span><br><span class="line">tmpFile = <span class="keyword">new</span> File(bean.getSFilePath()+File.separator + bean.getSFileName()+<span class="string">".info"</span>);</span><br><span class="line"><span class="keyword">if</span>(tmpFile.exists ())</span><br><span class="line">&#123;</span><br><span class="line">bFirst = <span class="keyword">false</span>;</span><br><span class="line">read_nPos();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nStartPos = <span class="keyword">new</span> <span class="keyword">long</span>[bean.getNSplitter()];</span><br><span class="line">nEndPos = <span class="keyword">new</span> <span class="keyword">long</span>[bean.getNSplitter()];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获得文件长度</span></span><br><span class="line"><span class="comment">// 分割文件</span></span><br><span class="line"><span class="comment">// 实例 FileSplitterFetch </span></span><br><span class="line"><span class="comment">// 启动 FileSplitterFetch 线程</span></span><br><span class="line"><span class="comment">// 等待子线程返回</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bFirst)&#123;</span><br><span class="line">nFileLength = getFileSize();</span><br><span class="line"><span class="keyword">if</span>(nFileLength == -<span class="number">1</span>)&#123;</span><br><span class="line">System.err.println(<span class="string">"File Length is not known!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nFileLength == -<span class="number">2</span>)&#123;</span><br><span class="line">System.err.println(<span class="string">"File is not access!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)&#123;</span><br><span class="line">nStartPos[i] = (<span class="keyword">long</span>)(i*(nFileLength/nStartPos.length));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nEndPos.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">nEndPos[i] = nStartPos[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">nEndPos[nEndPos.length-<span class="number">1</span>] = nFileLength;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动子线程</span></span><br><span class="line">fileSplitterFetch = <span class="keyword">new</span> FileSplitterFetch[nStartPos.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)&#123;</span><br><span class="line">fileSplitterFetch[i] = <span class="keyword">new</span> FileSplitterFetch(siteInfoBean.getSSiteURL(),</span><br><span class="line">siteInfoBean.getSFilePath() + File.separator + siteInfoBean.getSFileName(),</span><br><span class="line">nStartPos[i],nEndPos[i],i);</span><br><span class="line">Utility.log(<span class="string">"Thread "</span> + i + <span class="string">" , nStartPos = "</span> + nStartPos[i] + <span class="string">", nEndPos = "</span></span><br><span class="line">+ nEndPos[i]);</span><br><span class="line">fileSplitterFetch[i].start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fileSplitterFetch[nPos.length-1] = new FileSplitterFetch(siteInfoBean.getSSiteURL(),</span></span><br><span class="line">siteInfoBean.getSFilePath() + File.separator</span><br><span class="line">+ siteInfoBean.getSFileName(),nPos[nPos.length-<span class="number">1</span>],nFileLength,nPos.length-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Utility.log("Thread " +(nPos.length-1) + ",nStartPos = "+nPos[nPos.length-1]+", nEndPos = " + nFileLength); </span></span><br><span class="line"><span class="comment">// fileSplitterFetch[nPos.length-1].start(); </span></span><br><span class="line"><span class="comment">// 等待子线程结束</span></span><br><span class="line"><span class="comment">//int count = 0; </span></span><br><span class="line"><span class="comment">// 是否结束 while 循环</span></span><br><span class="line"><span class="keyword">boolean</span> breakWhile = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!bStop)&#123;</span><br><span class="line">write_nPos();</span><br><span class="line">Utility.sleep(<span class="number">500</span>);</span><br><span class="line">breakWhile = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!fileSplitterFetch[i].bDownOver)&#123;</span><br><span class="line">breakWhile = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(breakWhile)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//count++; </span></span><br><span class="line"><span class="comment">//if(count&gt;4) </span></span><br><span class="line"><span class="comment">//    siteStop(); </span></span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">"文件下载结束！"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nFileLength = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(siteInfoBean.getSSiteURL());</span><br><span class="line">HttpURLConnection httpConnection = (HttpURLConnection)url.openConnection ();</span><br><span class="line">httpConnection.setRequestProperty(<span class="string">"User-Agent"</span>,<span class="string">"NetFox"</span>);</span><br><span class="line"><span class="keyword">int</span> responseCode=httpConnection.getResponseCode();</span><br><span class="line"><span class="keyword">if</span>(responseCode&gt;=<span class="number">400</span>)&#123;</span><br><span class="line">processErrorCode(responseCode);</span><br><span class="line"><span class="keyword">return</span> -<span class="number">2</span>; <span class="comment">//-2 represent access is error </span></span><br><span class="line">&#125;</span><br><span class="line">String sHeader;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line"><span class="comment">//DataInputStream in = new DataInputStream(httpConnection.getInputStream ()); </span></span><br><span class="line"><span class="comment">//Utility.log(in.readLine()); </span></span><br><span class="line">sHeader=httpConnection.getHeaderFieldKey(i);</span><br><span class="line"><span class="keyword">if</span>(sHeader!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(sHeader.equals(<span class="string">"Content-Length"</span>))&#123;</span><br><span class="line">nFileLength = Integer.parseInt(httpConnection.getHeaderField(sHeader));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)&#123;e.printStackTrace ();&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace ();&#125;</span><br><span class="line">Utility.log(nFileLength);</span><br><span class="line"><span class="keyword">return</span> nFileLength;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存下载信息（文件指针位置）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write_nPos</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">output = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(tmpFile));</span><br><span class="line">output.writeInt(nStartPos.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)&#123;</span><br><span class="line"><span class="comment">// output.writeLong(nPos[i]); </span></span><br><span class="line">output.writeLong(fileSplitterFetch[i].nStartPos);</span><br><span class="line">output.writeLong(fileSplitterFetch[i].nEndPos);</span><br><span class="line">&#125;</span><br><span class="line">output.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)&#123;e.printStackTrace ();&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace ();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取保存的下载信息（文件指针位置）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read_nPos</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">DataInputStream input = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(tmpFile));</span><br><span class="line"><span class="keyword">int</span> nCount = input.readInt();</span><br><span class="line">nStartPos = <span class="keyword">new</span> <span class="keyword">long</span>[nCount];</span><br><span class="line">nEndPos = <span class="keyword">new</span> <span class="keyword">long</span>[nCount];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)&#123;</span><br><span class="line">nStartPos[i] = input.readLong();</span><br><span class="line">nEndPos[i] = input.readLong();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)&#123;e.printStackTrace ();&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace ();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processErrorCode</span><span class="params">(<span class="keyword">int</span> nErrorCode)</span></span>&#123;</span><br><span class="line">System.err.println(<span class="string">"Error Code : "</span> + nErrorCode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 停止文件下载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siteStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">bStop = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nStartPos.length;i++)</span><br><span class="line">fileSplitterFetch[i].splitterStop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>FileSplitterFetch.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *FileSplitterFetch.java </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSplitterFetch</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">String sURL; <span class="comment">//File URL </span></span><br><span class="line"><span class="keyword">long</span> nStartPos; <span class="comment">//File Snippet Start Position </span></span><br><span class="line"><span class="keyword">long</span> nEndPos; <span class="comment">//File Snippet End Position </span></span><br><span class="line"><span class="keyword">int</span> nThreadID; <span class="comment">//Thread's ID </span></span><br><span class="line"><span class="keyword">boolean</span> bDownOver = <span class="keyword">false</span>; <span class="comment">//Downing is over </span></span><br><span class="line"><span class="keyword">boolean</span> bStop = <span class="keyword">false</span>; <span class="comment">//Stop identical </span></span><br><span class="line">FileAccessI fileAccessI = <span class="keyword">null</span>; <span class="comment">//File Access interface </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSplitterFetch</span><span class="params">(String sURL,String sName,<span class="keyword">long</span> nStart,<span class="keyword">long</span> nEnd,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sURL = sURL;</span><br><span class="line"><span class="keyword">this</span>.nStartPos = nStart;</span><br><span class="line"><span class="keyword">this</span>.nEndPos = nEnd;</span><br><span class="line">nThreadID = id;</span><br><span class="line">fileAccessI = <span class="keyword">new</span> FileAccessI(sName,nStartPos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(nStartPos &lt; nEndPos &amp;&amp; !bStop)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(sURL);</span><br><span class="line">HttpURLConnection httpConnection = (HttpURLConnection)url.openConnection ();</span><br><span class="line">httpConnection.setRequestProperty(<span class="string">"User-Agent"</span>,<span class="string">"NetFox"</span>);</span><br><span class="line">String sProperty = <span class="string">"bytes="</span>+nStartPos+<span class="string">"-"</span>;</span><br><span class="line">httpConnection.setRequestProperty(<span class="string">"RANGE"</span>,sProperty);</span><br><span class="line">Utility.log(sProperty);</span><br><span class="line">InputStream input = httpConnection.getInputStream();</span><br><span class="line"><span class="comment">//logResponseHead(httpConnection); </span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> nRead;</span><br><span class="line"><span class="keyword">while</span>((nRead=input.read(b,<span class="number">0</span>,<span class="number">1024</span>)) &gt; <span class="number">0</span> &amp;&amp; nStartPos &lt; nEndPos</span><br><span class="line">&amp;&amp; !bStop) &#123;</span><br><span class="line">nStartPos += fileAccessI.write(b,<span class="number">0</span>,nRead);</span><br><span class="line"><span class="comment">//if(nThreadID == 1)</span></span><br><span class="line"><span class="comment">// Utility.log("nStartPos = " + nStartPos + ", nEndPos = " + nEndPos); </span></span><br><span class="line">&#125;</span><br><span class="line">Utility.log(<span class="string">"Thread "</span> + nThreadID + <span class="string">" is over!"</span>);</span><br><span class="line">bDownOver = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//nPos = fileAccessI.write (b,0,nRead); </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace ();&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印回应的头信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logResponseHead</span><span class="params">(HttpURLConnection con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line">String header=con.getHeaderFieldKey(i);</span><br><span class="line"><span class="keyword">if</span>(header!=<span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//responseHeaders.put(header,httpConnection.getHeaderField(header)); </span></span><br><span class="line">Utility.log(header+<span class="string">" : "</span>+con.getHeaderField(header));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitterStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">bStop = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>FileAccess.java </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *FileAccess.java </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAccessI</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">RandomAccessFile oSavedFile;</span><br><span class="line"><span class="keyword">long</span> nPos;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileAccessI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileAccessI</span><span class="params">(String sName,<span class="keyword">long</span> nPos)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">oSavedFile = <span class="keyword">new</span> RandomAccessFile(sName,<span class="string">"rw"</span>);</span><br><span class="line"><span class="keyword">this</span>.nPos = nPos;</span><br><span class="line">oSavedFile.seek(nPos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> nStart,<span class="keyword">int</span> nLen)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">oSavedFile.write(b,nStart,nLen);</span><br><span class="line">n = nLen;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">e.printStackTrace ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>SiteInfoBean.java </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *SiteInfoBean.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteInfoBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String sSiteURL; <span class="comment">//Site's URL</span></span><br><span class="line"><span class="keyword">private</span> String sFilePath; <span class="comment">//Saved File's Path</span></span><br><span class="line"><span class="keyword">private</span> String sFileName; <span class="comment">//Saved File's Name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nSplitter; <span class="comment">//Count of Splited Downloading File</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SiteInfoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//default value of nSplitter is 5</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SiteInfoBean</span><span class="params">(String sURL,String sPath,String sName,<span class="keyword">int</span> nSpiltter)</span> </span>&#123;</span><br><span class="line">sSiteURL= sURL;</span><br><span class="line">sFilePath = sPath;</span><br><span class="line">sFileName = sName;</span><br><span class="line"><span class="keyword">this</span>.nSplitter = nSpiltter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSSiteURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sSiteURL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSSiteURL</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">sSiteURL = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSFilePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sFilePath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSFilePath</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">sFilePath = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sFileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSFileName</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">sFileName = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNSplitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nSplitter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNSplitter</span><span class="params">(<span class="keyword">int</span> nCount)</span> </span>&#123;</span><br><span class="line">nSplitter = nCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Utility.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *Utility.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utility</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Utility</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> nSecond)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(nSecond);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String sMsg)</span> </span>&#123;</span><br><span class="line">System.err.println(sMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> sMsg)</span> </span>&#123;</span><br><span class="line">System.err.println(sMsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>TestMethod.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *TestMethod.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> NetFox;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestMethod</span><span class="params">()</span> </span>&#123; <span class="comment">///xx/weblogic60b2_win.exe</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">SiteInfoBean bean = <span class="keyword">new</span> SiteInfoBean(<span class="string">"http://localhost/xx/weblogic60b2_win.exe"</span>,</span><br><span class="line"><span class="string">"L:\\temp"</span>,<span class="string">"weblogic60b2_win.exe"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//SiteInfoBean bean = new SiteInfoBean("http://localhost:8080/down.zip","L:\\temp",</span></span><br><span class="line"><span class="string">"weblogic60b2_win.exe"</span>,<span class="number">5</span>);</span><br><span class="line">SiteFileFetch fileFetch = <span class="keyword">new</span> SiteFileFetch(bean);</span><br><span class="line">fileFetch.start();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> TestMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/joy-down/" target="_blank" rel="noopener">用 Java 实现断点续传 (HTTP) - IBM DeveloperWorks</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;断点续传的原理&quot;&gt;&lt;a href=&quot;#断点续传的原理&quot; class=&quot;headerlink&quot; title=&quot;断点续传的原理&quot;&gt;&lt;/a&gt;断点续传的原理&lt;/h3&gt;&lt;p&gt;其实断点续传的原理很简单，就是在 Http 的请求上和一般的下载有所不同而已。&lt;br&gt;打个比方，浏览器请求服务器上的一个文时，所发出的请求如下：&lt;br&gt;假设服务器域名为 &lt;a href=&quot;www.sjtu.edu.cn&quot;&gt;www.sjtu.edu.cn&lt;/a&gt;，文件名为 down.zip。 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET /down.zip HTTP/1.1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms- &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;excel, application/msword, application/vnd.ms-powerpoint, */* &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Accept-Language: zh-cn &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Accept-Encoding: gzip, deflate &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Connection: Keep-Alive&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;服务器收到请求后，按要求寻找请求的文件，提取文件的信息，然后返回给浏览器，返回信息如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;200 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Length=106786028 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Accept-Ranges=bytes &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date=Mon, 30 Apr 2001 12:56:11 GMT &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ETag=W/&amp;quot;02ca57e173c11:95b&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Type=application/octet-stream &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Server=Microsoft-IIS/5.0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Last-Modified=Mon, 30 Apr 2001 12:56:11 GMT&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://itimetraveler.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://itimetraveler.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
